
Filename: .dockerignore
Content:
# Git specific
.git
.gitignore

# IDE/Editor specific
.vscode/
*.code-workspace

# Go cache/modules (downloaded inside container)
vendor/

# Local environment files
.env*

# Build artifacts (if any created locally)
bin/
server

# OS specific
*~
.DS_Store

# Documentation/Scripts not needed in runtime image
README.md
scripts/
geoguessr.session.sql
repo_contents.txt
*.log

# Docker specific files (if they exist at root)
# Dockerfile
# docker-compose.yml
pg_dump
database.bak
backup.sql

================================================================================

Filename: .gitignore
Content:
.env
.vscode
repo_contents.txt
backup.sql
database.bak
pg_dump

================================================================================

Filename: Dockerfile
Content:
FROM golang:1.24-alpine AS builder

RUN apk add --no-cache ca-certificates git

WORKDIR /app

COPY go.mod go.sum ./
# Download dependencies
RUN go mod download

# Copy the entire application source code
COPY . .

# Build the Go application
# - CGO_ENABLED=0: Build without CGo for a static binary (good for Alpine/Scratch)
# - -ldflags="-w -s": Optimize the binary size (-w removes DWARF symbols, -s removes symbol table)
# - -o /app/server: Specify the output binary path
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags="-w -s" -o /app/server ./cmd/server/main.go

#---------------------------------------------------------------------
# Stage 2: Runtime Stage - Create the minimal final image
#---------------------------------------------------------------------
# Use a minimal Alpine base image
FROM alpine:3.21

# Install ca-certificates for HTTPS requests (if your app makes external calls)
# GORM might need this for SSL connections to the DB
RUN apk add --no-cache ca-certificates tzdata

# Create a non-root user and group for security
RUN addgroup -S appgroup && adduser -S appuser -G appgroup

# Set the working directory for the non-root user
WORKDIR /home/appuser

# Copy the compiled binary from the builder stage
# Change ownership to the non-root user
COPY --from=builder --chown=appuser:appgroup /app/server /home/appuser/server

# Copy the Swagger documentation files needed by the handler at runtime
# The gin-swagger handler might serve these static files or reference swagger.json/yaml
COPY --from=builder --chown=appuser:appgroup /app/docs /home/appuser/docs

# Switch to the non-root user
USER appuser

# Expose the port the application listens on (Cloud Run uses $PORT, default 8080)
# Your current main.go listens on :8080, which matches the default.
EXPOSE 8080

# Command to run the application when the container starts
CMD ["./server"]

================================================================================

Filename: cmd/server/main.go
Content:
package main

import (
	"log"
	"net/http"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
	"github.com/joho/godotenv"

	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"

	"github.com/go-openapi/runtime/middleware"

	_ "geoguessr-backend/docs" // for swagger docs
	"geoguessr-backend/internal/database"
	"geoguessr-backend/internal/handlers"
	internalMiddleware "geoguessr-backend/internal/middleware"
	"geoguessr-backend/internal/utils"
)

// @title           TerraQuest Backend API
// @version         1.0
// @description     API Server for the TerraQuest GeoGuessr clone game.
// @termsOfService  http://swagger.io/terms/  <-- Update later

// @contact.name   API Support
// @contact.url    http://www.example.com/support <-- Update later
// @contact.email  support@example.com <-- Update later

// @license.name  Apache 2.0  <-- Or your chosen license
// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html

// @host      localhost:8080
// @BasePath  /api/v1

// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
// @description Type "Bearer" followed by a space and JWT token.

func main() {
	log.Println("Starting GeoGuessr Backend Server...")

	err := godotenv.Load()
	if err != nil {
		log.Println("No .env file found, using system environment variables.")
	}

	utils.InitializeJWT()

	err = database.Connect()
	if err != nil {
		log.Fatalf("Could not connect to the database: %v", err)
	}

	router := gin.Default()

	config := cors.DefaultConfig()

	// Allow specific origins instead of all origins
	config.AllowOrigins = []string{"http://localhost:5173", "https://rudra-garg.github.io"}
	config.AllowMethods = []string{"GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"}
	config.AllowHeaders = []string{"Origin", "Content-Type", "Accept", "Authorization"}
	config.AllowCredentials = true // This is required for credentials to work
	config.ExposeHeaders = []string{"Content-Length"}

	router.Use(cors.New(config))

	router.GET("/docs/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
	log.Println("Swagger UI available at http://localhost:8080/docs/index.html")

	opts := middleware.RedocOpts{
		SpecURL: "/docs/doc.json",
		Path:    "/redoc",
		Title:   "TerraQuest API Docs (ReDoc)",
	}
	redocHandler := middleware.Redoc(opts, nil)
	router.GET("/redoc", gin.WrapH(redocHandler))
	log.Println("ReDoc UI available at http://localhost:8080/redoc")

	api := router.Group("/api/v1")
	{
		authGroup := api.Group("/auth")
		{
			authGroup.POST("/register", handlers.Register)
			authGroup.POST("/login", handlers.Login)
		}

		// Game routes - apply auth middleware here
		gameGroup := api.Group("/game")
		// Apply AuthRequired middleware to all routes within this group
		gameGroup.Use(internalMiddleware.AuthRequired()) // <<< APPLY MIDDLEWARE
		{
			gameGroup.GET("/start", handlers.StartGame)
			gameGroup.POST("/finish", handlers.FinishGame)
		}

		// Multiplayer game routes
		multiplayerGroup := api.Group("/multiplayer")
		{
			// Routes that require authentication
			authMultiplayerGroup := multiplayerGroup.Group("/")
			authMultiplayerGroup.Use(internalMiddleware.AuthRequired())
			{
				authMultiplayerGroup.POST("/create", handlers.CreateMultiplayerGame)
				authMultiplayerGroup.POST("/join/:gameCode", handlers.JoinMultiplayerGame)
				authMultiplayerGroup.GET("/game/:gameId", handlers.GetMultiplayerGameState)
			}

			// WebSocket endpoint - auth is handled in the handler
			multiplayerGroup.GET("/ws", handlers.HandleWebSocket)
		}
	}

	router.GET("/ping", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"message": "pong"})
	})

	port := ":8080"
	log.Printf("Server listening on port %s\n", port)
	err = router.Run(port)
	if err != nil {
		log.Fatalf("Failed to start server: %v", err)
	}
}


================================================================================

Filename: docs/docs.go
Content:
// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/  \u003c-- Update later",
        "contact": {
            "name": "API Support",
            "url": "http://www.example.com/support \u003c-- Update later",
            "email": "support@example.com \u003c-- Update later"
        },
        "license": {
            "name": "Apache 2.0  \u003c-- Or your chosen license",
            "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/auth/login": {
            "post": {
                "description": "Authenticates a user with email and password, returns a JWT token upon success.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Log in a user",
                "parameters": [
                    {
                        "description": "User Login Credentials",
                        "name": "credentials",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.LoginInput"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Login successful (returns JWT token and basic user info)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid input format or validation failed",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "Invalid credentials (user not found or password mismatch)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal server error (DB find, token generation)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/auth/register": {
            "post": {
                "description": "Creates a new user account with username, email, and password.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Register a new user",
                "parameters": [
                    {
                        "description": "User Registration Info",
                        "name": "userInput",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.RegisterInput"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "User registered successfully (returns basic user info)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid input format or validation failed",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "409": {
                        "description": "Conflict: Username or Email already exists",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal server error (hashing, DB create)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/game/start": {
            "get": {
                "description": "Fetches a specified number of random locations for a new game session.",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Game"
                ],
                "summary": "Start a new game",
                "parameters": [
                    {
                        "maximum": 10,
                        "type": "integer",
                        "description": "Number of rounds (default: 5)",
                        "name": "rounds",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Game started successfully (returns gameId placeholder and locations)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error (failed to fetch locations)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "models.LoginInput": {
            "type": "object",
            "required": [
                "email",
                "password"
            ],
            "properties": {
                "email": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                }
            }
        },
        "models.RegisterInput": {
            "type": "object",
            "required": [
                "email",
                "password",
                "username"
            ],
            "properties": {
                "email": {
                    "type": "string"
                },
                "password": {
                    "type": "string",
                    "maxLength": 72,
                    "minLength": 6
                },
                "username": {
                    "type": "string",
                    "maxLength": 50,
                    "minLength": 3
                }
            }
        }
    },
    "securityDefinitions": {
        "BearerAuth": {
            "description": "Type \"Bearer\" followed by a space and JWT token.",
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &swag.Spec{
	Version:          "1.0",
	Host:             "localhost:8080",
	BasePath:         "/api/v1",
	Schemes:          []string{},
	Title:            "TerraQuest Backend API",
	Description:      "API Server for the TerraQuest GeoGuessr clone game.",
	InfoInstanceName: "swagger",
	SwaggerTemplate:  docTemplate,
	LeftDelim:        "{{",
	RightDelim:       "}}",
}

func init() {
	swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}


================================================================================

Filename: docs/swagger.json
Content:
{
    "swagger": "2.0",
    "info": {
        "description": "API Server for the TerraQuest GeoGuessr clone game.",
        "title": "TerraQuest Backend API",
        "termsOfService": "http://swagger.io/terms/  \u003c-- Update later",
        "contact": {
            "name": "API Support",
            "url": "http://www.example.com/support \u003c-- Update later",
            "email": "support@example.com \u003c-- Update later"
        },
        "license": {
            "name": "Apache 2.0  \u003c-- Or your chosen license",
            "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
        },
        "version": "1.0"
    },
    "host": "localhost:8080",
    "basePath": "/api/v1",
    "paths": {
        "/auth/login": {
            "post": {
                "description": "Authenticates a user with email and password, returns a JWT token upon success.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Log in a user",
                "parameters": [
                    {
                        "description": "User Login Credentials",
                        "name": "credentials",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.LoginInput"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Login successful (returns JWT token and basic user info)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid input format or validation failed",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "Invalid credentials (user not found or password mismatch)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal server error (DB find, token generation)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/auth/register": {
            "post": {
                "description": "Creates a new user account with username, email, and password.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Register a new user",
                "parameters": [
                    {
                        "description": "User Registration Info",
                        "name": "userInput",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.RegisterInput"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "User registered successfully (returns basic user info)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid input format or validation failed",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "409": {
                        "description": "Conflict: Username or Email already exists",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal server error (hashing, DB create)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/game/start": {
            "get": {
                "description": "Fetches a specified number of random locations for a new game session.",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Game"
                ],
                "summary": "Start a new game",
                "parameters": [
                    {
                        "maximum": 10,
                        "type": "integer",
                        "description": "Number of rounds (default: 5)",
                        "name": "rounds",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Game started successfully (returns gameId placeholder and locations)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error (failed to fetch locations)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "models.LoginInput": {
            "type": "object",
            "required": [
                "email",
                "password"
            ],
            "properties": {
                "email": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                }
            }
        },
        "models.RegisterInput": {
            "type": "object",
            "required": [
                "email",
                "password",
                "username"
            ],
            "properties": {
                "email": {
                    "type": "string"
                },
                "password": {
                    "type": "string",
                    "maxLength": 72,
                    "minLength": 6
                },
                "username": {
                    "type": "string",
                    "maxLength": 50,
                    "minLength": 3
                }
            }
        }
    },
    "securityDefinitions": {
        "BearerAuth": {
            "description": "Type \"Bearer\" followed by a space and JWT token.",
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}

================================================================================

Filename: docs/swagger.yaml
Content:
basePath: /api/v1
definitions:
  models.LoginInput:
    properties:
      email:
        type: string
      password:
        type: string
    required:
    - email
    - password
    type: object
  models.RegisterInput:
    properties:
      email:
        type: string
      password:
        maxLength: 72
        minLength: 6
        type: string
      username:
        maxLength: 50
        minLength: 3
        type: string
    required:
    - email
    - password
    - username
    type: object
host: localhost:8080
info:
  contact:
    email: support@example.com <-- Update later
    name: API Support
    url: http://www.example.com/support <-- Update later
  description: API Server for the TerraQuest GeoGuessr clone game.
  license:
    name: Apache 2.0  <-- Or your chosen license
    url: http://www.apache.org/licenses/LICENSE-2.0.html
  termsOfService: http://swagger.io/terms/  <-- Update later
  title: TerraQuest Backend API
  version: "1.0"
paths:
  /auth/login:
    post:
      consumes:
      - application/json
      description: Authenticates a user with email and password, returns a JWT token
        upon success.
      parameters:
      - description: User Login Credentials
        in: body
        name: credentials
        required: true
        schema:
          $ref: '#/definitions/models.LoginInput'
      produces:
      - application/json
      responses:
        "200":
          description: Login successful (returns JWT token and basic user info)
          schema:
            additionalProperties: true
            type: object
        "400":
          description: Invalid input format or validation failed
          schema:
            additionalProperties:
              type: string
            type: object
        "401":
          description: Invalid credentials (user not found or password mismatch)
          schema:
            additionalProperties:
              type: string
            type: object
        "500":
          description: Internal server error (DB find, token generation)
          schema:
            additionalProperties:
              type: string
            type: object
      summary: Log in a user
      tags:
      - Auth
  /auth/register:
    post:
      consumes:
      - application/json
      description: Creates a new user account with username, email, and password.
      parameters:
      - description: User Registration Info
        in: body
        name: userInput
        required: true
        schema:
          $ref: '#/definitions/models.RegisterInput'
      produces:
      - application/json
      responses:
        "201":
          description: User registered successfully (returns basic user info)
          schema:
            additionalProperties: true
            type: object
        "400":
          description: Invalid input format or validation failed
          schema:
            additionalProperties:
              type: string
            type: object
        "409":
          description: 'Conflict: Username or Email already exists'
          schema:
            additionalProperties:
              type: string
            type: object
        "500":
          description: Internal server error (hashing, DB create)
          schema:
            additionalProperties:
              type: string
            type: object
      summary: Register a new user
      tags:
      - Auth
  /game/start:
    get:
      description: Fetches a specified number of random locations for a new game session.
      parameters:
      - description: 'Number of rounds (default: 5)'
        in: query
        maximum: 10
        name: rounds
        type: integer
      produces:
      - application/json
      responses:
        "200":
          description: Game started successfully (returns gameId placeholder and locations)
          schema:
            additionalProperties: true
            type: object
        "500":
          description: Internal server error (failed to fetch locations)
          schema:
            additionalProperties:
              type: string
            type: object
      summary: Start a new game
      tags:
      - Game
securityDefinitions:
  BearerAuth:
    description: Type "Bearer" followed by a space and JWT token.
    in: header
    name: Authorization
    type: apiKey
swagger: "2.0"


================================================================================

Filename: geoguessr.session.sql
Content:
DROP table users;

================================================================================

Filename: go.mod
Content:
module geoguessr-backend

go 1.23.4

require (
	github.com/KyleBanks/depth v1.2.1 // indirect
	github.com/PuerkitoBio/purell v1.2.1 // indirect
	github.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578 // indirect
	github.com/asaskevich/govalidator v0.0.0-20230301143203-a9d515a09cc2 // indirect
	github.com/bytedance/sonic v1.13.2 // indirect
	github.com/bytedance/sonic/loader v0.2.4 // indirect
	github.com/cloudwego/base64x v0.1.5 // indirect
	github.com/cloudwego/iasm v0.2.0 // indirect
	github.com/cpuguy83/go-md2man/v2 v2.0.6 // indirect
	github.com/gabriel-vasile/mimetype v1.4.8 // indirect
	github.com/gin-contrib/cors v1.7.5 // indirect
	github.com/gin-contrib/sse v1.1.0 // indirect
	github.com/gin-gonic/gin v1.10.0 // indirect
	github.com/go-openapi/analysis v0.23.0 // indirect
	github.com/go-openapi/errors v0.22.0 // indirect
	github.com/go-openapi/jsonpointer v0.21.1 // indirect
	github.com/go-openapi/jsonreference v0.21.0 // indirect
	github.com/go-openapi/loads v0.22.0 // indirect
	github.com/go-openapi/runtime v0.28.0 // indirect
	github.com/go-openapi/spec v0.21.0 // indirect
	github.com/go-openapi/strfmt v0.23.0 // indirect
	github.com/go-openapi/swag v0.23.1 // indirect
	github.com/go-openapi/validate v0.24.0 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/go-playground/validator/v10 v10.26.0 // indirect
	github.com/goccy/go-json v0.10.5 // indirect
	github.com/golang-jwt/jwt/v5 v5.2.2 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/gorilla/websocket v1.5.3 // indirect
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 // indirect
	github.com/jackc/pgx/v5 v5.7.4 // indirect
	github.com/jackc/puddle/v2 v2.2.2 // indirect
	github.com/jinzhu/inflection v1.0.0 // indirect
	github.com/jinzhu/now v1.1.5 // indirect
	github.com/joho/godotenv v1.5.1 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/klauspost/cpuid/v2 v2.2.10 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/mailru/easyjson v0.9.0 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mitchellh/mapstructure v1.5.0 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/oklog/ulid v1.3.1 // indirect
	github.com/pelletier/go-toml/v2 v2.2.4 // indirect
	github.com/russross/blackfriday/v2 v2.1.0 // indirect
	github.com/shurcooL/sanitized_anchor_name v1.0.0 // indirect
	github.com/swaggo/files v1.0.1 // indirect
	github.com/swaggo/gin-swagger v1.6.0 // indirect
	github.com/swaggo/swag v1.16.4 // indirect
	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
	github.com/ugorji/go/codec v1.2.12 // indirect
	github.com/urfave/cli/v2 v2.27.6 // indirect
	github.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1 // indirect
	go.mongodb.org/mongo-driver v1.14.0 // indirect
	golang.org/x/arch v0.16.0 // indirect
	golang.org/x/crypto v0.37.0 // indirect
	golang.org/x/net v0.39.0 // indirect
	golang.org/x/sync v0.13.0 // indirect
	golang.org/x/sys v0.32.0 // indirect
	golang.org/x/text v0.24.0 // indirect
	golang.org/x/tools v0.32.0 // indirect
	google.golang.org/protobuf v1.36.6 // indirect
	gopkg.in/yaml.v2 v2.4.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
	gorm.io/driver/postgres v1.5.11 // indirect
	gorm.io/gorm v1.25.12 // indirect
	sigs.k8s.io/yaml v1.4.0 // indirect
)


================================================================================

Filename: go.sum
Content:
github.com/KyleBanks/depth v1.2.1 h1:5h8fQADFrWtarTdtDudMmGsC7GPbOAu6RVB3ffsVFHc=
github.com/KyleBanks/depth v1.2.1/go.mod h1:jzSb9d0L43HxTQfT+oSA1EEp2q+ne2uh6XgeJcm8brE=
github.com/PuerkitoBio/purell v1.2.1 h1:QsZ4TjvwiMpat6gBCBxEQI0rcS9ehtkKtSpiUnd9N28=
github.com/PuerkitoBio/purell v1.2.1/go.mod h1:ZwHcC/82TOaovDi//J/804umJFFmbOHPngi8iYYv/Eo=
github.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578 h1:d+Bc7a5rLufV/sSk/8dngufqelfh6jnri85riMAaF/M=
github.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578/go.mod h1:uGdkoq3SwY9Y+13GIhn11/XLaGBb4BfwItxLd5jeuXE=
github.com/asaskevich/govalidator v0.0.0-20230301143203-a9d515a09cc2 h1:DklsrG3dyBCFEj5IhUbnKptjxatkF07cF2ak3yi77so=
github.com/asaskevich/govalidator v0.0.0-20230301143203-a9d515a09cc2/go.mod h1:WaHUgvxTVq04UNunO+XhnAqY/wQc+bxr74GqbsZ/Jqw=
github.com/bytedance/sonic v1.13.2 h1:8/H1FempDZqC4VqjptGo14QQlJx8VdZJegxs6wwfqpQ=
github.com/bytedance/sonic v1.13.2/go.mod h1:o68xyaF9u2gvVBuGHPlUVCy+ZfmNNO5ETf1+KgkJhz4=
github.com/bytedance/sonic/loader v0.1.1/go.mod h1:ncP89zfokxS5LZrJxl5z0UJcsk4M4yY2JpfqGeCtNLU=
github.com/bytedance/sonic/loader v0.2.4 h1:ZWCw4stuXUsn1/+zQDqeE7JKP+QO47tz7QCNan80NzY=
github.com/bytedance/sonic/loader v0.2.4/go.mod h1:N8A3vUdtUebEY2/VQC0MyhYeKUFosQU6FxH2JmUe6VI=
github.com/cloudwego/base64x v0.1.5 h1:XPciSp1xaq2VCSt6lF0phncD4koWyULpl5bUxbfCyP4=
github.com/cloudwego/base64x v0.1.5/go.mod h1:0zlkT4Wn5C6NdauXdJRhSKRlJvmclQ1hhJgA0rcu/8w=
github.com/cloudwego/iasm v0.2.0 h1:1KNIy1I1H9hNNFEEH3DVnI4UujN+1zjpuk6gwHLTssg=
github.com/cloudwego/iasm v0.2.0/go.mod h1:8rXZaNYT2n95jn+zTI1sDr+IgcD2GVs0nlbbQPiEFhY=
github.com/cpuguy83/go-md2man/v2 v2.0.6 h1:XJtiaUW6dEEqVuZiMTn1ldk455QWwEIsMIJlo5vtkx0=
github.com/cpuguy83/go-md2man/v2 v2.0.6/go.mod h1:oOW0eioCTA6cOiMLiUPZOpcVxMig6NIQQ7OS05n1F4g=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/gabriel-vasile/mimetype v1.4.8 h1:FfZ3gj38NjllZIeJAmMhr+qKL8Wu+nOoI3GqacKw1NM=
github.com/gabriel-vasile/mimetype v1.4.8/go.mod h1:ByKUIKGjh1ODkGM1asKUbQZOLGrPjydw3hYPU2YU9t8=
github.com/gin-contrib/cors v1.7.5 h1:cXC9SmofOrRg0w9PigwGlHG3ztswH6bqq4vJVXnvYMk=
github.com/gin-contrib/cors v1.7.5/go.mod h1:4q3yi7xBEDDWKapjT2o1V7mScKDDr8k+jZ0fSquGoy0=
github.com/gin-contrib/sse v1.1.0 h1:n0w2GMuUpWDVp7qSpvze6fAu9iRxJY4Hmj6AmBOU05w=
github.com/gin-contrib/sse v1.1.0/go.mod h1:hxRZ5gVpWMT7Z0B0gSNYqqsSCNIJMjzvm6fqCz9vjwM=
github.com/gin-gonic/gin v1.10.0 h1:nTuyha1TYqgedzytsKYqna+DfLos46nTv2ygFy86HFU=
github.com/gin-gonic/gin v1.10.0/go.mod h1:4PMNQiOhvDRa013RKVbsiNwoyezlm2rm0uX/T7kzp5Y=
github.com/go-openapi/analysis v0.23.0 h1:aGday7OWupfMs+LbmLZG4k0MYXIANxcuBTYUC03zFCU=
github.com/go-openapi/analysis v0.23.0/go.mod h1:9mz9ZWaSlV8TvjQHLl2mUW2PbZtemkE8yA5v22ohupo=
github.com/go-openapi/errors v0.22.0 h1:c4xY/OLxUBSTiepAg3j/MHuAv5mJhnf53LLMWFB+u/w=
github.com/go-openapi/errors v0.22.0/go.mod h1:J3DmZScxCDufmIMsdOuDHxJbdOGC0xtUynjIx092vXE=
github.com/go-openapi/jsonpointer v0.21.1 h1:whnzv/pNXtK2FbX/W9yJfRmE2gsmkfahjMKB0fZvcic=
github.com/go-openapi/jsonpointer v0.21.1/go.mod h1:50I1STOfbY1ycR8jGz8DaMeLCdXiI6aDteEdRNNzpdk=
github.com/go-openapi/jsonreference v0.21.0 h1:Rs+Y7hSXT83Jacb7kFyjn4ijOuVGSvOdF2+tg1TRrwQ=
github.com/go-openapi/jsonreference v0.21.0/go.mod h1:LmZmgsrTkVg9LG4EaHeY8cBDslNPMo06cago5JNLkm4=
github.com/go-openapi/loads v0.22.0 h1:ECPGd4jX1U6NApCGG1We+uEozOAvXvJSF4nnwHZ8Aco=
github.com/go-openapi/loads v0.22.0/go.mod h1:yLsaTCS92mnSAZX5WWoxszLj0u+Ojl+Zs5Stn1oF+rs=
github.com/go-openapi/runtime v0.28.0 h1:gpPPmWSNGo214l6n8hzdXYhPuJcGtziTOgUpvsFWGIQ=
github.com/go-openapi/runtime v0.28.0/go.mod h1:QN7OzcS+XuYmkQLw05akXk0jRH/eZ3kb18+1KwW9gyc=
github.com/go-openapi/spec v0.21.0 h1:LTVzPc3p/RzRnkQqLRndbAzjY0d0BCL72A6j3CdL9ZY=
github.com/go-openapi/spec v0.21.0/go.mod h1:78u6VdPw81XU44qEWGhtr982gJ5BWg2c0I5XwVMotYk=
github.com/go-openapi/strfmt v0.23.0 h1:nlUS6BCqcnAk0pyhi9Y+kdDVZdZMHfEKQiS4HaMgO/c=
github.com/go-openapi/strfmt v0.23.0/go.mod h1:NrtIpfKtWIygRkKVsxh7XQMDQW5HKQl6S5ik2elW+K4=
github.com/go-openapi/swag v0.23.1 h1:lpsStH0n2ittzTnbaSloVZLuB5+fvSY/+hnagBjSNZU=
github.com/go-openapi/swag v0.23.1/go.mod h1:STZs8TbRvEQQKUA+JZNAm3EWlgaOBGpyFDqQnDHMef0=
github.com/go-openapi/validate v0.24.0 h1:LdfDKwNbpB6Vn40xhTdNZAnfLECL81w+VX3BumrGD58=
github.com/go-openapi/validate v0.24.0/go.mod h1:iyeX1sEufmv3nPbBdX3ieNviWnOZaJ1+zquzJEf2BAQ=
github.com/go-playground/locales v0.14.1 h1:EWaQ/wswjilfKLTECiXz7Rh+3BjFhfDFKv/oXslEjJA=
github.com/go-playground/locales v0.14.1/go.mod h1:hxrqLVvrK65+Rwrd5Fc6F2O76J/NuW9t0sjnWqG1slY=
github.com/go-playground/universal-translator v0.18.1 h1:Bcnm0ZwsGyWbCzImXv+pAJnYK9S473LQFuzCbDbfSFY=
github.com/go-playground/universal-translator v0.18.1/go.mod h1:xekY+UJKNuX9WP91TpwSH2VMlDf28Uj24BCp08ZFTUY=
github.com/go-playground/validator/v10 v10.26.0 h1:SP05Nqhjcvz81uJaRfEV0YBSSSGMc/iMaVtFbr3Sw2k=
github.com/go-playground/validator/v10 v10.26.0/go.mod h1:I5QpIEbmr8On7W0TktmJAumgzX4CA1XNl4ZmDuVHKKo=
github.com/goccy/go-json v0.10.5 h1:Fq85nIqj+gXn/S5ahsiTlK3TmC85qgirsdTP/+DeaC4=
github.com/goccy/go-json v0.10.5/go.mod h1:oq7eo15ShAhp70Anwd5lgX2pLfOS3QCiwU/PULtXL6M=
github.com/golang-jwt/jwt/v5 v5.2.2 h1:Rl4B7itRWVtYIHFrSNd7vhTiz9UpLdi6gZhZ3wEeDy8=
github.com/golang-jwt/jwt/v5 v5.2.2/go.mod h1:pqrtFR0X4osieyHYxtmOUWsAWrfe1Q5UVIyoH402zdk=
github.com/google/go-cmp v0.5.9/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
github.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/gorilla/websocket v1.5.3 h1:saDtZ6Pbx/0u+bgYQ3q96pZgCzfhKXGPqt7kZ72aNNg=
github.com/gorilla/websocket v1.5.3/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=
github.com/jackc/pgpassfile v1.0.0 h1:/6Hmqy13Ss2zCq62VdNG8tM1wchn8zjSGOBJ6icpsIM=
github.com/jackc/pgpassfile v1.0.0/go.mod h1:CEx0iS5ambNFdcRtxPj5JhEz+xB6uRky5eyVu/W2HEg=
github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 h1:iCEnooe7UlwOQYpKFhBabPMi4aNAfoODPEFNiAnClxo=
github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761/go.mod h1:5TJZWKEWniPve33vlWYSoGYefn3gLQRzjfDlhSJ9ZKM=
github.com/jackc/pgx/v5 v5.7.4 h1:9wKznZrhWa2QiHL+NjTSPP6yjl3451BX3imWDnokYlg=
github.com/jackc/pgx/v5 v5.7.4/go.mod h1:ncY89UGWxg82EykZUwSpUKEfccBGGYq1xjrOpsbsfGQ=
github.com/jackc/puddle/v2 v2.2.2 h1:PR8nw+E/1w0GLuRFSmiioY6UooMp6KJv0/61nB7icHo=
github.com/jackc/puddle/v2 v2.2.2/go.mod h1:vriiEXHvEE654aYKXXjOvZM39qJ0q+azkZFrfEOc3H4=
github.com/jinzhu/inflection v1.0.0 h1:K317FqzuhWc8YvSVlFMCCUb36O/S9MCKRDI7QkRKD/E=
github.com/jinzhu/inflection v1.0.0/go.mod h1:h+uFLlag+Qp1Va5pdKtLDYj+kHp5pxUVkryuEj+Srlc=
github.com/jinzhu/now v1.1.5 h1:/o9tlHleP7gOFmsnYNz3RGnqzefHA47wQpKrrdTIwXQ=
github.com/jinzhu/now v1.1.5/go.mod h1:d3SSVoowX0Lcu0IBviAWJpolVfI5UJVZZ7cO71lE/z8=
github.com/joho/godotenv v1.5.1 h1:7eLL/+HRGLY0ldzfGMeQkb7vMd0as4CfYvUVzLqw0N0=
github.com/joho/godotenv v1.5.1/go.mod h1:f4LDr5Voq0i2e/R5DDNOoa2zzDfwtkZa6DnEwAbqwq4=
github.com/josharian/intern v1.0.0 h1:vlS4z54oSdjm0bgjRigI+G1HpF+tI+9rE5LLzOg8HmY=
github.com/josharian/intern v1.0.0/go.mod h1:5DoeVV0s6jJacbCEi61lwdGj/aVlrQvzHFFd8Hwg//Y=
github.com/json-iterator/go v1.1.12 h1:PV8peI4a0ysnczrg+LtxykD8LfKY9ML6u2jnxaEnrnM=
github.com/json-iterator/go v1.1.12/go.mod h1:e30LSqwooZae/UwlEbR2852Gd8hjQvJoHmT4TnhNGBo=
github.com/klauspost/cpuid/v2 v2.0.9/go.mod h1:FInQzS24/EEf25PyTYn52gqo7WaD8xa0213Md/qVLRg=
github.com/klauspost/cpuid/v2 v2.2.10 h1:tBs3QSyvjDyFTq3uoc/9xFpCuOsJQFNPiAhYdw2skhE=
github.com/klauspost/cpuid/v2 v2.2.10/go.mod h1:hqwkgyIinND0mEev00jJYCxPNVRVXFQeu1XKlok6oO0=
github.com/knz/go-libedit v1.10.1/go.mod h1:MZTVkCWyz0oBc7JOWP3wNAzd002ZbM/5hgShxwh4x8M=
github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
github.com/leodido/go-urn v1.4.0 h1:WT9HwE9SGECu3lg4d/dIA+jxlljEa1/ffXKmRjqdmIQ=
github.com/leodido/go-urn v1.4.0/go.mod h1:bvxc+MVxLKB4z00jd1z+Dvzr47oO32F/QSNjSBOlFxI=
github.com/mailru/easyjson v0.9.0 h1:PrnmzHw7262yW8sTBwxi1PdJA3Iw/EKBa8psRf7d9a4=
github.com/mailru/easyjson v0.9.0/go.mod h1:1+xMtQp2MRNVL/V1bOzuP3aP8VNwRW55fQUto+XFtTU=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/mitchellh/mapstructure v1.5.0 h1:jeMsZIYE/09sWLaz43PL7Gy6RuMjD2eJVyuac5Z2hdY=
github.com/mitchellh/mapstructure v1.5.0/go.mod h1:bFUtVrKA4DC2yAKiSyO/QUcy7e+RRV2QTWOzhPopBRo=
github.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd h1:TRLaZ9cD/w8PVh93nsPXa1VrQ6jlwL5oN8l14QlcNfg=
github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
github.com/modern-go/reflect2 v1.0.2 h1:xBagoLtFs94CBntxluKeaWgTMpvLxC4ur3nMaC9Gz0M=
github.com/modern-go/reflect2 v1.0.2/go.mod h1:yWuevngMOJpCy52FWWMvUC8ws7m/LJsjYzDa0/r8luk=
github.com/oklog/ulid v1.3.1 h1:EGfNDEx6MqHz8B3uNV6QAib1UR2Lm97sHi3ocA6ESJ4=
github.com/oklog/ulid v1.3.1/go.mod h1:CirwcVhetQ6Lv90oh/F+FBtV6XMibvdAFo93nm5qn4U=
github.com/pelletier/go-toml/v2 v2.2.4 h1:mye9XuhQ6gvn5h28+VilKrrPoQVanw5PMw/TB0t5Ec4=
github.com/pelletier/go-toml/v2 v2.2.4/go.mod h1:2gIqNv+qfxSVS7cM2xJQKtLSTLUE9V8t9Stt+h56mCY=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/russross/blackfriday/v2 v2.1.0 h1:JIOH55/0cWyOuilr9/qlrm0BSXldqnqwMsf35Ld67mk=
github.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=
github.com/shurcooL/sanitized_anchor_name v1.0.0 h1:PdmoCO6wvbs+7yrJyMORt4/BmY5IYyJwS/kOiWx8mHo=
github.com/shurcooL/sanitized_anchor_name v1.0.0/go.mod h1:1NzhyTcUVG4SuEtjjoZeVRXNmyL/1OwPU0+IJeTBvfc=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=
github.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=
github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=
github.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
github.com/swaggo/files v1.0.1 h1:J1bVJ4XHZNq0I46UU90611i9/YzdrF7x92oX1ig5IdE=
github.com/swaggo/files v1.0.1/go.mod h1:0qXmMNH6sXNf+73t65aKeB+ApmgxdnkQzVTAj2uaMUg=
github.com/swaggo/gin-swagger v1.6.0 h1:y8sxvQ3E20/RCyrXeFfg60r6H0Z+SwpTjMYsMm+zy8M=
github.com/swaggo/gin-swagger v1.6.0/go.mod h1:BG00cCEy294xtVpyIAHG6+e2Qzj/xKlRdOqDkvq0uzo=
github.com/swaggo/swag v1.16.4 h1:clWJtd9LStiG3VeijiCfOVODP6VpHtKdQy9ELFG3s1A=
github.com/swaggo/swag v1.16.4/go.mod h1:VBsHJRsDvfYvqoiMKnsdwhNV9LEMHgEDZcyVYX0sxPg=
github.com/twitchyliquid64/golang-asm v0.15.1 h1:SU5vSMR7hnwNxj24w34ZyCi/FmDZTkS4MhqMhdFk5YI=
github.com/twitchyliquid64/golang-asm v0.15.1/go.mod h1:a1lVb/DtPvCB8fslRZhAngC2+aY1QWCk3Cedj/Gdt08=
github.com/ugorji/go/codec v1.2.12 h1:9LC83zGrHhuUA9l16C9AHXAqEV/2wBQ4nkvumAE65EE=
github.com/ugorji/go/codec v1.2.12/go.mod h1:UNopzCgEMSXjBc6AOMqYvWC1ktqTAfzJZUZgYf6w6lg=
github.com/urfave/cli/v2 v2.27.6 h1:VdRdS98FNhKZ8/Az8B7MTyGQmpIr36O1EHybx/LaZ4g=
github.com/urfave/cli/v2 v2.27.6/go.mod h1:3Sevf16NykTbInEnD0yKkjDAeZDS0A6bzhBH5hrMvTQ=
github.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1 h1:gEOO8jv9F4OT7lGCjxCBTO/36wtF6j2nSip77qHd4x4=
github.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1/go.mod h1:Ohn+xnUBiLI6FVj/9LpzZWtj1/D6lUovWYBkxHVV3aM=
github.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=
go.mongodb.org/mongo-driver v1.14.0 h1:P98w8egYRjYe3XDjxhYJagTokP/H6HzlsnojRgZRd80=
go.mongodb.org/mongo-driver v1.14.0/go.mod h1:Vzb0Mk/pa7e6cWw85R4F/endUC3u0U9jGcNU603k65c=
golang.org/x/arch v0.16.0 h1:foMtLTdyOmIniqWCHjY6+JxuC54XP1fDwx4N0ASyW+U=
golang.org/x/arch v0.16.0/go.mod h1:JmwW7aLIoRUKgaTzhkiEFxvcEiQGyOg9BMonBJUS7EE=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=
golang.org/x/crypto v0.37.0 h1:kJNSjF/Xp7kU0iB2Z+9viTPMW4EqqsrywMXLJOOsXSE=
golang.org/x/crypto v0.37.0/go.mod h1:vg+k43peMZ0pUMhYmVAWysMK35e6ioLh3wB8ZCAfbVc=
golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=
golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
golang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=
golang.org/x/net v0.7.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=
golang.org/x/net v0.39.0 h1:ZCu7HMWDxpXpaiKdhzIfaltL9Lp31x/3fCP11bc6/fY=
golang.org/x/net v0.39.0/go.mod h1:X7NRbYVEA+ewNkCNyJ513WmMdQ3BineSwVtN2zD/d+E=
golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.13.0 h1:AauUjRAJ9OSnvULf/ARrrVywoJDy0YS2AwQ98I37610=
golang.org/x/sync v0.13.0/go.mod h1:1dzgHSNfp02xaA81J2MS99Qcpr2w7fw1gpm99rleRqA=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.32.0 h1:s77OFDvIQeibCmezSnk/q6iAfkdiQaJi4VzroCFrN20=
golang.org/x/sys v0.32.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=
golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=
golang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=
golang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=
golang.org/x/text v0.24.0 h1:dd5Bzh4yt5KYA8f9CJHCP4FB4D51c2c6JvN37xJJkJ0=
golang.org/x/text v0.24.0/go.mod h1:L8rBsPeo2pSS+xqN0d5u2ikmjtmoJbDBT1b7nHvFCdU=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=
golang.org/x/tools v0.32.0 h1:Q7N1vhpkQv7ybVzLFtTjvQya2ewbwNDZzUgfXGqtMWU=
golang.org/x/tools v0.32.0/go.mod h1:ZxrU41P/wAbZD8EDa6dDCa6XfpkhJ7HFMjHJXfBDu8s=
golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
google.golang.org/protobuf v1.36.6 h1:z1NpPI8ku2WgiWnf+t9wTPsn6eP1L7ksHUlkfLvd9xY=
google.golang.org/protobuf v1.36.6/go.mod h1:jduwjTPXsFjZGTmRluh+L6NjiWu7pchiJ2/5YcXBHnY=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=
gopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gorm.io/driver/postgres v1.5.11 h1:ubBVAfbKEUld/twyKZ0IYn9rSQh448EdelLYk9Mv314=
gorm.io/driver/postgres v1.5.11/go.mod h1:DX3GReXH+3FPWGrrgffdvCk3DQ1dwDPdmbenSkweRGI=
gorm.io/gorm v1.25.12 h1:I0u8i2hWQItBq1WfE0o2+WuL9+8L21K9e2HHSTE/0f8=
gorm.io/gorm v1.25.12/go.mod h1:xh7N7RHfYlNc5EmcI/El95gXusucDrQnHXe0+CgWcLQ=
nullprogram.com/x/optparse v1.0.0/go.mod h1:KdyPE+Igbe0jQUrVfMqDMeJQIJZEuyV7pjYmp6pbG50=
rsc.io/pdf v0.1.1/go.mod h1:n8OzWcQ6Sp37PL01nO98y4iUCRdTGarVfzxY20ICaU4=
sigs.k8s.io/yaml v1.4.0 h1:Mk1wCc2gy/F0THH0TAp1QYyJNzRm2KCLy3o5ASXVI5E=
sigs.k8s.io/yaml v1.4.0/go.mod h1:Ejl7/uTz7PSA4eKMyQCUTnhZYNmLIl+5c2lQPGR2BPY=


================================================================================

Filename: internal/database/database.go
Content:
package database

import (
	"fmt"
	"log"
	"os"
	"time"

	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"

	"geoguessr-backend/internal/models"
)

var DB *gorm.DB

func Connect() error {

	dbHost := os.Getenv("DB_HOST")
	if dbHost == "" {
		dbHost = "localhost"
	}
	dbPort := os.Getenv("DB_PORT")
	if dbPort == "" {
		dbPort = "5432"
	}
	dbUser := os.Getenv("DB_USER")
	if dbUser == "" {
		dbUser = "postgres"
	}
	dbPassword := os.Getenv("DB_PASSWORD")
	if dbPassword == "" {
		log.Println("WARNING: DB_PASSWORD environment variable not set.")

		dbPassword = "mysecretpassword"
	}
	dbName := os.Getenv("DB_NAME")
	if dbName == "" {
		dbName = "geoguessr"
	}
	dbSSLMode := os.Getenv("DB_SSLMODE")
	if dbSSLMode == "" {
		dbSSLMode = "disable"
	}

	dsn := fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%s sslmode=%s TimeZone=UTC",
		dbHost, dbUser, dbPassword, dbName, dbPort, dbSSLMode)

	logLevel := logger.Warn // <<< Change from logger.Info to logger.Warn
	if os.Getenv("GORM_LOG_LEVEL") == "info" {
		logLevel = logger.Info // Allow overriding via env var if needed
	}

	newLogger := logger.New(
		log.New(os.Stdout, "\r\n", log.LstdFlags), // io writer
		logger.Config{
			SlowThreshold:             time.Second * 2, // Slow SQL threshold (optional)
			LogLevel:                  logLevel,        // Set the desired log level
			IgnoreRecordNotFoundError: true,            // Don't log ErrRecordNotFound errors (usually expected)
			ParameterizedQueries:      false,           // Don't include params in Info level logs (optional)
			Colorful:                  true,            // Enable color (optional)
		},
	)
	// ---------------------------

	var err error
	DB, err = gorm.Open(postgres.Open(dsn), &gorm.Config{
		Logger: newLogger, // <<< Use the configured logger
	})

	if err != nil {
		return fmt.Errorf("failed to connect to database: %w", err)
	}

	log.Println("Database connection established successfully.")
	log.Println("Running auto migrations...")
	err = DB.AutoMigrate(
		&models.Location{},
		&models.User{},
		&models.Game{},
		&models.Round{},
		&models.MultiplayerGame{},
		&models.MultiplayerSession{},
		&models.MultiplayerRound{},
	)
	if err != nil {
		return fmt.Errorf("failed to auto migrate database: %w", err)
	}
	log.Println("Auto migrations completed.")

	return nil
}

func GetDB() *gorm.DB {
	return DB
}


================================================================================

Filename: internal/handlers/auth_handler.go
Content:

package handlers

import (
	"log"
	"net/http"
	"strings" 

	"geoguessr-backend/internal/database" 
	"geoguessr-backend/internal/models"    
	"geoguessr-backend/internal/utils"     

	"github.com/gin-gonic/gin"
	"github.com/go-playground/validator/v10" 
	"golang.org/x/crypto/bcrypt"
	"gorm.io/gorm"
)


var validate = validator.New()

// Register godoc
// @Summary      Register a new user
// @Description  Creates a new user account with username, email, and password.
// @Tags         Auth
// @Accept       json
// @Produce      json
// @Param        userInput body models.RegisterInput true "User Registration Info"
// @Success      201  {object}  map[string]interface{}  "User registered successfully (returns basic user info)"
// @Failure      400  {object}  map[string]string "Invalid input format or validation failed"
// @Failure      409  {object}  map[string]string "Conflict: Username or Email already exists"
// @Failure      500  {object}  map[string]string "Internal server error (hashing, DB create)"
// @Router       /auth/register [post]
func Register(c *gin.Context) {
	var input models.RegisterInput

	
	if err := c.ShouldBindJSON(&input); err != nil {
		log.Printf("Register Error - Binding: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input format"})
		return
	}

	
	if err := validate.Struct(input); err != nil {
		log.Printf("Register Error - Validation: %v", err)
		
		c.JSON(http.StatusBadRequest, gin.H{"error": "Validation failed: " + err.Error()})
		return
	}

	db := database.GetDB()

	
	var existingUser models.User
	err := db.Where("email = ? OR username = ?", input.Email, input.Username).First(&existingUser).Error
	if err == nil {
		
		errorMsg := "Conflict: "
		if strings.EqualFold(existingUser.Email, input.Email) { 
			errorMsg += "Email already exists."
		} else {
			errorMsg += "Username already exists."
		}
		log.Printf("Register Error - Conflict: %s", errorMsg)
		c.JSON(http.StatusConflict, gin.H{"error": errorMsg})
		return
	} else if err != gorm.ErrRecordNotFound {
		
		log.Printf("Register Error - DB Check: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Database error checking user existence"})
		return
	}
	

	
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		log.Printf("Register Error - Hashing: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to process password"})
		return
	}

	
	newUser := models.User{
		Username:     input.Username,
		Email:        input.Email,
		PasswordHash: string(hashedPassword),
	}

	
	result := db.Create(&newUser)
	if result.Error != nil {
		log.Printf("Register Error - DB Create: %v", result.Error)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to register user"})
		return
	}

	log.Printf("User registered successfully: %s (%s)", newUser.Username, newUser.Email)
	
	c.JSON(http.StatusCreated, gin.H{
		"message": "User registered successfully",
		"user": gin.H{
			"id":       newUser.ID,
			"username": newUser.Username,
			"email":    newUser.Email,
		},
	})
}

// Login godoc
// @Summary      Log in a user
// @Description  Authenticates a user with email and password, returns a JWT token upon success.
// @Tags         Auth
// @Accept       json
// @Produce      json
// @Param        credentials body models.LoginInput true "User Login Credentials"
// @Success      200  {object}  map[string]interface{} "Login successful (returns JWT token and basic user info)"
// @Failure      400  {object}  map[string]string "Invalid input format or validation failed"
// @Failure      401  {object}  map[string]string "Invalid credentials (user not found or password mismatch)"
// @Failure      500  {object}  map[string]string "Internal server error (DB find, token generation)"
// @Router       /auth/login [post]
func Login(c *gin.Context) {
	var input models.LoginInput

	
	if err := c.ShouldBindJSON(&input); err != nil {
		log.Printf("Login Error - Binding: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input format"})
		return
	}

	
	if err := validate.Struct(input); err != nil {
		log.Printf("Login Error - Validation: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Validation failed: " + err.Error()})
		return
	}

	db := database.GetDB()
	var user models.User

	
	
	
	result := db.Where("email = ?", input.Email).First(&user) 
	if result.Error != nil {
		if result.Error == gorm.ErrRecordNotFound {
			log.Printf("Login Error - User not found: %s", input.Email)
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"}) 
		} else {
			log.Printf("Login Error - DB Find: %v", result.Error)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Database error finding user"})
		}
		return
	}

	
	err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(input.Password))
	if err != nil {
		
		log.Printf("Login Error - Password mismatch for user: %s", input.Email)
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"}) 
		return
	}

	
	token, err := utils.GenerateToken(user.ID)
	if err != nil {
		log.Printf("Login Error - Token Generation: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to generate login token"})
		return
	}

	log.Printf("User logged in successfully: %s (%d)", user.Username, user.ID)
	
	c.JSON(http.StatusOK, gin.H{
		"message": "Login successful",
		"token":   token,
		"user": gin.H{ 
			"id":       user.ID,
			"username": user.Username,
			"email":    user.Email,
		},
	})
}

================================================================================

Filename: internal/handlers/game_handler.go
Content:
package handlers

import (
	"log"
	"net/http"
	"strconv"
	"time"

	"geoguessr-backend/internal/database"
	"geoguessr-backend/internal/models"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
)

const defaultRounds = 5

type GameLocationResponse struct {
	ID        uint    `json:"id"`
	Latitude  float64 `json:"lat"`
	Longitude float64 `json:"lng"`
}

// StartGame godoc
// @Summary      Start a new game
// @Description  Fetches a specified number of random locations for a new game session.
// @Tags         Game
// @Produce      json
// @Param        rounds query int false "Number of rounds (default: 5)" mininum(1) maximum(10)
// @Success      200 {object} map[string]interface{} "Game started successfully (returns gameId placeholder and locations)"
// @Failure      500 {object} map[string]string "Internal server error (failed to fetch locations)"
// @Router       /game/start [get]
func StartGame(c *gin.Context) {
	log.Println("Handler: StartGame invoked")

	roundsStr := c.DefaultQuery("rounds", strconv.Itoa(defaultRounds))
	rounds, err := strconv.Atoi(roundsStr)
	if err != nil || rounds <= 0 {
		rounds = defaultRounds
	}
	log.Printf("Handler: Requesting %d rounds", rounds)

	db := database.GetDB()

	var locations []models.Location
	var responseLocations []GameLocationResponse

	result := db.Model(&models.Location{}).
		Order("RANDOM()").
		Limit(rounds).
		Find(&locations)

	if result.Error != nil {
		log.Printf("Error fetching locations: %v", result.Error)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch game locations"})
		return
	}

	if len(locations) < rounds {

		log.Printf("Warning: Found only %d locations, requested %d", len(locations), rounds)

		if len(locations) == 0 {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "No locations found in database"})
			return
		}
	}

	for _, loc := range locations {
		responseLocations = append(responseLocations, GameLocationResponse{
			ID:        loc.ID,
			Latitude:  loc.Latitude,
			Longitude: loc.Longitude,
		})
	}

	log.Printf("Handler: Successfully fetched %d locations", len(responseLocations))
	c.JSON(http.StatusOK, gin.H{
		"gameId":    "mock_backend_game_" + strconv.Itoa(int(time.Now().Unix())),
		"locations": responseLocations,
	})
}

// FinishGame saves the results of a completed game
// @Summary      Submit game results
// @Description  Saves the total score and round details for a completed game session for the authenticated user.
// @Tags         Game
// @Accept       json
// @Produce      json
// @Param        gameResult body models.SubmitGameInput true "Completed Game Data"
// @Success      201  {object}  map[string]interface{} "Game results saved successfully"
// @Failure      400  {object}  map[string]string "Invalid input format or validation failed"
// @Failure      401  {object}  map[string]string "Unauthorized (invalid/missing token)"
// @Failure      500  {object}  map[string]string "Internal server error (database error)"
// @Security     BearerAuth
// @Router       /game/finish [post]
func FinishGame(c *gin.Context) {
	var input models.SubmitGameInput
	var newGame models.Game // <<< Declare newGame OUTSIDE the transaction scope

	// 1. Get User ID from context
	userIDAny, exists := c.Get("userID")
	if !exists {
		log.Println("FinishGame Error: userID not found in context")
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User authentication not found"})
		return
	}
	userID, ok := userIDAny.(uint)
	if !ok {
		log.Println("FinishGame Error: userID in context is not uint")
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Internal server error processing user identity"})
		return
	}
	log.Printf("FinishGame Handler: Processing submission for user ID: %d", userID)

	// 2. Bind JSON input
	if err := c.ShouldBindJSON(&input); err != nil {
		log.Printf("FinishGame Error - Binding: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input format: " + err.Error()})
		return
	}

	// 3. Validate input struct
	if err := validate.Struct(input); err != nil {
		log.Printf("FinishGame Error - Validation: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Validation failed: " + err.Error()})
		return
	}

	db := database.GetDB()

	// --- Save Game and Rounds within a Transaction ---
	err := db.Transaction(func(tx *gorm.DB) error {
		// 4. Create the main Game record
		// Assign to the newGame declared outside
		newGame = models.Game{
			UserID:       userID,
			TotalScore:   input.TotalScore,
			RoundsPlayed: input.RoundsPlayed,
		}
		if err := tx.Create(&newGame).Error; err != nil {
			log.Printf("FinishGame Error - DB Create Game: %v", err)
			return err
		}
		log.Printf("FinishGame - Created Game record ID: %d", newGame.ID)

		// 5. Create Round records linked to the Game
		for _, roundInput := range input.Rounds {
			newRound := models.Round{
				GameID:      newGame.ID, // Use ID from the created game
				LocationID:  roundInput.LocationID,
				RoundNumber: roundInput.RoundNumber,
				GuessLat:    roundInput.GuessLat,
				GuessLng:    roundInput.GuessLng,
				ActualLat:   roundInput.ActualLat,
				ActualLng:   roundInput.ActualLng,
				DistanceKm:  roundInput.DistanceKm,
				Score:       roundInput.Score,
			}
			if err := tx.Create(&newRound).Error; err != nil {
				log.Printf("FinishGame Error - DB Create Round %d: %v", roundInput.RoundNumber, err)
				return err
			}
		}
		log.Printf("FinishGame - Successfully created %d Round records for Game ID: %d", len(input.Rounds), newGame.ID)
		return nil
	})
	// --- End Transaction ---

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to save game results due to database error"})
		return
	}

	// 6. Return Success Response (newGame is now accessible here)
	log.Printf("FinishGame - Successfully saved results for User ID: %d", userID)
	c.JSON(http.StatusCreated, gin.H{
		"message": "Game results saved successfully",
		"gameId":  newGame.ID,
	})
}


================================================================================

Filename: internal/handlers/multiplayer_handler.go
Content:
// internal/handlers/multiplayer_handler.go
package handlers

import (
	"math/rand"
	"net/http"
	"time"
	"strings"

	"github.com/gin-gonic/gin"
	
	"geoguessr-backend/internal/database"
	"geoguessr-backend/internal/models"
)

const gameCodeLength = 6
const gameCodeChars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789" // Omitting easily confused characters

// Generates a random game code for multiplayer games
func generateGameCode() string {
	rand.Seed(time.Now().UnixNano())
	code := make([]byte, gameCodeLength)
	for i := range code {
		code[i] = gameCodeChars[rand.Intn(len(gameCodeChars))]
	}
	return string(code)
}

// CreateMultiplayerGame creates a new multiplayer game
func CreateMultiplayerGame(c *gin.Context) {
	userID := c.GetUint("userID") // From auth middleware
	
	var input struct {
		MaxPlayers  int `json:"maxPlayers" binding:"required,min=2,max=8"`
		RoundsTotal int `json:"roundsTotal" binding:"required,min=1,max=10"`
	}
	
	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	
	// Generate unique game code
	gameCode := generateGameCode()
	
	// Check if code already exists and regenerate if needed
	for i := 0; i < 5; i++ { // Try up to 5 times
		var existingGame models.MultiplayerGame
		if database.DB.Where("game_code = ?", gameCode).First(&existingGame).Error != nil {
			// No game found with this code, it's unique
			break
		}
		// Code exists, generate a new one
		gameCode = generateGameCode()
	}
	
	// Get random locations for the game
	var locations []models.Location
	if err := database.DB.Order("RANDOM()").Limit(input.RoundsTotal).Find(&locations).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get game locations"})
		return
	}
	
	if len(locations) < input.RoundsTotal {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Not enough locations available"})
		return
	}
	
	// Create multiplayer game in DB
	game := models.MultiplayerGame{
		HostUserID:   userID,
		GameCode:     gameCode,
		Status:       "waiting",
		MaxPlayers:   input.MaxPlayers,
		RoundsTotal:  input.RoundsTotal,
		CurrentRound: 0,
		Locations:    locations,
	}
	
	// Save game to database
	if err := database.DB.Create(&game).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create game"})
		return
	}
	
	// Create host session
	session := models.MultiplayerSession{
		GameID:    game.ID,
		UserID:    userID,
		IsHost:    true,
		IsReady:   false,
		IsActive:  true,
		JoinedAt:  time.Now(),
	}
	
	if err := database.DB.Create(&session).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create host session"})
		return
	}
	
	c.JSON(http.StatusOK, gin.H{
		"gameCode": gameCode,
		"gameId":   game.ID,
	})
}

// JoinMultiplayerGame allows a player to join an existing game
func JoinMultiplayerGame(c *gin.Context) {
	userID := c.GetUint("userID")
	gameCode := c.Param("gameCode")
	
	// Normalize game code (uppercase)
	gameCode = strings.ToUpper(gameCode)
	
	var game models.MultiplayerGame
	if err := database.DB.Where("game_code = ? AND status = 'waiting'", gameCode).First(&game).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Game not found or already started"})
		return
	}
	
	// Check if game is full
	var count int64
	database.DB.Model(&models.MultiplayerSession{}).Where("game_id = ? AND is_active = true", game.ID).Count(&count)
	if int(count) >= game.MaxPlayers {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Game is full"})
		return
	}
	
	// Check if player already joined
	var existingSession models.MultiplayerSession
	result := database.DB.Where("game_id = ? AND user_id = ?", game.ID, userID).First(&existingSession)
	if result.Error == nil {
		// Player already joined, update session
		existingSession.IsActive = true
		database.DB.Save(&existingSession)
		c.JSON(http.StatusOK, gin.H{"gameId": game.ID})
		return
	}
	
	// Create new session
	session := models.MultiplayerSession{
		GameID:    game.ID,
		UserID:    userID,
		IsHost:    false,
		IsReady:   false,
		IsActive:  true,
		JoinedAt:  time.Now(),
	}
	
	if err := database.DB.Create(&session).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to join game"})
		return
	}
	
	c.JSON(http.StatusOK, gin.H{"gameId": game.ID})
}

// GetMultiplayerGameState returns the current state of a multiplayer game
func GetMultiplayerGameState(c *gin.Context) {
	gameID := c.Param("gameId")
	userID := c.GetUint("userID")
	
	var game models.MultiplayerGame
	if err := database.DB.Preload("PlayerSessions.User").Preload("Locations").First(&game, gameID).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Game not found"})
		return
	}
	
	// Check if user is a participant
	var isParticipant bool
	for _, session := range game.PlayerSessions {
		if session.UserID == userID && session.IsActive {
			isParticipant = true
			break
		}
	}
	
	if !isParticipant {
		c.JSON(http.StatusForbidden, gin.H{"error": "You are not a participant in this game"})
		return
	}
	
	// Prepare player data (exclude sensitive info)
	type PlayerInfo struct {
		UserID    uint   `json:"userId"`
		Username  string `json:"username"`
		IsHost    bool   `json:"isHost"`
		IsReady   bool   `json:"isReady"`
		TotalScore int   `json:"totalScore"`
	}
	
	players := make([]PlayerInfo, 0)
	for _, session := range game.PlayerSessions {
		if session.IsActive {
			players = append(players, PlayerInfo{
				UserID:     session.UserID,
				Username:   session.User.Username,
				IsHost:     session.IsHost,
				IsReady:    session.IsReady,
				TotalScore: session.TotalScore,
			})
		}
	}
	
	// Only send location data if game is in progress
	var locationsData []gin.H
	if game.Status == "in_progress" || game.Status == "completed" {
		locationsData = make([]gin.H, len(game.Locations))
		for i, loc := range game.Locations {
			locationsData[i] = gin.H{
				"id":  loc.ID,
				"lat": loc.Latitude,
				"lng": loc.Longitude,
			}
		}
	}
	
	c.JSON(http.StatusOK, gin.H{
		"gameId":       game.ID,
		"gameCode":     game.GameCode,
		"status":       game.Status,
		"currentRound": game.CurrentRound,
		"roundsTotal":  game.RoundsTotal,
		"players":      players,
		"locations":    locationsData,
	})
} 

================================================================================

Filename: internal/handlers/websocket.go
Content:
// internal/handlers/websocket.go
package handlers

import (
	"encoding/json"
	"log"
	"net/http"
	"sync"

	"github.com/gin-gonic/gin"
	"github.com/gorilla/websocket"

	"geoguessr-backend/internal/database"
	"geoguessr-backend/internal/models"
	"geoguessr-backend/internal/utils"
)

// PlayerInfo holds data about a connected player
type PlayerInfo struct {
	Conn     *websocket.Conn `json:"-"` // Exclude connection from JSON
	Username string          `json:"username"`
	UserID   uint            `json:"userId"`
	IsHost   bool            `json:"isHost"`
	IsReady  bool            `json:"isReady"`
}

var (
	// Configure WebSocket upgrader
	upgrader = websocket.Upgrader{
		ReadBufferSize:  1024,
		WriteBufferSize: 1024,
		CheckOrigin: func(r *http.Request) bool {
			// Allow specific origins
			origin := r.Header.Get("Origin")
			allowedOrigins := []string{"http://localhost:5173", "https://rudra-garg.github.io"}
			for _, allowedOrigin := range allowedOrigins {
				if origin == allowedOrigin {
					return true
				}
			}
			return false
		},
	}

	// Map to track active game rooms: gameCode -> userID -> PlayerInfo
	gameRooms = struct {
		sync.RWMutex
		rooms map[string]map[uint]*PlayerInfo
	}{
		rooms: make(map[string]map[uint]*PlayerInfo),
	}
)

// Message types for WebSocket communication
const (
	MsgTypePlayerJoin       = "player_join"
	MsgTypePlayerLeave      = "player_leave"
	MsgTypeGameStart        = "game_start"
	MsgTypeRoundStart       = "round_start"
	MsgTypeGuessSubmit      = "guess_submit"
	MsgTypeRoundEnd         = "round_end"
	MsgTypeGameEnd          = "game_end"
	MsgTypePlayerReady      = "player_ready"
	MsgTypeChatMessage      = "chat_message"
	MsgTypePlayerListUpdate = "player_list_update" // New message type
)

// WSMessage struct for WebSocket communication
type WSMessage struct {
	Type    string          `json:"type"`
	Payload json.RawMessage `json:"payload"`
	GameID  string          `json:"gameId"`
	UserID  uint            `json:"userId"` // UserID of the sender
}

// HandleWebSocket handles WebSocket connections for multiplayer games
func HandleWebSocket(c *gin.Context) {
	// Get token from query param
	token := c.Query("token")
	if token == "" {
		log.Println("No token provided for WebSocket connection")
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
		return
	}

	// Validate token
	parsedToken, err := utils.ValidateToken(token)
	if err != nil {
		log.Printf("Invalid token: %v", err)
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid authentication token"})
		return
	}

	// Extract user ID from token
	userId, err := utils.ExtractUserIDFromToken(parsedToken)
	if err != nil {
		log.Printf("Failed to extract user ID: %v", err)
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid user ID in token"})
		return
	}

	// Upgrade HTTP connection to WebSocket
	conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
	if err != nil {
		log.Printf("Failed to upgrade connection: %v", err)
		return
	}
	defer conn.Close()

	// Get game code from query param
	gameCode := c.Query("gameCode")
	if gameCode == "" {
		log.Println("No game code provided")
		conn.WriteJSON(gin.H{"error": "No game code provided"})
		return
	}

	// Get username from database
	var user models.User
	if err := database.DB.First(&user, userId).Error; err != nil {
		log.Printf("Could not find user with ID %d: %v", userId, err)
		conn.WriteJSON(gin.H{"error": "User not found"})
		return
	}
	username := user.Username

	// Create PlayerInfo
	player := &PlayerInfo{
		Conn:     conn,
		Username: username,
		UserID:   userId,
		IsHost:   false,
		IsReady:  false,
	}

	// Add player to game room
	gameRooms.Lock()
	if _, exists := gameRooms.rooms[gameCode]; !exists {
		gameRooms.rooms[gameCode] = make(map[uint]*PlayerInfo)
		player.IsHost = true // First player is the host
	}
	gameRooms.rooms[gameCode][userId] = player

	// Get current players list BEFORE unlocking
	roomPlayers := make([]*PlayerInfo, 0)
	for _, p := range gameRooms.rooms[gameCode] {
		roomPlayers = append(roomPlayers, &PlayerInfo{
			Username: p.Username,
			UserID:   p.UserID,
			IsHost:   p.IsHost,
			IsReady:  p.IsReady,
		})
	}
	gameRooms.Unlock()

	log.Printf("Player %s (ID: %d) connected to game %s. Host: %t", username, userId, gameCode, player.IsHost)
	log.Printf("Current players in room %s: %+v", gameCode, roomPlayers)

	// First send the current list of players to the newly joined player
	sendPlayerListUpdate(conn, gameCode, roomPlayers)

	// Then broadcast the new player's arrival to everyone else
	broadcastPlayerUpdate(gameCode, player, MsgTypePlayerJoin, conn)

	// Finally, broadcast the updated player list to everyone
	broadcastPlayerListUpdate(gameCode, roomPlayers, nil)

	// Remove player and notify others on disconnect
	defer func() {
		gameRooms.Lock()
		delete(gameRooms.rooms[gameCode], userId)
		// If room is empty, remove it
		if len(gameRooms.rooms[gameCode]) == 0 {
			delete(gameRooms.rooms, gameCode)
			log.Printf("Game room %s closed.", gameCode)
		} else {
			// Notify remaining players
			remainingPlayers := getCurrentPlayers(gameCode)
			gameRooms.Unlock() // Unlock before broadcasting
			broadcastPlayerUpdate(gameCode, player, MsgTypePlayerLeave, nil)
			broadcastPlayerListUpdate(gameCode, remainingPlayers, nil)
		}
		// Ensure unlock happens if not done above
		if gameRooms.TryLock() {
			gameRooms.Unlock()
		}
	}()

	// Message handling loop
	for {
		var msg WSMessage
		err := conn.ReadJSON(&msg)
		if err != nil {
			if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
				log.Printf("Error reading message: %v", err)
			} else {
				log.Printf("Player %s (ID: %d) closed connection for game %s.", username, userId, gameCode)
			}
			break
		}

		log.Printf("Raw message received from %d: %s", userId, msg.Payload)

		// Set the user ID from the authenticated connection
		msg.UserID = userId

		// Process message based on its type
		handleWSMessage(msg, player, gameCode)
	}
}

// getCurrentPlayers safely gets a list of players in a room
func getCurrentPlayers(gameCode string) []*PlayerInfo {
	gameRooms.RLock()
	defer gameRooms.RUnlock()

	room, exists := gameRooms.rooms[gameCode]
	if !exists {
		return []*PlayerInfo{} // Return empty array instead of nil
	}

	players := make([]*PlayerInfo, 0, len(room))
	for _, player := range room {
		// Create a copy without the WebSocket connection
		players = append(players, &PlayerInfo{
			Username: player.Username,
			UserID:   player.UserID,
			IsHost:   player.IsHost,
			IsReady:  player.IsReady,
		})
	}
	return players
}

// sendPlayerListUpdate sends the full player list to a specific connection
func sendPlayerListUpdate(conn *websocket.Conn, gameCode string, players []*PlayerInfo) {
	if players == nil {
		players = []*PlayerInfo{} // Ensure we never send null
	}

	msg := WSMessage{
		Type:    MsgTypePlayerListUpdate,
		Payload: json.RawMessage("[]"), // Initialize with empty array
		GameID:  gameCode,
	}

	// Marshal the players list
	if playersData, err := json.Marshal(players); err == nil {
		msg.Payload = json.RawMessage(playersData)
	} else {
		log.Printf("Error marshaling player list: %v", err)
		return
	}

	if err := conn.WriteJSON(msg); err != nil {
		log.Printf("Error sending player list update: %v", err)
	} else {
		log.Printf("Sent player list update to player: %+v", players)
	}
}

// broadcastPlayerListUpdate sends the full player list to all connections in a room (except sender if specified)
func broadcastPlayerListUpdate(gameCode string, players []*PlayerInfo, sender *websocket.Conn) {
	gameRooms.RLock()
	room, exists := gameRooms.rooms[gameCode]
	if !exists {
		gameRooms.RUnlock()
		return
	}
	gameRooms.RUnlock()

	msg := WSMessage{
		Type:    MsgTypePlayerListUpdate,
		Payload: json.RawMessage("[]"), // Initialize with empty array
	}

	// Marshal the players list
	if playersData, err := json.Marshal(players); err == nil {
		msg.Payload = json.RawMessage(playersData)
	}

	// Broadcast to all players except sender
	for _, player := range room {
		if sender == nil || player.Conn != sender {
			if err := player.Conn.WriteJSON(msg); err != nil {
				log.Printf("Error broadcasting player list update to %d: %v", player.UserID, err)
			}
		}
	}
}

// broadcastPlayerUpdate sends a message about a specific player's action (join/leave/ready)
func broadcastPlayerUpdate(gameCode string, playerInfo *PlayerInfo, messageType string, sender *websocket.Conn) {
	// Create a copy of player info without the WebSocket connection
	playerCopy := &PlayerInfo{
		Username: playerInfo.Username,
		UserID:   playerInfo.UserID,
		IsHost:   playerInfo.IsHost,
		IsReady:  playerInfo.IsReady,
	}

	// Marshal the player info
	payloadBytes, err := json.Marshal(playerCopy)
	if err != nil {
		log.Printf("Error marshaling player info for broadcast (%s): %v", messageType, err)
		return
	}

	msg := WSMessage{
		Type:    messageType,
		Payload: json.RawMessage(payloadBytes),
		GameID:  gameCode,
		UserID:  playerInfo.UserID,
	}

	gameRooms.RLock()
	defer gameRooms.RUnlock()

	if room, exists := gameRooms.rooms[gameCode]; exists {
		log.Printf("Broadcasting %s for player %d to game %s (excluding sender: %t)",
			messageType, playerInfo.UserID, gameCode, sender != nil)

		for _, p := range room {
			if sender == nil || p.Conn != sender {
				log.Printf("Sending %s update about %d to player %d",
					messageType, playerInfo.UserID, p.UserID)
				if err := p.Conn.WriteJSON(msg); err != nil {
					log.Printf("Error broadcasting %s update to %d: %v",
						messageType, p.UserID, err)
				}
			}
		}
	}
}

// handleWSMessage processes incoming WebSocket messages
func handleWSMessage(msg WSMessage, senderInfo *PlayerInfo, gameCode string) {
	gameRooms.Lock() // Use Lock for potential modifications
	room, exists := gameRooms.rooms[gameCode]
	if !exists {
		gameRooms.Unlock()
		log.Printf("Game room %s does not exist for message type %s", gameCode, msg.Type)
		return
	}

	player, playerExists := room[senderInfo.UserID]
	if !playerExists {
		gameRooms.Unlock()
		log.Printf("Player %d not found in game room %s for message type %s", senderInfo.UserID, gameCode, msg.Type)
		return
	}
	gameRooms.Unlock() // Unlock after read, relock if needed for write

	switch msg.Type {
	case MsgTypePlayerJoin:
		// Update player info from the join message
		var joinData struct {
			Username string `json:"username"`
			UserID   uint   `json:"userId"`
			IsHost   bool   `json:"isHost"`
		}
		if err := json.Unmarshal(msg.Payload, &joinData); err != nil {
			log.Printf("Error parsing join payload from %d: %v", senderInfo.UserID, err)
			return
		}

		gameRooms.Lock()
		player.Username = joinData.Username
		player.IsHost = joinData.IsHost
		log.Printf("Player %s (ID: %d) joined game %s. Host: %t", player.Username, player.UserID, gameCode, player.IsHost)
		gameRooms.Unlock()

		// Send updated player list to all players
		players := getCurrentPlayers(gameCode)
		broadcastPlayerListUpdate(gameCode, players, nil)

		// Also send a player_join message to all other players
		broadcastPlayerUpdate(gameCode, player, MsgTypePlayerJoin, senderInfo.Conn)

	case MsgTypePlayerReady:
		var readyData struct {
			IsReady bool `json:"isReady"`
		}
		if err := json.Unmarshal(msg.Payload, &readyData); err != nil {
			log.Printf("Error parsing ready status payload from %d: %v", senderInfo.UserID, err)
			return
		}

		gameRooms.Lock()
		player.IsReady = readyData.IsReady
		log.Printf("Player %s (ID: %d) readiness set to %t in game %s", player.Username, player.UserID, player.IsReady, gameCode)
		gameRooms.Unlock()

		// Send updated player list to all players
		players := getCurrentPlayers(gameCode)
		broadcastPlayerListUpdate(gameCode, players, nil)

	case MsgTypeGuessSubmit:
		// Process and save player guess (TODO)
		// Broadcast guess submission to other players
		broadcastPlayerUpdate(gameCode, player, MsgTypeGuessSubmit, senderInfo.Conn) // Send full player info or just guess?

	case MsgTypeChatMessage:
		// Simple broadcast of chat payload
		broadcastGenericMessage(gameCode, msg, senderInfo.Conn)

	case MsgTypeGameStart:
		// Only host can start
		if !player.IsHost {
			log.Printf("Non-host player %d attempted to start game %s", player.UserID, gameCode)
			// TODO: Send error message back to player
			return
		}

		// Get game settings (needed for rounds, etc.)
		var game models.MultiplayerGame
		if err := database.DB.Where("game_code = ?", gameCode).First(&game).Error; err != nil {
			log.Printf("Error fetching game %s for start: %v", gameCode, err)
			// TODO: Send error message back to host
			return
		}

		// Check if all players are ready
		gameRooms.RLock()
		allReady := true
		if len(room) < 2 { // Require at least 2 players (Adjust as needed)
			allReady = false
		} else {
			for _, p := range room {
				if !p.IsReady {
					allReady = false
					break
				}
			}
		}
		gameRooms.RUnlock()

		if !allReady {
			log.Printf("Host %d attempted to start game %s before all players were ready", player.UserID, gameCode)
			// TODO: Send error message back to host
			return
		}

		// Fetch locations using GORM query directly
		db := database.GetDB() // Get DB instance
		var locations []models.Location
		result := db.Model(&models.Location{}).
			Order("RANDOM()").
			Limit(int(game.RoundsTotal)).
			Find(&locations)

		if result.Error != nil {
			log.Printf("Error getting locations for game %s: %v", gameCode, result.Error)
			// TODO: Send error message back to host
			return
		}
		if result.RowsAffected < int64(game.RoundsTotal) {
			log.Printf("Warning: Found only %d locations for game %s, requested %d", result.RowsAffected, gameCode, game.RoundsTotal)
			if result.RowsAffected == 0 {
				// TODO: Send error message back to host
				return
			}
		}

		// Update game status in DB
		game.Status = "in_progress"
		game.CurrentRound = 1
		if err := database.DB.Save(&game).Error; err != nil {
			log.Printf("Error updating game status for %s: %v", gameCode, err)
			// TODO: Send error message back to host
			return
		}

		// Prepare payload with locations
		startPayload := struct {
			Locations []models.Location `json:"locations"`
		}{
			Locations: locations,
		}
		payloadBytes, err := json.Marshal(startPayload)
		if err != nil {
			log.Printf("Error marshaling start game payload: %v", err)
			return
		}
		msg.Payload = json.RawMessage(payloadBytes)

		// Broadcast game start to all players (including host)
		log.Printf("Host %d starting game %s with %d locations", player.UserID, gameCode, len(locations))
		broadcastGenericMessage(gameCode, msg, nil) // Send to all

	// Note: MsgTypePlayerLeave is handled by the defer function in HandleWebSocket
	// Note: MsgTypePlayerJoin is handled by the connection logic in HandleWebSocket

	default:
		log.Printf("Received unknown message type '%s' from player %d", msg.Type, senderInfo.UserID)
	}
}

// broadcastGenericMessage sends a generic WSMessage to all clients in a room except the sender
func broadcastGenericMessage(gameCode string, msg WSMessage, sender *websocket.Conn) {
	gameRooms.RLock()
	defer gameRooms.RUnlock()

	if room, exists := gameRooms.rooms[gameCode]; exists {
		for _, player := range room {
			if player.Conn != sender {
				if err := player.Conn.WriteJSON(msg); err != nil {
					log.Printf("Error broadcasting generic message type %s to %d: %v", msg.Type, player.UserID, err)
					// Optionally handle connection closure here
				}
			}
		}
	}
}

// TODO: Add function to update player status in DB when ready status changes.
// TODO: Add function to handle Game Start logic (generating locations, etc.)
// TODO: Add function to handle Guess Submission logic.
// TODO: Properly determine host status when joining/creating.


================================================================================

Filename: internal/middleware/auth.go
Content:
// internal/middleware/auth.go
package middleware

import (
	"log"
	"net/http"

	"geoguessr-backend/internal/utils" // Adjust path

	"github.com/gin-gonic/gin"
)

// AuthRequired is a middleware function to protect routes
func AuthRequired() gin.HandlerFunc {
	return func(c *gin.Context) {
		tokenString := utils.ExtractToken(c) // Get token from "Bearer <token>" header
		if tokenString == "" {
			log.Println("Auth Middleware: No token provided")
			c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "Authorization token required"})
			return
		}

		token, err := utils.ValidateToken(tokenString) // Validate signature, expiry, etc.
		if err != nil {
			log.Printf("Auth Middleware: Invalid token: %v", err)
			c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "Invalid or expired token"})
			return
		}

		// Token is valid, extract user ID
		userID, err := utils.ExtractUserIDFromToken(token)
		if err != nil {
			log.Printf("Auth Middleware: Failed to extract userID from valid token: %v", err)
			c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "Invalid token claims"})
			return
		}

		// Set user ID in the context for subsequent handlers to use
		c.Set("userID", userID)
		log.Printf("Auth Middleware: User %d authenticated", userID)

		// Proceed to the next handler
		c.Next()
	}
}


================================================================================

Filename: internal/models/game.go
Content:
// internal/models/game.go
package models

import (
	"time"
)

// Game represents a completed game session by a user
type Game struct {
	ID           uint      `gorm:"primaryKey"`
	UserID       uint      `gorm:"not null;index"` // Foreign key to User table
	User         User      // GORM association (belongs to User) - optional but useful for preloading
	TotalScore   int       `gorm:"not null"`
	RoundsPlayed int       `gorm:"not null"` // Typically 5, but could be variable
	CreatedAt    time.Time // When the game was completed/saved
	UpdatedAt    time.Time

	Rounds []Round `gorm:"foreignKey:GameID"` // GORM association (has many Rounds)
}

// RoundResultInput represents the data for a single round sent from frontend
type RoundResultInput struct {
	RoundNumber int     `json:"roundNumber" validate:"required,min=1"`
	LocationID  uint    `json:"locationId" validate:"required,min=1"`
	GuessLat    float64 `json:"guessLat" validate:"required"`
	GuessLng    float64 `json:"guessLng" validate:"required"`
	ActualLat   float64 `json:"actualLat" validate:"required"` // Send actual coords for verification/record
	ActualLng   float64 `json:"actualLng" validate:"required"`
	DistanceKm  float64 `json:"distanceKm" validate:"min=0"`
	Score       int     `json:"score" validate:"required,min=0"`
}

// SubmitGameInput represents the complete game data sent from frontend
type SubmitGameInput struct {
	// GameID      string             `json:"gameId"` // We might generate ID on backend instead
	TotalScore   int                `json:"totalScore" validate:"required,min=0"`
	RoundsPlayed int                `json:"roundsPlayed" validate:"required,min=1"`
	Rounds       []RoundResultInput `json:"rounds" validate:"required,min=1,dive"` // 'dive' validates each element in slice
}


================================================================================

Filename: internal/models/location.go
Content:
package models

import "gorm.io/gorm"

type Location struct {
	gorm.Model
	Latitude    float64 `gorm:"not null;index:idx_lat"`
	Longitude   float64 `gorm:"not null;index:idx_lng"`
	Description string `gorm: index:idx_description"`
	Country     string `gorm:"index:idx_country"`
	Region      string `gorm:"index:idx_region"`

	// Composite index for lat/lng pairs
	// This is especially useful for geographic queries
	// that need to look up locations by both coordinates
	_ int `gorm:"index:idx_lat_lng,priority:1,columns:latitude,longitude"`
}


================================================================================

Filename: internal/models/multiplayer.go
Content:
// internal/models/multiplayer.go
package models

import (
	"time"
)

// MultiplayerGame represents a game with multiple participants
type MultiplayerGame struct {
	ID            uint      `gorm:"primaryKey"`
	HostUserID    uint      `gorm:"not null;index"`
	GameCode      string    `gorm:"uniqueIndex;size:8"` // For joining games
	Status        string    `gorm:"size:20;not null"` // "waiting", "in_progress", "completed"
	MaxPlayers    int       `gorm:"not null;default:4"`
	RoundsTotal   int       `gorm:"not null;default:5"`
	CurrentRound  int       `gorm:"not null;default:0"`
	CreatedAt     time.Time
	UpdatedAt     time.Time
	
	// Same locations for all players
	Locations     []Location `gorm:"many2many:multiplayer_game_locations;"`
	// Player sessions
	PlayerSessions []MultiplayerSession `gorm:"foreignKey:GameID"`
}

// MultiplayerSession represents a player's session in a multiplayer game
type MultiplayerSession struct {
	ID          uint      `gorm:"primaryKey"`
	GameID      uint      `gorm:"not null;index"`
	UserID      uint      `gorm:"not null;index"`
	IsHost      bool      `gorm:"not null;default:false"`
	IsReady     bool      `gorm:"not null;default:false"`
	TotalScore  int       `gorm:"not null;default:0"`
	IsActive    bool      `gorm:"not null;default:true"`
	JoinedAt    time.Time
	
	User        User
	Game        MultiplayerGame
	Rounds      []MultiplayerRound `gorm:"foreignKey:SessionID"`
}

// MultiplayerRound represents a single round for a player in a multiplayer game
type MultiplayerRound struct {
	ID           uint    `gorm:"primaryKey"`
	SessionID    uint    `gorm:"not null;index"`
	RoundNumber  int     `gorm:"not null"`
	LocationID   uint    `gorm:"not null"`
	GuessLat     float64
	GuessLng     float64
	DistanceKm   float64
	Score        int
	GuessedAt    time.Time
} 

================================================================================

Filename: internal/models/round.go
Content:
// internal/models/round.go
package models

import (
	"time"

	"gorm.io/gorm"
)

// Round represents the result of a single round within a game
type Round struct {
	ID          uint     `gorm:"primaryKey"`
	GameID      uint     `gorm:"not null;index"` // Foreign key to Game table
	LocationID  uint     `gorm:"not null"`       // Foreign key to Location table
	Location    Location // GORM association (belongs to Location) - optional
	RoundNumber int      `gorm:"not null"` // e.g., 1, 2, 3, 4, 5
	GuessLat    float64  `gorm:"not null"` // User's guessed latitude
	GuessLng    float64  `gorm:"not null"` // User's guessed longitude
	ActualLat   float64  `gorm:"not null"` // Actual latitude (from Location)
	ActualLng   float64  `gorm:"not null"` // Actual longitude (from Location)
	DistanceKm  float64  // Calculated distance in km
	Score       int      `gorm:"not null"` // Score for this round
	CreatedAt   time.Time
	UpdatedAt   time.Time
	DeletedAt   gorm.DeletedAt `gorm:"index"` // Soft delete support
}


================================================================================

Filename: internal/models/user.go
Content:
package models

import (
	"time" 

	"gorm.io/gorm"
)


type User struct {
	ID        uint   `gorm:"primaryKey"`
	Username  string `gorm:"size:50;not null;uniqueIndex" validate:"required,min=3,max=50"` 
	Email     string `gorm:"size:100;not null;uniqueIndex" validate:"required,email"`        
	PasswordHash string `gorm:"not null" validate:"required"`                             
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt gorm.DeletedAt `gorm:"index"` 

	
	
	
}




type RegisterInput struct {
	Username string `json:"username" validate:"required,min=3,max=50"`
	Email    string `json:"email" validate:"required,email"`
	Password string `json:"password" validate:"required,min=6,max=72"` 
}


type LoginInput struct {
	Email    string `json:"email" validate:"required,email"`
	Password string `json:"password" validate:"required"`
}

================================================================================

Filename: internal/utils/token.go
Content:
package utils

import (
	"fmt"
	"log"
	"os"
	
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v5"
)

var jwtSecretKey []byte


func InitializeJWT() {
	secret := os.Getenv("JWT_SECRET_KEY")
	if secret == "" {
		log.Fatal("FATAL: JWT_SECRET_KEY environment variable not set!")
	}
	jwtSecretKey = []byte(secret)
	log.Println("JWT Secret Key loaded.")
}


func GenerateToken(userID uint) (string, error) {
	
	
	
	expirationTime := time.Now().Add(24 * time.Hour) 
	claims := jwt.MapClaims{
		"user_id": userID,
		"exp":     expirationTime.Unix(),
		"iat":     time.Now().Unix(),
		"iss":     "terraquest-backend", 
	}

	
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	
	tokenString, err := token.SignedString(jwtSecretKey)
	if err != nil {
		return "", fmt.Errorf("failed to sign token: %w", err)
	}

	return tokenString, nil
}


func ValidateToken(tokenString string) (*jwt.Token, error) {
	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
		
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		
		return jwtSecretKey, nil
	})

	if err != nil {
		return nil, fmt.Errorf("failed to parse token: %w", err) 
	}

	if !token.Valid {
		return nil, fmt.Errorf("invalid token")
	}

	return token, nil
}


func ExtractToken(c *gin.Context) string {
	bearerToken := c.Request.Header.Get("Authorization")
	
	parts := strings.Split(bearerToken, " ")
	if len(parts) == 2 && parts[0] == "Bearer" {
		return parts[1]
	}
	return ""
}


func ExtractUserIDFromToken(token *jwt.Token) (uint, error) {
	claims, ok := token.Claims.(jwt.MapClaims)
	if !ok || !token.Valid {
		return 0, fmt.Errorf("invalid token claims")
	}

	
	userIDFloat, ok := claims["user_id"].(float64)
	if !ok {
		return 0, fmt.Errorf("user_id claim is not a valid number")
	}

	
	return uint(userIDFloat), nil
}


func ExtractUserID(c *gin.Context) (uint, error) {
	tokenString := ExtractToken(c)
	if tokenString == "" {
		return 0, fmt.Errorf("authorization token not provided")
	}

	token, err := ValidateToken(tokenString)
	if err != nil {
		return 0, err 
	}

	return ExtractUserIDFromToken(token)
}

================================================================================

Filename: repo_contents.txt
Content:

Filename: .gitignore
Content:
.env
.vscode
repo_contents.txt

================================================================================

Filename: cmd/server/main.go
Content:
package main

import (
	"log"
	"net/http"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
	"github.com/joho/godotenv"

	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"

	"github.com/go-openapi/runtime/middleware"

	_ "geoguessr-backend/docs" // for swagger docs
	"geoguessr-backend/internal/database"
	"geoguessr-backend/internal/handlers"
	internalMiddleware "geoguessr-backend/internal/middleware"
	"geoguessr-backend/internal/utils"
)

// @title           TerraQuest Backend API
// @version         1.0
// @description     API Server for the TerraQuest GeoGuessr clone game.
// @termsOfService  http://swagger.io/terms/  <-- Update later

// @contact.name   API Support
// @contact.url    http://www.example.com/support <-- Update later
// @contact.email  support@example.com <-- Update later

// @license.name  Apache 2.0  <-- Or your chosen license
// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html

// @host      localhost:8080
// @BasePath  /api/v1

// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
// @description Type "Bearer" followed by a space and JWT token.

func main() {
	log.Println("Starting GeoGuessr Backend Server...")

	err := godotenv.Load()
	if err != nil {
		log.Println("No .env file found, using system environment variables.")
	}

	utils.InitializeJWT()

	err = database.Connect()
	if err != nil {
		log.Fatalf("Could not connect to the database: %v", err)
	}

	router := gin.Default()

	config := cors.DefaultConfig()

	config.AllowOrigins = []string{"http://localhost:5173"}
	config.AllowMethods = []string{"GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"}
	config.AllowHeaders = []string{"Origin", "Content-Type", "Accept", "Authorization"}

	router.Use(cors.New(config))

	router.GET("/docs/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
	log.Println("Swagger UI available at http://localhost:8080/docs/index.html")

	opts := middleware.RedocOpts{
		SpecURL: "/docs/doc.json",
		Path:    "/redoc",
		Title:   "TerraQuest API Docs (ReDoc)",
	}
	redocHandler := middleware.Redoc(opts, nil)
	router.GET("/redoc", gin.WrapH(redocHandler))
	log.Println("ReDoc UI available at http://localhost:8080/redoc")

	api := router.Group("/api/v1")
	{
		authGroup := api.Group("/auth")
		{
			authGroup.POST("/register", handlers.Register)
			authGroup.POST("/login", handlers.Login)
		}

		// Game routes - apply auth middleware here
		gameGroup := api.Group("/game")
		// Apply AuthRequired middleware to all routes within this group
		gameGroup.Use(internalMiddleware.AuthRequired()) // <<< APPLY MIDDLEWARE
		{
			gameGroup.GET("/start", handlers.StartGame)
			gameGroup.POST("/finish", handlers.FinishGame)

		}

	}

	router.GET("/ping", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"message": "pong"})
	})

	port := ":8080"
	log.Printf("Server listening on port %s\n", port)
	err = router.Run(port)
	if err != nil {
		log.Fatalf("Failed to start server: %v", err)
	}
}


================================================================================

Filename: docs/docs.go
Content:
// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/  \u003c-- Update later",
        "contact": {
            "name": "API Support",
            "url": "http://www.example.com/support \u003c-- Update later",
            "email": "support@example.com \u003c-- Update later"
        },
        "license": {
            "name": "Apache 2.0  \u003c-- Or your chosen license",
            "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/auth/login": {
            "post": {
                "description": "Authenticates a user with email and password, returns a JWT token upon success.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Log in a user",
                "parameters": [
                    {
                        "description": "User Login Credentials",
                        "name": "credentials",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.LoginInput"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Login successful (returns JWT token and basic user info)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid input format or validation failed",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "Invalid credentials (user not found or password mismatch)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal server error (DB find, token generation)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/auth/register": {
            "post": {
                "description": "Creates a new user account with username, email, and password.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Register a new user",
                "parameters": [
                    {
                        "description": "User Registration Info",
                        "name": "userInput",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.RegisterInput"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "User registered successfully (returns basic user info)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid input format or validation failed",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "409": {
                        "description": "Conflict: Username or Email already exists",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal server error (hashing, DB create)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/game/start": {
            "get": {
                "description": "Fetches a specified number of random locations for a new game session.",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Game"
                ],
                "summary": "Start a new game",
                "parameters": [
                    {
                        "maximum": 10,
                        "type": "integer",
                        "description": "Number of rounds (default: 5)",
                        "name": "rounds",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Game started successfully (returns gameId placeholder and locations)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error (failed to fetch locations)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "models.LoginInput": {
            "type": "object",
            "required": [
                "email",
                "password"
            ],
            "properties": {
                "email": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                }
            }
        },
        "models.RegisterInput": {
            "type": "object",
            "required": [
                "email",
                "password",
                "username"
            ],
            "properties": {
                "email": {
                    "type": "string"
                },
                "password": {
                    "type": "string",
                    "maxLength": 72,
                    "minLength": 6
                },
                "username": {
                    "type": "string",
                    "maxLength": 50,
                    "minLength": 3
                }
            }
        }
    },
    "securityDefinitions": {
        "BearerAuth": {
            "description": "Type \"Bearer\" followed by a space and JWT token.",
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &swag.Spec{
	Version:          "1.0",
	Host:             "localhost:8080",
	BasePath:         "/api/v1",
	Schemes:          []string{},
	Title:            "TerraQuest Backend API",
	Description:      "API Server for the TerraQuest GeoGuessr clone game.",
	InfoInstanceName: "swagger",
	SwaggerTemplate:  docTemplate,
	LeftDelim:        "{{",
	RightDelim:       "}}",
}

func init() {
	swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}


================================================================================

Filename: docs/swagger.json
Content:
{
    "swagger": "2.0",
    "info": {
        "description": "API Server for the TerraQuest GeoGuessr clone game.",
        "title": "TerraQuest Backend API",
        "termsOfService": "http://swagger.io/terms/  \u003c-- Update later",
        "contact": {
            "name": "API Support",
            "url": "http://www.example.com/support \u003c-- Update later",
            "email": "support@example.com \u003c-- Update later"
        },
        "license": {
            "name": "Apache 2.0  \u003c-- Or your chosen license",
            "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
        },
        "version": "1.0"
    },
    "host": "localhost:8080",
    "basePath": "/api/v1",
    "paths": {
        "/auth/login": {
            "post": {
                "description": "Authenticates a user with email and password, returns a JWT token upon success.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Log in a user",
                "parameters": [
                    {
                        "description": "User Login Credentials",
                        "name": "credentials",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.LoginInput"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Login successful (returns JWT token and basic user info)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid input format or validation failed",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "Invalid credentials (user not found or password mismatch)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal server error (DB find, token generation)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/auth/register": {
            "post": {
                "description": "Creates a new user account with username, email, and password.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Register a new user",
                "parameters": [
                    {
                        "description": "User Registration Info",
                        "name": "userInput",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.RegisterInput"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "User registered successfully (returns basic user info)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid input format or validation failed",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "409": {
                        "description": "Conflict: Username or Email already exists",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal server error (hashing, DB create)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/game/start": {
            "get": {
                "description": "Fetches a specified number of random locations for a new game session.",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Game"
                ],
                "summary": "Start a new game",
                "parameters": [
                    {
                        "maximum": 10,
                        "type": "integer",
                        "description": "Number of rounds (default: 5)",
                        "name": "rounds",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Game started successfully (returns gameId placeholder and locations)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error (failed to fetch locations)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "models.LoginInput": {
            "type": "object",
            "required": [
                "email",
                "password"
            ],
            "properties": {
                "email": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                }
            }
        },
        "models.RegisterInput": {
            "type": "object",
            "required": [
                "email",
                "password",
                "username"
            ],
            "properties": {
                "email": {
                    "type": "string"
                },
                "password": {
                    "type": "string",
                    "maxLength": 72,
                    "minLength": 6
                },
                "username": {
                    "type": "string",
                    "maxLength": 50,
                    "minLength": 3
                }
            }
        }
    },
    "securityDefinitions": {
        "BearerAuth": {
            "description": "Type \"Bearer\" followed by a space and JWT token.",
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}

================================================================================

Filename: docs/swagger.yaml
Content:
basePath: /api/v1
definitions:
  models.LoginInput:
    properties:
      email:
        type: string
      password:
        type: string
    required:
    - email
    - password
    type: object
  models.RegisterInput:
    properties:
      email:
        type: string
      password:
        maxLength: 72
        minLength: 6
        type: string
      username:
        maxLength: 50
        minLength: 3
        type: string
    required:
    - email
    - password
    - username
    type: object
host: localhost:8080
info:
  contact:
    email: support@example.com <-- Update later
    name: API Support
    url: http://www.example.com/support <-- Update later
  description: API Server for the TerraQuest GeoGuessr clone game.
  license:
    name: Apache 2.0  <-- Or your chosen license
    url: http://www.apache.org/licenses/LICENSE-2.0.html
  termsOfService: http://swagger.io/terms/  <-- Update later
  title: TerraQuest Backend API
  version: "1.0"
paths:
  /auth/login:
    post:
      consumes:
      - application/json
      description: Authenticates a user with email and password, returns a JWT token
        upon success.
      parameters:
      - description: User Login Credentials
        in: body
        name: credentials
        required: true
        schema:
          $ref: '#/definitions/models.LoginInput'
      produces:
      - application/json
      responses:
        "200":
          description: Login successful (returns JWT token and basic user info)
          schema:
            additionalProperties: true
            type: object
        "400":
          description: Invalid input format or validation failed
          schema:
            additionalProperties:
              type: string
            type: object
        "401":
          description: Invalid credentials (user not found or password mismatch)
          schema:
            additionalProperties:
              type: string
            type: object
        "500":
          description: Internal server error (DB find, token generation)
          schema:
            additionalProperties:
              type: string
            type: object
      summary: Log in a user
      tags:
      - Auth
  /auth/register:
    post:
      consumes:
      - application/json
      description: Creates a new user account with username, email, and password.
      parameters:
      - description: User Registration Info
        in: body
        name: userInput
        required: true
        schema:
          $ref: '#/definitions/models.RegisterInput'
      produces:
      - application/json
      responses:
        "201":
          description: User registered successfully (returns basic user info)
          schema:
            additionalProperties: true
            type: object
        "400":
          description: Invalid input format or validation failed
          schema:
            additionalProperties:
              type: string
            type: object
        "409":
          description: 'Conflict: Username or Email already exists'
          schema:
            additionalProperties:
              type: string
            type: object
        "500":
          description: Internal server error (hashing, DB create)
          schema:
            additionalProperties:
              type: string
            type: object
      summary: Register a new user
      tags:
      - Auth
  /game/start:
    get:
      description: Fetches a specified number of random locations for a new game session.
      parameters:
      - description: 'Number of rounds (default: 5)'
        in: query
        maximum: 10
        name: rounds
        type: integer
      produces:
      - application/json
      responses:
        "200":
          description: Game started successfully (returns gameId placeholder and locations)
          schema:
            additionalProperties: true
            type: object
        "500":
          description: Internal server error (failed to fetch locations)
          schema:
            additionalProperties:
              type: string
            type: object
      summary: Start a new game
      tags:
      - Game
securityDefinitions:
  BearerAuth:
    description: Type "Bearer" followed by a space and JWT token.
    in: header
    name: Authorization
    type: apiKey
swagger: "2.0"


================================================================================

Filename: geoguessr.session.sql
Content:
DROP table users;

================================================================================

Filename: go.mod
Content:
module geoguessr-backend

go 1.23.4

require (
	github.com/KyleBanks/depth v1.2.1 // indirect
	github.com/PuerkitoBio/purell v1.2.1 // indirect
	github.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578 // indirect
	github.com/asaskevich/govalidator v0.0.0-20230301143203-a9d515a09cc2 // indirect
	github.com/bytedance/sonic v1.13.2 // indirect
	github.com/bytedance/sonic/loader v0.2.4 // indirect
	github.com/cloudwego/base64x v0.1.5 // indirect
	github.com/cloudwego/iasm v0.2.0 // indirect
	github.com/cpuguy83/go-md2man/v2 v2.0.6 // indirect
	github.com/gabriel-vasile/mimetype v1.4.8 // indirect
	github.com/gin-contrib/cors v1.7.5 // indirect
	github.com/gin-contrib/sse v1.1.0 // indirect
	github.com/gin-gonic/gin v1.10.0 // indirect
	github.com/go-openapi/analysis v0.23.0 // indirect
	github.com/go-openapi/errors v0.22.0 // indirect
	github.com/go-openapi/jsonpointer v0.21.1 // indirect
	github.com/go-openapi/jsonreference v0.21.0 // indirect
	github.com/go-openapi/loads v0.22.0 // indirect
	github.com/go-openapi/runtime v0.28.0 // indirect
	github.com/go-openapi/spec v0.21.0 // indirect
	github.com/go-openapi/strfmt v0.23.0 // indirect
	github.com/go-openapi/swag v0.23.1 // indirect
	github.com/go-openapi/validate v0.24.0 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/go-playground/validator/v10 v10.26.0 // indirect
	github.com/goccy/go-json v0.10.5 // indirect
	github.com/golang-jwt/jwt/v5 v5.2.2 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/gorilla/websocket v1.5.3 // indirect
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 // indirect
	github.com/jackc/pgx/v5 v5.7.4 // indirect
	github.com/jackc/puddle/v2 v2.2.2 // indirect
	github.com/jinzhu/inflection v1.0.0 // indirect
	github.com/jinzhu/now v1.1.5 // indirect
	github.com/joho/godotenv v1.5.1 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/klauspost/cpuid/v2 v2.2.10 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/mailru/easyjson v0.9.0 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mitchellh/mapstructure v1.5.0 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/oklog/ulid v1.3.1 // indirect
	github.com/pelletier/go-toml/v2 v2.2.4 // indirect
	github.com/russross/blackfriday/v2 v2.1.0 // indirect
	github.com/shurcooL/sanitized_anchor_name v1.0.0 // indirect
	github.com/swaggo/files v1.0.1 // indirect
	github.com/swaggo/gin-swagger v1.6.0 // indirect
	github.com/swaggo/swag v1.16.4 // indirect
	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
	github.com/ugorji/go/codec v1.2.12 // indirect
	github.com/urfave/cli/v2 v2.27.6 // indirect
	github.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1 // indirect
	go.mongodb.org/mongo-driver v1.14.0 // indirect
	golang.org/x/arch v0.16.0 // indirect
	golang.org/x/crypto v0.37.0 // indirect
	golang.org/x/net v0.39.0 // indirect
	golang.org/x/sync v0.13.0 // indirect
	golang.org/x/sys v0.32.0 // indirect
	golang.org/x/text v0.24.0 // indirect
	golang.org/x/tools v0.32.0 // indirect
	google.golang.org/protobuf v1.36.6 // indirect
	gopkg.in/yaml.v2 v2.4.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
	gorm.io/driver/postgres v1.5.11 // indirect
	gorm.io/gorm v1.25.12 // indirect
	sigs.k8s.io/yaml v1.4.0 // indirect
)


================================================================================

Filename: go.sum
Content:
github.com/KyleBanks/depth v1.2.1 h1:5h8fQADFrWtarTdtDudMmGsC7GPbOAu6RVB3ffsVFHc=
github.com/KyleBanks/depth v1.2.1/go.mod h1:jzSb9d0L43HxTQfT+oSA1EEp2q+ne2uh6XgeJcm8brE=
github.com/PuerkitoBio/purell v1.2.1 h1:QsZ4TjvwiMpat6gBCBxEQI0rcS9ehtkKtSpiUnd9N28=
github.com/PuerkitoBio/purell v1.2.1/go.mod h1:ZwHcC/82TOaovDi//J/804umJFFmbOHPngi8iYYv/Eo=
github.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578 h1:d+Bc7a5rLufV/sSk/8dngufqelfh6jnri85riMAaF/M=
github.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578/go.mod h1:uGdkoq3SwY9Y+13GIhn11/XLaGBb4BfwItxLd5jeuXE=
github.com/asaskevich/govalidator v0.0.0-20230301143203-a9d515a09cc2 h1:DklsrG3dyBCFEj5IhUbnKptjxatkF07cF2ak3yi77so=
github.com/asaskevich/govalidator v0.0.0-20230301143203-a9d515a09cc2/go.mod h1:WaHUgvxTVq04UNunO+XhnAqY/wQc+bxr74GqbsZ/Jqw=
github.com/bytedance/sonic v1.13.2 h1:8/H1FempDZqC4VqjptGo14QQlJx8VdZJegxs6wwfqpQ=
github.com/bytedance/sonic v1.13.2/go.mod h1:o68xyaF9u2gvVBuGHPlUVCy+ZfmNNO5ETf1+KgkJhz4=
github.com/bytedance/sonic/loader v0.1.1/go.mod h1:ncP89zfokxS5LZrJxl5z0UJcsk4M4yY2JpfqGeCtNLU=
github.com/bytedance/sonic/loader v0.2.4 h1:ZWCw4stuXUsn1/+zQDqeE7JKP+QO47tz7QCNan80NzY=
github.com/bytedance/sonic/loader v0.2.4/go.mod h1:N8A3vUdtUebEY2/VQC0MyhYeKUFosQU6FxH2JmUe6VI=
github.com/cloudwego/base64x v0.1.5 h1:XPciSp1xaq2VCSt6lF0phncD4koWyULpl5bUxbfCyP4=
github.com/cloudwego/base64x v0.1.5/go.mod h1:0zlkT4Wn5C6NdauXdJRhSKRlJvmclQ1hhJgA0rcu/8w=
github.com/cloudwego/iasm v0.2.0 h1:1KNIy1I1H9hNNFEEH3DVnI4UujN+1zjpuk6gwHLTssg=
github.com/cloudwego/iasm v0.2.0/go.mod h1:8rXZaNYT2n95jn+zTI1sDr+IgcD2GVs0nlbbQPiEFhY=
github.com/cpuguy83/go-md2man/v2 v2.0.6 h1:XJtiaUW6dEEqVuZiMTn1ldk455QWwEIsMIJlo5vtkx0=
github.com/cpuguy83/go-md2man/v2 v2.0.6/go.mod h1:oOW0eioCTA6cOiMLiUPZOpcVxMig6NIQQ7OS05n1F4g=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/gabriel-vasile/mimetype v1.4.8 h1:FfZ3gj38NjllZIeJAmMhr+qKL8Wu+nOoI3GqacKw1NM=
github.com/gabriel-vasile/mimetype v1.4.8/go.mod h1:ByKUIKGjh1ODkGM1asKUbQZOLGrPjydw3hYPU2YU9t8=
github.com/gin-contrib/cors v1.7.5 h1:cXC9SmofOrRg0w9PigwGlHG3ztswH6bqq4vJVXnvYMk=
github.com/gin-contrib/cors v1.7.5/go.mod h1:4q3yi7xBEDDWKapjT2o1V7mScKDDr8k+jZ0fSquGoy0=
github.com/gin-contrib/sse v1.1.0 h1:n0w2GMuUpWDVp7qSpvze6fAu9iRxJY4Hmj6AmBOU05w=
github.com/gin-contrib/sse v1.1.0/go.mod h1:hxRZ5gVpWMT7Z0B0gSNYqqsSCNIJMjzvm6fqCz9vjwM=
github.com/gin-gonic/gin v1.10.0 h1:nTuyha1TYqgedzytsKYqna+DfLos46nTv2ygFy86HFU=
github.com/gin-gonic/gin v1.10.0/go.mod h1:4PMNQiOhvDRa013RKVbsiNwoyezlm2rm0uX/T7kzp5Y=
github.com/go-openapi/analysis v0.23.0 h1:aGday7OWupfMs+LbmLZG4k0MYXIANxcuBTYUC03zFCU=
github.com/go-openapi/analysis v0.23.0/go.mod h1:9mz9ZWaSlV8TvjQHLl2mUW2PbZtemkE8yA5v22ohupo=
github.com/go-openapi/errors v0.22.0 h1:c4xY/OLxUBSTiepAg3j/MHuAv5mJhnf53LLMWFB+u/w=
github.com/go-openapi/errors v0.22.0/go.mod h1:J3DmZScxCDufmIMsdOuDHxJbdOGC0xtUynjIx092vXE=
github.com/go-openapi/jsonpointer v0.21.1 h1:whnzv/pNXtK2FbX/W9yJfRmE2gsmkfahjMKB0fZvcic=
github.com/go-openapi/jsonpointer v0.21.1/go.mod h1:50I1STOfbY1ycR8jGz8DaMeLCdXiI6aDteEdRNNzpdk=
github.com/go-openapi/jsonreference v0.21.0 h1:Rs+Y7hSXT83Jacb7kFyjn4ijOuVGSvOdF2+tg1TRrwQ=
github.com/go-openapi/jsonreference v0.21.0/go.mod h1:LmZmgsrTkVg9LG4EaHeY8cBDslNPMo06cago5JNLkm4=
github.com/go-openapi/loads v0.22.0 h1:ECPGd4jX1U6NApCGG1We+uEozOAvXvJSF4nnwHZ8Aco=
github.com/go-openapi/loads v0.22.0/go.mod h1:yLsaTCS92mnSAZX5WWoxszLj0u+Ojl+Zs5Stn1oF+rs=
github.com/go-openapi/runtime v0.28.0 h1:gpPPmWSNGo214l6n8hzdXYhPuJcGtziTOgUpvsFWGIQ=
github.com/go-openapi/runtime v0.28.0/go.mod h1:QN7OzcS+XuYmkQLw05akXk0jRH/eZ3kb18+1KwW9gyc=
github.com/go-openapi/spec v0.21.0 h1:LTVzPc3p/RzRnkQqLRndbAzjY0d0BCL72A6j3CdL9ZY=
github.com/go-openapi/spec v0.21.0/go.mod h1:78u6VdPw81XU44qEWGhtr982gJ5BWg2c0I5XwVMotYk=
github.com/go-openapi/strfmt v0.23.0 h1:nlUS6BCqcnAk0pyhi9Y+kdDVZdZMHfEKQiS4HaMgO/c=
github.com/go-openapi/strfmt v0.23.0/go.mod h1:NrtIpfKtWIygRkKVsxh7XQMDQW5HKQl6S5ik2elW+K4=
github.com/go-openapi/swag v0.23.1 h1:lpsStH0n2ittzTnbaSloVZLuB5+fvSY/+hnagBjSNZU=
github.com/go-openapi/swag v0.23.1/go.mod h1:STZs8TbRvEQQKUA+JZNAm3EWlgaOBGpyFDqQnDHMef0=
github.com/go-openapi/validate v0.24.0 h1:LdfDKwNbpB6Vn40xhTdNZAnfLECL81w+VX3BumrGD58=
github.com/go-openapi/validate v0.24.0/go.mod h1:iyeX1sEufmv3nPbBdX3ieNviWnOZaJ1+zquzJEf2BAQ=
github.com/go-playground/locales v0.14.1 h1:EWaQ/wswjilfKLTECiXz7Rh+3BjFhfDFKv/oXslEjJA=
github.com/go-playground/locales v0.14.1/go.mod h1:hxrqLVvrK65+Rwrd5Fc6F2O76J/NuW9t0sjnWqG1slY=
github.com/go-playground/universal-translator v0.18.1 h1:Bcnm0ZwsGyWbCzImXv+pAJnYK9S473LQFuzCbDbfSFY=
github.com/go-playground/universal-translator v0.18.1/go.mod h1:xekY+UJKNuX9WP91TpwSH2VMlDf28Uj24BCp08ZFTUY=
github.com/go-playground/validator/v10 v10.26.0 h1:SP05Nqhjcvz81uJaRfEV0YBSSSGMc/iMaVtFbr3Sw2k=
github.com/go-playground/validator/v10 v10.26.0/go.mod h1:I5QpIEbmr8On7W0TktmJAumgzX4CA1XNl4ZmDuVHKKo=
github.com/goccy/go-json v0.10.5 h1:Fq85nIqj+gXn/S5ahsiTlK3TmC85qgirsdTP/+DeaC4=
github.com/goccy/go-json v0.10.5/go.mod h1:oq7eo15ShAhp70Anwd5lgX2pLfOS3QCiwU/PULtXL6M=
github.com/golang-jwt/jwt/v5 v5.2.2 h1:Rl4B7itRWVtYIHFrSNd7vhTiz9UpLdi6gZhZ3wEeDy8=
github.com/golang-jwt/jwt/v5 v5.2.2/go.mod h1:pqrtFR0X4osieyHYxtmOUWsAWrfe1Q5UVIyoH402zdk=
github.com/google/go-cmp v0.5.9/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
github.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/gorilla/websocket v1.5.3 h1:saDtZ6Pbx/0u+bgYQ3q96pZgCzfhKXGPqt7kZ72aNNg=
github.com/gorilla/websocket v1.5.3/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=
github.com/jackc/pgpassfile v1.0.0 h1:/6Hmqy13Ss2zCq62VdNG8tM1wchn8zjSGOBJ6icpsIM=
github.com/jackc/pgpassfile v1.0.0/go.mod h1:CEx0iS5ambNFdcRtxPj5JhEz+xB6uRky5eyVu/W2HEg=
github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 h1:iCEnooe7UlwOQYpKFhBabPMi4aNAfoODPEFNiAnClxo=
github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761/go.mod h1:5TJZWKEWniPve33vlWYSoGYefn3gLQRzjfDlhSJ9ZKM=
github.com/jackc/pgx/v5 v5.7.4 h1:9wKznZrhWa2QiHL+NjTSPP6yjl3451BX3imWDnokYlg=
github.com/jackc/pgx/v5 v5.7.4/go.mod h1:ncY89UGWxg82EykZUwSpUKEfccBGGYq1xjrOpsbsfGQ=
github.com/jackc/puddle/v2 v2.2.2 h1:PR8nw+E/1w0GLuRFSmiioY6UooMp6KJv0/61nB7icHo=
github.com/jackc/puddle/v2 v2.2.2/go.mod h1:vriiEXHvEE654aYKXXjOvZM39qJ0q+azkZFrfEOc3H4=
github.com/jinzhu/inflection v1.0.0 h1:K317FqzuhWc8YvSVlFMCCUb36O/S9MCKRDI7QkRKD/E=
github.com/jinzhu/inflection v1.0.0/go.mod h1:h+uFLlag+Qp1Va5pdKtLDYj+kHp5pxUVkryuEj+Srlc=
github.com/jinzhu/now v1.1.5 h1:/o9tlHleP7gOFmsnYNz3RGnqzefHA47wQpKrrdTIwXQ=
github.com/jinzhu/now v1.1.5/go.mod h1:d3SSVoowX0Lcu0IBviAWJpolVfI5UJVZZ7cO71lE/z8=
github.com/joho/godotenv v1.5.1 h1:7eLL/+HRGLY0ldzfGMeQkb7vMd0as4CfYvUVzLqw0N0=
github.com/joho/godotenv v1.5.1/go.mod h1:f4LDr5Voq0i2e/R5DDNOoa2zzDfwtkZa6DnEwAbqwq4=
github.com/josharian/intern v1.0.0 h1:vlS4z54oSdjm0bgjRigI+G1HpF+tI+9rE5LLzOg8HmY=
github.com/josharian/intern v1.0.0/go.mod h1:5DoeVV0s6jJacbCEi61lwdGj/aVlrQvzHFFd8Hwg//Y=
github.com/json-iterator/go v1.1.12 h1:PV8peI4a0ysnczrg+LtxykD8LfKY9ML6u2jnxaEnrnM=
github.com/json-iterator/go v1.1.12/go.mod h1:e30LSqwooZae/UwlEbR2852Gd8hjQvJoHmT4TnhNGBo=
github.com/klauspost/cpuid/v2 v2.0.9/go.mod h1:FInQzS24/EEf25PyTYn52gqo7WaD8xa0213Md/qVLRg=
github.com/klauspost/cpuid/v2 v2.2.10 h1:tBs3QSyvjDyFTq3uoc/9xFpCuOsJQFNPiAhYdw2skhE=
github.com/klauspost/cpuid/v2 v2.2.10/go.mod h1:hqwkgyIinND0mEev00jJYCxPNVRVXFQeu1XKlok6oO0=
github.com/knz/go-libedit v1.10.1/go.mod h1:MZTVkCWyz0oBc7JOWP3wNAzd002ZbM/5hgShxwh4x8M=
github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
github.com/leodido/go-urn v1.4.0 h1:WT9HwE9SGECu3lg4d/dIA+jxlljEa1/ffXKmRjqdmIQ=
github.com/leodido/go-urn v1.4.0/go.mod h1:bvxc+MVxLKB4z00jd1z+Dvzr47oO32F/QSNjSBOlFxI=
github.com/mailru/easyjson v0.9.0 h1:PrnmzHw7262yW8sTBwxi1PdJA3Iw/EKBa8psRf7d9a4=
github.com/mailru/easyjson v0.9.0/go.mod h1:1+xMtQp2MRNVL/V1bOzuP3aP8VNwRW55fQUto+XFtTU=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/mitchellh/mapstructure v1.5.0 h1:jeMsZIYE/09sWLaz43PL7Gy6RuMjD2eJVyuac5Z2hdY=
github.com/mitchellh/mapstructure v1.5.0/go.mod h1:bFUtVrKA4DC2yAKiSyO/QUcy7e+RRV2QTWOzhPopBRo=
github.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd h1:TRLaZ9cD/w8PVh93nsPXa1VrQ6jlwL5oN8l14QlcNfg=
github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
github.com/modern-go/reflect2 v1.0.2 h1:xBagoLtFs94CBntxluKeaWgTMpvLxC4ur3nMaC9Gz0M=
github.com/modern-go/reflect2 v1.0.2/go.mod h1:yWuevngMOJpCy52FWWMvUC8ws7m/LJsjYzDa0/r8luk=
github.com/oklog/ulid v1.3.1 h1:EGfNDEx6MqHz8B3uNV6QAib1UR2Lm97sHi3ocA6ESJ4=
github.com/oklog/ulid v1.3.1/go.mod h1:CirwcVhetQ6Lv90oh/F+FBtV6XMibvdAFo93nm5qn4U=
github.com/pelletier/go-toml/v2 v2.2.4 h1:mye9XuhQ6gvn5h28+VilKrrPoQVanw5PMw/TB0t5Ec4=
github.com/pelletier/go-toml/v2 v2.2.4/go.mod h1:2gIqNv+qfxSVS7cM2xJQKtLSTLUE9V8t9Stt+h56mCY=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/russross/blackfriday/v2 v2.1.0 h1:JIOH55/0cWyOuilr9/qlrm0BSXldqnqwMsf35Ld67mk=
github.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=
github.com/shurcooL/sanitized_anchor_name v1.0.0 h1:PdmoCO6wvbs+7yrJyMORt4/BmY5IYyJwS/kOiWx8mHo=
github.com/shurcooL/sanitized_anchor_name v1.0.0/go.mod h1:1NzhyTcUVG4SuEtjjoZeVRXNmyL/1OwPU0+IJeTBvfc=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=
github.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=
github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=
github.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
github.com/swaggo/files v1.0.1 h1:J1bVJ4XHZNq0I46UU90611i9/YzdrF7x92oX1ig5IdE=
github.com/swaggo/files v1.0.1/go.mod h1:0qXmMNH6sXNf+73t65aKeB+ApmgxdnkQzVTAj2uaMUg=
github.com/swaggo/gin-swagger v1.6.0 h1:y8sxvQ3E20/RCyrXeFfg60r6H0Z+SwpTjMYsMm+zy8M=
github.com/swaggo/gin-swagger v1.6.0/go.mod h1:BG00cCEy294xtVpyIAHG6+e2Qzj/xKlRdOqDkvq0uzo=
github.com/swaggo/swag v1.16.4 h1:clWJtd9LStiG3VeijiCfOVODP6VpHtKdQy9ELFG3s1A=
github.com/swaggo/swag v1.16.4/go.mod h1:VBsHJRsDvfYvqoiMKnsdwhNV9LEMHgEDZcyVYX0sxPg=
github.com/twitchyliquid64/golang-asm v0.15.1 h1:SU5vSMR7hnwNxj24w34ZyCi/FmDZTkS4MhqMhdFk5YI=
github.com/twitchyliquid64/golang-asm v0.15.1/go.mod h1:a1lVb/DtPvCB8fslRZhAngC2+aY1QWCk3Cedj/Gdt08=
github.com/ugorji/go/codec v1.2.12 h1:9LC83zGrHhuUA9l16C9AHXAqEV/2wBQ4nkvumAE65EE=
github.com/ugorji/go/codec v1.2.12/go.mod h1:UNopzCgEMSXjBc6AOMqYvWC1ktqTAfzJZUZgYf6w6lg=
github.com/urfave/cli/v2 v2.27.6 h1:VdRdS98FNhKZ8/Az8B7MTyGQmpIr36O1EHybx/LaZ4g=
github.com/urfave/cli/v2 v2.27.6/go.mod h1:3Sevf16NykTbInEnD0yKkjDAeZDS0A6bzhBH5hrMvTQ=
github.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1 h1:gEOO8jv9F4OT7lGCjxCBTO/36wtF6j2nSip77qHd4x4=
github.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1/go.mod h1:Ohn+xnUBiLI6FVj/9LpzZWtj1/D6lUovWYBkxHVV3aM=
github.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=
go.mongodb.org/mongo-driver v1.14.0 h1:P98w8egYRjYe3XDjxhYJagTokP/H6HzlsnojRgZRd80=
go.mongodb.org/mongo-driver v1.14.0/go.mod h1:Vzb0Mk/pa7e6cWw85R4F/endUC3u0U9jGcNU603k65c=
golang.org/x/arch v0.16.0 h1:foMtLTdyOmIniqWCHjY6+JxuC54XP1fDwx4N0ASyW+U=
golang.org/x/arch v0.16.0/go.mod h1:JmwW7aLIoRUKgaTzhkiEFxvcEiQGyOg9BMonBJUS7EE=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=
golang.org/x/crypto v0.37.0 h1:kJNSjF/Xp7kU0iB2Z+9viTPMW4EqqsrywMXLJOOsXSE=
golang.org/x/crypto v0.37.0/go.mod h1:vg+k43peMZ0pUMhYmVAWysMK35e6ioLh3wB8ZCAfbVc=
golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=
golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
golang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=
golang.org/x/net v0.7.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=
golang.org/x/net v0.39.0 h1:ZCu7HMWDxpXpaiKdhzIfaltL9Lp31x/3fCP11bc6/fY=
golang.org/x/net v0.39.0/go.mod h1:X7NRbYVEA+ewNkCNyJ513WmMdQ3BineSwVtN2zD/d+E=
golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.13.0 h1:AauUjRAJ9OSnvULf/ARrrVywoJDy0YS2AwQ98I37610=
golang.org/x/sync v0.13.0/go.mod h1:1dzgHSNfp02xaA81J2MS99Qcpr2w7fw1gpm99rleRqA=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.32.0 h1:s77OFDvIQeibCmezSnk/q6iAfkdiQaJi4VzroCFrN20=
golang.org/x/sys v0.32.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=
golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=
golang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=
golang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=
golang.org/x/text v0.24.0 h1:dd5Bzh4yt5KYA8f9CJHCP4FB4D51c2c6JvN37xJJkJ0=
golang.org/x/text v0.24.0/go.mod h1:L8rBsPeo2pSS+xqN0d5u2ikmjtmoJbDBT1b7nHvFCdU=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=
golang.org/x/tools v0.32.0 h1:Q7N1vhpkQv7ybVzLFtTjvQya2ewbwNDZzUgfXGqtMWU=
golang.org/x/tools v0.32.0/go.mod h1:ZxrU41P/wAbZD8EDa6dDCa6XfpkhJ7HFMjHJXfBDu8s=
golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
google.golang.org/protobuf v1.36.6 h1:z1NpPI8ku2WgiWnf+t9wTPsn6eP1L7ksHUlkfLvd9xY=
google.golang.org/protobuf v1.36.6/go.mod h1:jduwjTPXsFjZGTmRluh+L6NjiWu7pchiJ2/5YcXBHnY=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=
gopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gorm.io/driver/postgres v1.5.11 h1:ubBVAfbKEUld/twyKZ0IYn9rSQh448EdelLYk9Mv314=
gorm.io/driver/postgres v1.5.11/go.mod h1:DX3GReXH+3FPWGrrgffdvCk3DQ1dwDPdmbenSkweRGI=
gorm.io/gorm v1.25.12 h1:I0u8i2hWQItBq1WfE0o2+WuL9+8L21K9e2HHSTE/0f8=
gorm.io/gorm v1.25.12/go.mod h1:xh7N7RHfYlNc5EmcI/El95gXusucDrQnHXe0+CgWcLQ=
nullprogram.com/x/optparse v1.0.0/go.mod h1:KdyPE+Igbe0jQUrVfMqDMeJQIJZEuyV7pjYmp6pbG50=
rsc.io/pdf v0.1.1/go.mod h1:n8OzWcQ6Sp37PL01nO98y4iUCRdTGarVfzxY20ICaU4=
sigs.k8s.io/yaml v1.4.0 h1:Mk1wCc2gy/F0THH0TAp1QYyJNzRm2KCLy3o5ASXVI5E=
sigs.k8s.io/yaml v1.4.0/go.mod h1:Ejl7/uTz7PSA4eKMyQCUTnhZYNmLIl+5c2lQPGR2BPY=


================================================================================

Filename: internal/database/database.go
Content:
package database

import (
	"fmt"
	"log"
	"os"
	"time"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"

	"geoguessr-backend/internal/models"

)

var DB *gorm.DB

func Connect() error {

	dbHost := os.Getenv("DB_HOST")
	if dbHost == "" {
		dbHost = "localhost"
	}
	dbPort := os.Getenv("DB_PORT")
	if dbPort == "" {
		dbPort = "5432"
	}
	dbUser := os.Getenv("DB_USER")
	if dbUser == "" {
		dbUser = "postgres"
	}
	dbPassword := os.Getenv("DB_PASSWORD")
	if dbPassword == "" {
		log.Println("WARNING: DB_PASSWORD environment variable not set.")

		dbPassword = "mysecretpassword"
	}
	dbName := os.Getenv("DB_NAME")
	if dbName == "" {
		dbName = "geoguessr"
	}
	dbSSLMode := os.Getenv("DB_SSLMODE")
	if dbSSLMode == "" {
		dbSSLMode = "disable"
	}

	dsn := fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%s sslmode=%s TimeZone=UTC",
		dbHost, dbUser, dbPassword, dbName, dbPort, dbSSLMode)

	
	logLevel := logger.Warn // <<< Change from logger.Info to logger.Warn
	if os.Getenv("GORM_LOG_LEVEL") == "info" {
		logLevel = logger.Info // Allow overriding via env var if needed
	}

	newLogger := logger.New(
		log.New(os.Stdout, "\r\n", log.LstdFlags), // io writer
		logger.Config{
			SlowThreshold:             time.Second * 2, // Slow SQL threshold (optional)
			LogLevel:                  logLevel,         // Set the desired log level
			IgnoreRecordNotFoundError: true,            // Don't log ErrRecordNotFound errors (usually expected)
			ParameterizedQueries:      false,           // Don't include params in Info level logs (optional)
			Colorful:                  true,            // Enable color (optional)
		},
	)
	// ---------------------------

	var err error
	DB, err = gorm.Open(postgres.Open(dsn), &gorm.Config{
		Logger: newLogger, // <<< Use the configured logger
	})

	if err != nil {
		return fmt.Errorf("failed to connect to database: %w", err)
	}

	log.Println("Database connection established successfully.")
	log.Println("Running auto migrations...")
	err = DB.AutoMigrate(
		&models.Location{},
		&models.User{},
		&models.Game{},
		&models.Round{},
	)
	if err != nil {
		return fmt.Errorf("failed to auto migrate database: %w", err)
	}
	log.Println("Auto migrations completed.")

	return nil
}

func GetDB() *gorm.DB {
	return DB
}

================================================================================

Filename: internal/handlers/auth_handler.go
Content:

package handlers

import (
	"log"
	"net/http"
	"strings" 

	"geoguessr-backend/internal/database" 
	"geoguessr-backend/internal/models"    
	"geoguessr-backend/internal/utils"     

	"github.com/gin-gonic/gin"
	"github.com/go-playground/validator/v10" 
	"golang.org/x/crypto/bcrypt"
	"gorm.io/gorm"
)


var validate = validator.New()

// Register godoc
// @Summary      Register a new user
// @Description  Creates a new user account with username, email, and password.
// @Tags         Auth
// @Accept       json
// @Produce      json
// @Param        userInput body models.RegisterInput true "User Registration Info"
// @Success      201  {object}  map[string]interface{}  "User registered successfully (returns basic user info)"
// @Failure      400  {object}  map[string]string "Invalid input format or validation failed"
// @Failure      409  {object}  map[string]string "Conflict: Username or Email already exists"
// @Failure      500  {object}  map[string]string "Internal server error (hashing, DB create)"
// @Router       /auth/register [post]
func Register(c *gin.Context) {
	var input models.RegisterInput

	
	if err := c.ShouldBindJSON(&input); err != nil {
		log.Printf("Register Error - Binding: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input format"})
		return
	}

	
	if err := validate.Struct(input); err != nil {
		log.Printf("Register Error - Validation: %v", err)
		
		c.JSON(http.StatusBadRequest, gin.H{"error": "Validation failed: " + err.Error()})
		return
	}

	db := database.GetDB()

	
	var existingUser models.User
	err := db.Where("email = ? OR username = ?", input.Email, input.Username).First(&existingUser).Error
	if err == nil {
		
		errorMsg := "Conflict: "
		if strings.EqualFold(existingUser.Email, input.Email) { 
			errorMsg += "Email already exists."
		} else {
			errorMsg += "Username already exists."
		}
		log.Printf("Register Error - Conflict: %s", errorMsg)
		c.JSON(http.StatusConflict, gin.H{"error": errorMsg})
		return
	} else if err != gorm.ErrRecordNotFound {
		
		log.Printf("Register Error - DB Check: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Database error checking user existence"})
		return
	}
	

	
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		log.Printf("Register Error - Hashing: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to process password"})
		return
	}

	
	newUser := models.User{
		Username:     input.Username,
		Email:        input.Email,
		PasswordHash: string(hashedPassword),
	}

	
	result := db.Create(&newUser)
	if result.Error != nil {
		log.Printf("Register Error - DB Create: %v", result.Error)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to register user"})
		return
	}

	log.Printf("User registered successfully: %s (%s)", newUser.Username, newUser.Email)
	
	c.JSON(http.StatusCreated, gin.H{
		"message": "User registered successfully",
		"user": gin.H{
			"id":       newUser.ID,
			"username": newUser.Username,
			"email":    newUser.Email,
		},
	})
}

// Login godoc
// @Summary      Log in a user
// @Description  Authenticates a user with email and password, returns a JWT token upon success.
// @Tags         Auth
// @Accept       json
// @Produce      json
// @Param        credentials body models.LoginInput true "User Login Credentials"
// @Success      200  {object}  map[string]interface{} "Login successful (returns JWT token and basic user info)"
// @Failure      400  {object}  map[string]string "Invalid input format or validation failed"
// @Failure      401  {object}  map[string]string "Invalid credentials (user not found or password mismatch)"
// @Failure      500  {object}  map[string]string "Internal server error (DB find, token generation)"
// @Router       /auth/login [post]
func Login(c *gin.Context) {
	var input models.LoginInput

	
	if err := c.ShouldBindJSON(&input); err != nil {
		log.Printf("Login Error - Binding: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input format"})
		return
	}

	
	if err := validate.Struct(input); err != nil {
		log.Printf("Login Error - Validation: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Validation failed: " + err.Error()})
		return
	}

	db := database.GetDB()
	var user models.User

	
	
	
	result := db.Where("email = ?", input.Email).First(&user) 
	if result.Error != nil {
		if result.Error == gorm.ErrRecordNotFound {
			log.Printf("Login Error - User not found: %s", input.Email)
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"}) 
		} else {
			log.Printf("Login Error - DB Find: %v", result.Error)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Database error finding user"})
		}
		return
	}

	
	err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(input.Password))
	if err != nil {
		
		log.Printf("Login Error - Password mismatch for user: %s", input.Email)
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"}) 
		return
	}

	
	token, err := utils.GenerateToken(user.ID)
	if err != nil {
		log.Printf("Login Error - Token Generation: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to generate login token"})
		return
	}

	log.Printf("User logged in successfully: %s (%d)", user.Username, user.ID)
	
	c.JSON(http.StatusOK, gin.H{
		"message": "Login successful",
		"token":   token,
		"user": gin.H{ 
			"id":       user.ID,
			"username": user.Username,
			"email":    user.Email,
		},
	})
}

================================================================================

Filename: internal/handlers/game_handler.go
Content:
package handlers

import (
	"log"
	"net/http"
	"strconv"
	"time"

	"geoguessr-backend/internal/database"
	"geoguessr-backend/internal/models"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
)

const defaultRounds = 5

type GameLocationResponse struct {
	ID        uint    `json:"id"`
	Latitude  float64 `json:"lat"`
	Longitude float64 `json:"lng"`
}

// StartGame godoc
// @Summary      Start a new game
// @Description  Fetches a specified number of random locations for a new game session.
// @Tags         Game
// @Produce      json
// @Param        rounds query int false "Number of rounds (default: 5)" mininum(1) maximum(10)
// @Success      200 {object} map[string]interface{} "Game started successfully (returns gameId placeholder and locations)"
// @Failure      500 {object} map[string]string "Internal server error (failed to fetch locations)"
// @Router       /game/start [get]
func StartGame(c *gin.Context) {
	log.Println("Handler: StartGame invoked")

	roundsStr := c.DefaultQuery("rounds", strconv.Itoa(defaultRounds))
	rounds, err := strconv.Atoi(roundsStr)
	if err != nil || rounds <= 0 {
		rounds = defaultRounds
	}
	log.Printf("Handler: Requesting %d rounds", rounds)

	db := database.GetDB()

	var locations []models.Location
	var responseLocations []GameLocationResponse

	result := db.Model(&models.Location{}).
		Order("RANDOM()").
		Limit(rounds).
		Find(&locations)

	if result.Error != nil {
		log.Printf("Error fetching locations: %v", result.Error)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch game locations"})
		return
	}

	if len(locations) < rounds {

		log.Printf("Warning: Found only %d locations, requested %d", len(locations), rounds)

		if len(locations) == 0 {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "No locations found in database"})
			return
		}
	}

	for _, loc := range locations {
		responseLocations = append(responseLocations, GameLocationResponse{
			ID:        loc.ID,
			Latitude:  loc.Latitude,
			Longitude: loc.Longitude,
		})
	}

	log.Printf("Handler: Successfully fetched %d locations", len(responseLocations))
	c.JSON(http.StatusOK, gin.H{
		"gameId":    "mock_backend_game_" + strconv.Itoa(int(time.Now().Unix())),
		"locations": responseLocations,
	})
}

// FinishGame saves the results of a completed game
// @Summary      Submit game results
// @Description  Saves the total score and round details for a completed game session for the authenticated user.
// @Tags         Game
// @Accept       json
// @Produce      json
// @Param        gameResult body models.SubmitGameInput true "Completed Game Data"
// @Success      201  {object}  map[string]interface{} "Game results saved successfully"
// @Failure      400  {object}  map[string]string "Invalid input format or validation failed"
// @Failure      401  {object}  map[string]string "Unauthorized (invalid/missing token)"
// @Failure      500  {object}  map[string]string "Internal server error (database error)"
// @Security     BearerAuth
// @Router       /game/finish [post]
func FinishGame(c *gin.Context) {
	var input models.SubmitGameInput
	var newGame models.Game // <<< Declare newGame OUTSIDE the transaction scope

	// 1. Get User ID from context
	userIDAny, exists := c.Get("userID")
	if !exists {
		log.Println("FinishGame Error: userID not found in context")
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User authentication not found"})
		return
	}
	userID, ok := userIDAny.(uint)
	if !ok {
		log.Println("FinishGame Error: userID in context is not uint")
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Internal server error processing user identity"})
		return
	}
	log.Printf("FinishGame Handler: Processing submission for user ID: %d", userID)

	// 2. Bind JSON input
	if err := c.ShouldBindJSON(&input); err != nil {
		log.Printf("FinishGame Error - Binding: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input format: " + err.Error()})
		return
	}

	// 3. Validate input struct
	if err := validate.Struct(input); err != nil {
		log.Printf("FinishGame Error - Validation: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Validation failed: " + err.Error()})
		return
	}

	db := database.GetDB()

	// --- Save Game and Rounds within a Transaction ---
	err := db.Transaction(func(tx *gorm.DB) error {
		// 4. Create the main Game record
		// Assign to the newGame declared outside
		newGame = models.Game{
			UserID:       userID,
			TotalScore:   input.TotalScore,
			RoundsPlayed: input.RoundsPlayed,
		}
		if err := tx.Create(&newGame).Error; err != nil {
			log.Printf("FinishGame Error - DB Create Game: %v", err)
			return err
		}
		log.Printf("FinishGame - Created Game record ID: %d", newGame.ID)

		// 5. Create Round records linked to the Game
		for _, roundInput := range input.Rounds {
			newRound := models.Round{
				GameID:      newGame.ID, // Use ID from the created game
				LocationID:  roundInput.LocationID,
				RoundNumber: roundInput.RoundNumber,
				GuessLat:    roundInput.GuessLat,
				GuessLng:    roundInput.GuessLng,
				ActualLat:   roundInput.ActualLat,
				ActualLng:   roundInput.ActualLng,
				DistanceKm:  roundInput.DistanceKm,
				Score:       roundInput.Score,
			}
			if err := tx.Create(&newRound).Error; err != nil {
				log.Printf("FinishGame Error - DB Create Round %d: %v", roundInput.RoundNumber, err)
				return err
			}
		}
		log.Printf("FinishGame - Successfully created %d Round records for Game ID: %d", len(input.Rounds), newGame.ID)
		return nil
	})
	// --- End Transaction ---

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to save game results due to database error"})
		return
	}

	// 6. Return Success Response (newGame is now accessible here)
	log.Printf("FinishGame - Successfully saved results for User ID: %d", userID)
	c.JSON(http.StatusCreated, gin.H{
		"message": "Game results saved successfully",
		"gameId":  newGame.ID,
	})
}


================================================================================

Filename: internal/middleware/auth.go
Content:
// internal/middleware/auth.go
package middleware

import (
	"log"
	"net/http"

	"geoguessr-backend/internal/utils" // Adjust path

	"github.com/gin-gonic/gin"
)

// AuthRequired is a middleware function to protect routes
func AuthRequired() gin.HandlerFunc {
	return func(c *gin.Context) {
		tokenString := utils.ExtractToken(c) // Get token from "Bearer <token>" header
		if tokenString == "" {
			log.Println("Auth Middleware: No token provided")
			c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "Authorization token required"})
			return
		}

		token, err := utils.ValidateToken(tokenString) // Validate signature, expiry, etc.
		if err != nil {
			log.Printf("Auth Middleware: Invalid token: %v", err)
			c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "Invalid or expired token"})
			return
		}

		// Token is valid, extract user ID
		userID, err := utils.ExtractUserIDFromToken(token)
		if err != nil {
			log.Printf("Auth Middleware: Failed to extract userID from valid token: %v", err)
			c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "Invalid token claims"})
			return
		}

		// Set user ID in the context for subsequent handlers to use
		c.Set("userID", userID)
		log.Printf("Auth Middleware: User %d authenticated", userID)

		// Proceed to the next handler
		c.Next()
	}
}


================================================================================

Filename: internal/models/game.go
Content:
// internal/models/game.go
package models

import (
	"time"

)

// Game represents a completed game session by a user
type Game struct {
	ID           uint      `gorm:"primaryKey"`
	UserID       uint      `gorm:"not null;index"` // Foreign key to User table
	User         User      // GORM association (belongs to User) - optional but useful for preloading
	TotalScore   int       `gorm:"not null"`
	RoundsPlayed int       `gorm:"not null"` // Typically 5, but could be variable
	CreatedAt    time.Time // When the game was completed/saved
	UpdatedAt    time.Time

	Rounds []Round `gorm:"foreignKey:GameID"` // GORM association (has many Rounds)
}
// RoundResultInput represents the data for a single round sent from frontend
type RoundResultInput struct {
	RoundNumber int     `json:"roundNumber" validate:"required,min=1"`
	LocationID  uint    `json:"locationId" validate:"required,min=1"`
	GuessLat    float64 `json:"guessLat" validate:"required"`
	GuessLng    float64 `json:"guessLng" validate:"required"`
	ActualLat   float64 `json:"actualLat" validate:"required"` // Send actual coords for verification/record
	ActualLng   float64 `json:"actualLng" validate:"required"`
	DistanceKm  float64 `json:"distanceKm" validate:"min=0"`
	Score       int     `json:"score" validate:"required,min=0"`
}

// SubmitGameInput represents the complete game data sent from frontend
type SubmitGameInput struct {
	// GameID      string             `json:"gameId"` // We might generate ID on backend instead
	TotalScore   int                `json:"totalScore" validate:"required,min=0"`
	RoundsPlayed int                `json:"roundsPlayed" validate:"required,min=1"`
	Rounds       []RoundResultInput `json:"rounds" validate:"required,min=1,dive"` // 'dive' validates each element in slice
}

================================================================================

Filename: internal/models/location.go
Content:
package models

import "gorm.io/gorm"

type Location struct {
	gorm.Model
	Latitude    float64 `gorm:"not null;index:idx_lat"`
	Longitude   float64 `gorm:"not null;index:idx_lng"`
	Description string `gorm: index:idx_description"`
	Country     string `gorm:"index:idx_country"`
	Region      string `gorm:"index:idx_region"`

	// Composite index for lat/lng pairs
	// This is especially useful for geographic queries
	// that need to look up locations by both coordinates
	_ int `gorm:"index:idx_lat_lng,priority:1,columns:latitude,longitude"`
}


================================================================================

Filename: internal/models/round.go
Content:
// internal/models/round.go
package models

import (
	"time"

	"gorm.io/gorm"
)

// Round represents the result of a single round within a game
type Round struct {
	ID          uint     `gorm:"primaryKey"`
	GameID      uint     `gorm:"not null;index"` // Foreign key to Game table
	LocationID  uint     `gorm:"not null"`       // Foreign key to Location table
	Location    Location // GORM association (belongs to Location) - optional
	RoundNumber int      `gorm:"not null"` // e.g., 1, 2, 3, 4, 5
	GuessLat    float64  `gorm:"not null"` // User's guessed latitude
	GuessLng    float64  `gorm:"not null"` // User's guessed longitude
	ActualLat   float64  `gorm:"not null"` // Actual latitude (from Location)
	ActualLng   float64  `gorm:"not null"` // Actual longitude (from Location)
	DistanceKm  float64  // Calculated distance in km
	Score       int      `gorm:"not null"` // Score for this round
	CreatedAt   time.Time
	UpdatedAt   time.Time
	DeletedAt   gorm.DeletedAt `gorm:"index"` // Soft delete support
}


================================================================================

Filename: internal/models/user.go
Content:
package models

import (
	"time" 

	"gorm.io/gorm"
)


type User struct {
	ID        uint   `gorm:"primaryKey"`
	Username  string `gorm:"size:50;not null;uniqueIndex" validate:"required,min=3,max=50"` 
	Email     string `gorm:"size:100;not null;uniqueIndex" validate:"required,email"`        
	PasswordHash string `gorm:"not null" validate:"required"`                             
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt gorm.DeletedAt `gorm:"index"` 

	
	
	
}




type RegisterInput struct {
	Username string `json:"username" validate:"required,min=3,max=50"`
	Email    string `json:"email" validate:"required,email"`
	Password string `json:"password" validate:"required,min=6,max=72"` 
}


type LoginInput struct {
	Email    string `json:"email" validate:"required,email"`
	Password string `json:"password" validate:"required"`
}

================================================================================

Filename: internal/utils/token.go
Content:
package utils

import (
	"fmt"
	"log"
	"os"
	
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v5"
)

var jwtSecretKey []byte


func InitializeJWT() {
	secret := os.Getenv("JWT_SECRET_KEY")
	if secret == "" {
		log.Fatal("FATAL: JWT_SECRET_KEY environment variable not set!")
	}
	jwtSecretKey = []byte(secret)
	log.Println("JWT Secret Key loaded.")
}


func GenerateToken(userID uint) (string, error) {
	
	
	
	expirationTime := time.Now().Add(24 * time.Hour) 
	claims := jwt.MapClaims{
		"user_id": userID,
		"exp":     expirationTime.Unix(),
		"iat":     time.Now().Unix(),
		"iss":     "terraquest-backend", 
	}

	
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	
	tokenString, err := token.SignedString(jwtSecretKey)
	if err != nil {
		return "", fmt.Errorf("failed to sign token: %w", err)
	}

	return tokenString, nil
}


func ValidateToken(tokenString string) (*jwt.Token, error) {
	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
		
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		
		return jwtSecretKey, nil
	})

	if err != nil {
		return nil, fmt.Errorf("failed to parse token: %w", err) 
	}

	if !token.Valid {
		return nil, fmt.Errorf("invalid token")
	}

	return token, nil
}


func ExtractToken(c *gin.Context) string {
	bearerToken := c.Request.Header.Get("Authorization")
	
	parts := strings.Split(bearerToken, " ")
	if len(parts) == 2 && parts[0] == "Bearer" {
		return parts[1]
	}
	return ""
}


func ExtractUserIDFromToken(token *jwt.Token) (uint, error) {
	claims, ok := token.Claims.(jwt.MapClaims)
	if !ok || !token.Valid {
		return 0, fmt.Errorf("invalid token claims")
	}

	
	userIDFloat, ok := claims["user_id"].(float64)
	if !ok {
		return 0, fmt.Errorf("user_id claim is not a valid number")
	}

	
	return uint(userIDFloat), nil
}


func ExtractUserID(c *gin.Context) (uint, error) {
	tokenString := ExtractToken(c)
	if tokenString == "" {
		return 0, fmt.Errorf("authorization token not provided")
	}

	token, err := ValidateToken(tokenString)
	if err != nil {
		return 0, err 
	}

	return ExtractUserIDFromToken(token)
}

================================================================================

Filename: repo_contents.txt
Content:

Filename: .gitignore
Content:
.env
.vscode
repo_contents.txt

================================================================================

Filename: cmd/server/main.go
Content:
package main

import (
	"log"
	"net/http"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
	"github.com/joho/godotenv"

	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"

	"github.com/go-openapi/runtime/middleware"

	_ "geoguessr-backend/docs" // for swagger docs
	"geoguessr-backend/internal/database"
	"geoguessr-backend/internal/handlers"
	internalMiddleware "geoguessr-backend/internal/middleware"
	"geoguessr-backend/internal/utils"
)

// @title           TerraQuest Backend API
// @version         1.0
// @description     API Server for the TerraQuest GeoGuessr clone game.
// @termsOfService  http://swagger.io/terms/  <-- Update later

// @contact.name   API Support
// @contact.url    http://www.example.com/support <-- Update later
// @contact.email  support@example.com <-- Update later

// @license.name  Apache 2.0  <-- Or your chosen license
// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html

// @host      localhost:8080
// @BasePath  /api/v1

// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
// @description Type "Bearer" followed by a space and JWT token.

func main() {
	log.Println("Starting GeoGuessr Backend Server...")

	err := godotenv.Load()
	if err != nil {
		log.Println("No .env file found, using system environment variables.")
	}

	utils.InitializeJWT()

	err = database.Connect()
	if err != nil {
		log.Fatalf("Could not connect to the database: %v", err)
	}

	router := gin.Default()

	config := cors.DefaultConfig()

	config.AllowOrigins = []string{"http://localhost:5173"}
	config.AllowMethods = []string{"GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"}
	config.AllowHeaders = []string{"Origin", "Content-Type", "Accept", "Authorization"}

	router.Use(cors.New(config))

	router.GET("/docs/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
	log.Println("Swagger UI available at http://localhost:8080/docs/index.html")

	opts := middleware.RedocOpts{
		SpecURL: "/docs/doc.json",
		Path:    "/redoc",
		Title:   "TerraQuest API Docs (ReDoc)",
	}
	redocHandler := middleware.Redoc(opts, nil)
	router.GET("/redoc", gin.WrapH(redocHandler))
	log.Println("ReDoc UI available at http://localhost:8080/redoc")

	api := router.Group("/api/v1")
	{
		authGroup := api.Group("/auth")
		{
			authGroup.POST("/register", handlers.Register)
			authGroup.POST("/login", handlers.Login)
		}

		// Game routes - apply auth middleware here
		gameGroup := api.Group("/game")
		// Apply AuthRequired middleware to all routes within this group
		gameGroup.Use(internalMiddleware.AuthRequired()) // <<< APPLY MIDDLEWARE
		{
			gameGroup.GET("/start", handlers.StartGame)
			gameGroup.POST("/finish", handlers.FinishGame)

		}

	}

	router.GET("/ping", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"message": "pong"})
	})

	port := ":8080"
	log.Printf("Server listening on port %s\n", port)
	err = router.Run(port)
	if err != nil {
		log.Fatalf("Failed to start server: %v", err)
	}
}


================================================================================

Filename: docs/docs.go
Content:
// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/  \u003c-- Update later",
        "contact": {
            "name": "API Support",
            "url": "http://www.example.com/support \u003c-- Update later",
            "email": "support@example.com \u003c-- Update later"
        },
        "license": {
            "name": "Apache 2.0  \u003c-- Or your chosen license",
            "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/auth/login": {
            "post": {
                "description": "Authenticates a user with email and password, returns a JWT token upon success.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Log in a user",
                "parameters": [
                    {
                        "description": "User Login Credentials",
                        "name": "credentials",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.LoginInput"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Login successful (returns JWT token and basic user info)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid input format or validation failed",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "Invalid credentials (user not found or password mismatch)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal server error (DB find, token generation)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/auth/register": {
            "post": {
                "description": "Creates a new user account with username, email, and password.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Register a new user",
                "parameters": [
                    {
                        "description": "User Registration Info",
                        "name": "userInput",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.RegisterInput"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "User registered successfully (returns basic user info)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid input format or validation failed",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "409": {
                        "description": "Conflict: Username or Email already exists",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal server error (hashing, DB create)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/game/start": {
            "get": {
                "description": "Fetches a specified number of random locations for a new game session.",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Game"
                ],
                "summary": "Start a new game",
                "parameters": [
                    {
                        "maximum": 10,
                        "type": "integer",
                        "description": "Number of rounds (default: 5)",
                        "name": "rounds",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Game started successfully (returns gameId placeholder and locations)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error (failed to fetch locations)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "models.LoginInput": {
            "type": "object",
            "required": [
                "email",
                "password"
            ],
            "properties": {
                "email": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                }
            }
        },
        "models.RegisterInput": {
            "type": "object",
            "required": [
                "email",
                "password",
                "username"
            ],
            "properties": {
                "email": {
                    "type": "string"
                },
                "password": {
                    "type": "string",
                    "maxLength": 72,
                    "minLength": 6
                },
                "username": {
                    "type": "string",
                    "maxLength": 50,
                    "minLength": 3
                }
            }
        }
    },
    "securityDefinitions": {
        "BearerAuth": {
            "description": "Type \"Bearer\" followed by a space and JWT token.",
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &swag.Spec{
	Version:          "1.0",
	Host:             "localhost:8080",
	BasePath:         "/api/v1",
	Schemes:          []string{},
	Title:            "TerraQuest Backend API",
	Description:      "API Server for the TerraQuest GeoGuessr clone game.",
	InfoInstanceName: "swagger",
	SwaggerTemplate:  docTemplate,
	LeftDelim:        "{{",
	RightDelim:       "}}",
}

func init() {
	swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}


================================================================================

Filename: docs/swagger.json
Content:
{
    "swagger": "2.0",
    "info": {
        "description": "API Server for the TerraQuest GeoGuessr clone game.",
        "title": "TerraQuest Backend API",
        "termsOfService": "http://swagger.io/terms/  \u003c-- Update later",
        "contact": {
            "name": "API Support",
            "url": "http://www.example.com/support \u003c-- Update later",
            "email": "support@example.com \u003c-- Update later"
        },
        "license": {
            "name": "Apache 2.0  \u003c-- Or your chosen license",
            "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
        },
        "version": "1.0"
    },
    "host": "localhost:8080",
    "basePath": "/api/v1",
    "paths": {
        "/auth/login": {
            "post": {
                "description": "Authenticates a user with email and password, returns a JWT token upon success.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Log in a user",
                "parameters": [
                    {
                        "description": "User Login Credentials",
                        "name": "credentials",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.LoginInput"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Login successful (returns JWT token and basic user info)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid input format or validation failed",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "Invalid credentials (user not found or password mismatch)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal server error (DB find, token generation)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/auth/register": {
            "post": {
                "description": "Creates a new user account with username, email, and password.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Register a new user",
                "parameters": [
                    {
                        "description": "User Registration Info",
                        "name": "userInput",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.RegisterInput"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "User registered successfully (returns basic user info)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid input format or validation failed",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "409": {
                        "description": "Conflict: Username or Email already exists",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal server error (hashing, DB create)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/game/start": {
            "get": {
                "description": "Fetches a specified number of random locations for a new game session.",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Game"
                ],
                "summary": "Start a new game",
                "parameters": [
                    {
                        "maximum": 10,
                        "type": "integer",
                        "description": "Number of rounds (default: 5)",
                        "name": "rounds",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Game started successfully (returns gameId placeholder and locations)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error (failed to fetch locations)",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "models.LoginInput": {
            "type": "object",
            "required": [
                "email",
                "password"
            ],
            "properties": {
                "email": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                }
            }
        },
        "models.RegisterInput": {
            "type": "object",
            "required": [
                "email",
                "password",
                "username"
            ],
            "properties": {
                "email": {
                    "type": "string"
                },
                "password": {
                    "type": "string",
                    "maxLength": 72,
                    "minLength": 6
                },
                "username": {
                    "type": "string",
                    "maxLength": 50,
                    "minLength": 3
                }
            }
        }
    },
    "securityDefinitions": {
        "BearerAuth": {
            "description": "Type \"Bearer\" followed by a space and JWT token.",
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}

================================================================================

Filename: docs/swagger.yaml
Content:
basePath: /api/v1
definitions:
  models.LoginInput:
    properties:
      email:
        type: string
      password:
        type: string
    required:
    - email
    - password
    type: object
  models.RegisterInput:
    properties:
      email:
        type: string
      password:
        maxLength: 72
        minLength: 6
        type: string
      username:
        maxLength: 50
        minLength: 3
        type: string
    required:
    - email
    - password
    - username
    type: object
host: localhost:8080
info:
  contact:
    email: support@example.com <-- Update later
    name: API Support
    url: http://www.example.com/support <-- Update later
  description: API Server for the TerraQuest GeoGuessr clone game.
  license:
    name: Apache 2.0  <-- Or your chosen license
    url: http://www.apache.org/licenses/LICENSE-2.0.html
  termsOfService: http://swagger.io/terms/  <-- Update later
  title: TerraQuest Backend API
  version: "1.0"
paths:
  /auth/login:
    post:
      consumes:
      - application/json
      description: Authenticates a user with email and password, returns a JWT token
        upon success.
      parameters:
      - description: User Login Credentials
        in: body
        name: credentials
        required: true
        schema:
          $ref: '#/definitions/models.LoginInput'
      produces:
      - application/json
      responses:
        "200":
          description: Login successful (returns JWT token and basic user info)
          schema:
            additionalProperties: true
            type: object
        "400":
          description: Invalid input format or validation failed
          schema:
            additionalProperties:
              type: string
            type: object
        "401":
          description: Invalid credentials (user not found or password mismatch)
          schema:
            additionalProperties:
              type: string
            type: object
        "500":
          description: Internal server error (DB find, token generation)
          schema:
            additionalProperties:
              type: string
            type: object
      summary: Log in a user
      tags:
      - Auth
  /auth/register:
    post:
      consumes:
      - application/json
      description: Creates a new user account with username, email, and password.
      parameters:
      - description: User Registration Info
        in: body
        name: userInput
        required: true
        schema:
          $ref: '#/definitions/models.RegisterInput'
      produces:
      - application/json
      responses:
        "201":
          description: User registered successfully (returns basic user info)
          schema:
            additionalProperties: true
            type: object
        "400":
          description: Invalid input format or validation failed
          schema:
            additionalProperties:
              type: string
            type: object
        "409":
          description: 'Conflict: Username or Email already exists'
          schema:
            additionalProperties:
              type: string
            type: object
        "500":
          description: Internal server error (hashing, DB create)
          schema:
            additionalProperties:
              type: string
            type: object
      summary: Register a new user
      tags:
      - Auth
  /game/start:
    get:
      description: Fetches a specified number of random locations for a new game session.
      parameters:
      - description: 'Number of rounds (default: 5)'
        in: query
        maximum: 10
        name: rounds
        type: integer
      produces:
      - application/json
      responses:
        "200":
          description: Game started successfully (returns gameId placeholder and locations)
          schema:
            additionalProperties: true
            type: object
        "500":
          description: Internal server error (failed to fetch locations)
          schema:
            additionalProperties:
              type: string
            type: object
      summary: Start a new game
      tags:
      - Game
securityDefinitions:
  BearerAuth:
    description: Type "Bearer" followed by a space and JWT token.
    in: header
    name: Authorization
    type: apiKey
swagger: "2.0"


================================================================================

Filename: geoguessr.session.sql
Content:
DROP table users;

================================================================================

Filename: go.mod
Content:
module geoguessr-backend

go 1.23.4

require (
	github.com/KyleBanks/depth v1.2.1 // indirect
	github.com/PuerkitoBio/purell v1.2.1 // indirect
	github.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578 // indirect
	github.com/asaskevich/govalidator v0.0.0-20230301143203-a9d515a09cc2 // indirect
	github.com/bytedance/sonic v1.13.2 // indirect
	github.com/bytedance/sonic/loader v0.2.4 // indirect
	github.com/cloudwego/base64x v0.1.5 // indirect
	github.com/cloudwego/iasm v0.2.0 // indirect
	github.com/cpuguy83/go-md2man/v2 v2.0.6 // indirect
	github.com/gabriel-vasile/mimetype v1.4.8 // indirect
	github.com/gin-contrib/cors v1.7.5 // indirect
	github.com/gin-contrib/sse v1.1.0 // indirect
	github.com/gin-gonic/gin v1.10.0 // indirect
	github.com/go-openapi/analysis v0.23.0 // indirect
	github.com/go-openapi/errors v0.22.0 // indirect
	github.com/go-openapi/jsonpointer v0.21.1 // indirect
	github.com/go-openapi/jsonreference v0.21.0 // indirect
	github.com/go-openapi/loads v0.22.0 // indirect
	github.com/go-openapi/runtime v0.28.0 // indirect
	github.com/go-openapi/spec v0.21.0 // indirect
	github.com/go-openapi/strfmt v0.23.0 // indirect
	github.com/go-openapi/swag v0.23.1 // indirect
	github.com/go-openapi/validate v0.24.0 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/go-playground/validator/v10 v10.26.0 // indirect
	github.com/goccy/go-json v0.10.5 // indirect
	github.com/golang-jwt/jwt/v5 v5.2.2 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/gorilla/websocket v1.5.3 // indirect
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 // indirect
	github.com/jackc/pgx/v5 v5.7.4 // indirect
	github.com/jackc/puddle/v2 v2.2.2 // indirect
	github.com/jinzhu/inflection v1.0.0 // indirect
	github.com/jinzhu/now v1.1.5 // indirect
	github.com/joho/godotenv v1.5.1 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/klauspost/cpuid/v2 v2.2.10 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/mailru/easyjson v0.9.0 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mitchellh/mapstructure v1.5.0 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/oklog/ulid v1.3.1 // indirect
	github.com/pelletier/go-toml/v2 v2.2.4 // indirect
	github.com/russross/blackfriday/v2 v2.1.0 // indirect
	github.com/shurcooL/sanitized_anchor_name v1.0.0 // indirect
	github.com/swaggo/files v1.0.1 // indirect
	github.com/swaggo/gin-swagger v1.6.0 // indirect
	github.com/swaggo/swag v1.16.4 // indirect
	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
	github.com/ugorji/go/codec v1.2.12 // indirect
	github.com/urfave/cli/v2 v2.27.6 // indirect
	github.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1 // indirect
	go.mongodb.org/mongo-driver v1.14.0 // indirect
	golang.org/x/arch v0.16.0 // indirect
	golang.org/x/crypto v0.37.0 // indirect
	golang.org/x/net v0.39.0 // indirect
	golang.org/x/sync v0.13.0 // indirect
	golang.org/x/sys v0.32.0 // indirect
	golang.org/x/text v0.24.0 // indirect
	golang.org/x/tools v0.32.0 // indirect
	google.golang.org/protobuf v1.36.6 // indirect
	gopkg.in/yaml.v2 v2.4.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
	gorm.io/driver/postgres v1.5.11 // indirect
	gorm.io/gorm v1.25.12 // indirect
	sigs.k8s.io/yaml v1.4.0 // indirect
)


================================================================================

Filename: go.sum
Content:
github.com/KyleBanks/depth v1.2.1 h1:5h8fQADFrWtarTdtDudMmGsC7GPbOAu6RVB3ffsVFHc=
github.com/KyleBanks/depth v1.2.1/go.mod h1:jzSb9d0L43HxTQfT+oSA1EEp2q+ne2uh6XgeJcm8brE=
github.com/PuerkitoBio/purell v1.2.1 h1:QsZ4TjvwiMpat6gBCBxEQI0rcS9ehtkKtSpiUnd9N28=
github.com/PuerkitoBio/purell v1.2.1/go.mod h1:ZwHcC/82TOaovDi//J/804umJFFmbOHPngi8iYYv/Eo=
github.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578 h1:d+Bc7a5rLufV/sSk/8dngufqelfh6jnri85riMAaF/M=
github.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578/go.mod h1:uGdkoq3SwY9Y+13GIhn11/XLaGBb4BfwItxLd5jeuXE=
github.com/asaskevich/govalidator v0.0.0-20230301143203-a9d515a09cc2 h1:DklsrG3dyBCFEj5IhUbnKptjxatkF07cF2ak3yi77so=
github.com/asaskevich/govalidator v0.0.0-20230301143203-a9d515a09cc2/go.mod h1:WaHUgvxTVq04UNunO+XhnAqY/wQc+bxr74GqbsZ/Jqw=
github.com/bytedance/sonic v1.13.2 h1:8/H1FempDZqC4VqjptGo14QQlJx8VdZJegxs6wwfqpQ=
github.com/bytedance/sonic v1.13.2/go.mod h1:o68xyaF9u2gvVBuGHPlUVCy+ZfmNNO5ETf1+KgkJhz4=
github.com/bytedance/sonic/loader v0.1.1/go.mod h1:ncP89zfokxS5LZrJxl5z0UJcsk4M4yY2JpfqGeCtNLU=
github.com/bytedance/sonic/loader v0.2.4 h1:ZWCw4stuXUsn1/+zQDqeE7JKP+QO47tz7QCNan80NzY=
github.com/bytedance/sonic/loader v0.2.4/go.mod h1:N8A3vUdtUebEY2/VQC0MyhYeKUFosQU6FxH2JmUe6VI=
github.com/cloudwego/base64x v0.1.5 h1:XPciSp1xaq2VCSt6lF0phncD4koWyULpl5bUxbfCyP4=
github.com/cloudwego/base64x v0.1.5/go.mod h1:0zlkT4Wn5C6NdauXdJRhSKRlJvmclQ1hhJgA0rcu/8w=
github.com/cloudwego/iasm v0.2.0 h1:1KNIy1I1H9hNNFEEH3DVnI4UujN+1zjpuk6gwHLTssg=
github.com/cloudwego/iasm v0.2.0/go.mod h1:8rXZaNYT2n95jn+zTI1sDr+IgcD2GVs0nlbbQPiEFhY=
github.com/cpuguy83/go-md2man/v2 v2.0.6 h1:XJtiaUW6dEEqVuZiMTn1ldk455QWwEIsMIJlo5vtkx0=
github.com/cpuguy83/go-md2man/v2 v2.0.6/go.mod h1:oOW0eioCTA6cOiMLiUPZOpcVxMig6NIQQ7OS05n1F4g=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/gabriel-vasile/mimetype v1.4.8 h1:FfZ3gj38NjllZIeJAmMhr+qKL8Wu+nOoI3GqacKw1NM=
github.com/gabriel-vasile/mimetype v1.4.8/go.mod h1:ByKUIKGjh1ODkGM1asKUbQZOLGrPjydw3hYPU2YU9t8=
github.com/gin-contrib/cors v1.7.5 h1:cXC9SmofOrRg0w9PigwGlHG3ztswH6bqq4vJVXnvYMk=
github.com/gin-contrib/cors v1.7.5/go.mod h1:4q3yi7xBEDDWKapjT2o1V7mScKDDr8k+jZ0fSquGoy0=
github.com/gin-contrib/sse v1.1.0 h1:n0w2GMuUpWDVp7qSpvze6fAu9iRxJY4Hmj6AmBOU05w=
github.com/gin-contrib/sse v1.1.0/go.mod h1:hxRZ5gVpWMT7Z0B0gSNYqqsSCNIJMjzvm6fqCz9vjwM=
github.com/gin-gonic/gin v1.10.0 h1:nTuyha1TYqgedzytsKYqna+DfLos46nTv2ygFy86HFU=
github.com/gin-gonic/gin v1.10.0/go.mod h1:4PMNQiOhvDRa013RKVbsiNwoyezlm2rm0uX/T7kzp5Y=
github.com/go-openapi/analysis v0.23.0 h1:aGday7OWupfMs+LbmLZG4k0MYXIANxcuBTYUC03zFCU=
github.com/go-openapi/analysis v0.23.0/go.mod h1:9mz9ZWaSlV8TvjQHLl2mUW2PbZtemkE8yA5v22ohupo=
github.com/go-openapi/errors v0.22.0 h1:c4xY/OLxUBSTiepAg3j/MHuAv5mJhnf53LLMWFB+u/w=
github.com/go-openapi/errors v0.22.0/go.mod h1:J3DmZScxCDufmIMsdOuDHxJbdOGC0xtUynjIx092vXE=
github.com/go-openapi/jsonpointer v0.21.1 h1:whnzv/pNXtK2FbX/W9yJfRmE2gsmkfahjMKB0fZvcic=
github.com/go-openapi/jsonpointer v0.21.1/go.mod h1:50I1STOfbY1ycR8jGz8DaMeLCdXiI6aDteEdRNNzpdk=
github.com/go-openapi/jsonreference v0.21.0 h1:Rs+Y7hSXT83Jacb7kFyjn4ijOuVGSvOdF2+tg1TRrwQ=
github.com/go-openapi/jsonreference v0.21.0/go.mod h1:LmZmgsrTkVg9LG4EaHeY8cBDslNPMo06cago5JNLkm4=
github.com/go-openapi/loads v0.22.0 h1:ECPGd4jX1U6NApCGG1We+uEozOAvXvJSF4nnwHZ8Aco=
github.com/go-openapi/loads v0.22.0/go.mod h1:yLsaTCS92mnSAZX5WWoxszLj0u+Ojl+Zs5Stn1oF+rs=
github.com/go-openapi/runtime v0.28.0 h1:gpPPmWSNGo214l6n8hzdXYhPuJcGtziTOgUpvsFWGIQ=
github.com/go-openapi/runtime v0.28.0/go.mod h1:QN7OzcS+XuYmkQLw05akXk0jRH/eZ3kb18+1KwW9gyc=
github.com/go-openapi/spec v0.21.0 h1:LTVzPc3p/RzRnkQqLRndbAzjY0d0BCL72A6j3CdL9ZY=
github.com/go-openapi/spec v0.21.0/go.mod h1:78u6VdPw81XU44qEWGhtr982gJ5BWg2c0I5XwVMotYk=
github.com/go-openapi/strfmt v0.23.0 h1:nlUS6BCqcnAk0pyhi9Y+kdDVZdZMHfEKQiS4HaMgO/c=
github.com/go-openapi/strfmt v0.23.0/go.mod h1:NrtIpfKtWIygRkKVsxh7XQMDQW5HKQl6S5ik2elW+K4=
github.com/go-openapi/swag v0.23.1 h1:lpsStH0n2ittzTnbaSloVZLuB5+fvSY/+hnagBjSNZU=
github.com/go-openapi/swag v0.23.1/go.mod h1:STZs8TbRvEQQKUA+JZNAm3EWlgaOBGpyFDqQnDHMef0=
github.com/go-openapi/validate v0.24.0 h1:LdfDKwNbpB6Vn40xhTdNZAnfLECL81w+VX3BumrGD58=
github.com/go-openapi/validate v0.24.0/go.mod h1:iyeX1sEufmv3nPbBdX3ieNviWnOZaJ1+zquzJEf2BAQ=
github.com/go-playground/locales v0.14.1 h1:EWaQ/wswjilfKLTECiXz7Rh+3BjFhfDFKv/oXslEjJA=
github.com/go-playground/locales v0.14.1/go.mod h1:hxrqLVvrK65+Rwrd5Fc6F2O76J/NuW9t0sjnWqG1slY=
github.com/go-playground/universal-translator v0.18.1 h1:Bcnm0ZwsGyWbCzImXv+pAJnYK9S473LQFuzCbDbfSFY=
github.com/go-playground/universal-translator v0.18.1/go.mod h1:xekY+UJKNuX9WP91TpwSH2VMlDf28Uj24BCp08ZFTUY=
github.com/go-playground/validator/v10 v10.26.0 h1:SP05Nqhjcvz81uJaRfEV0YBSSSGMc/iMaVtFbr3Sw2k=
github.com/go-playground/validator/v10 v10.26.0/go.mod h1:I5QpIEbmr8On7W0TktmJAumgzX4CA1XNl4ZmDuVHKKo=
github.com/goccy/go-json v0.10.5 h1:Fq85nIqj+gXn/S5ahsiTlK3TmC85qgirsdTP/+DeaC4=
github.com/goccy/go-json v0.10.5/go.mod h1:oq7eo15ShAhp70Anwd5lgX2pLfOS3QCiwU/PULtXL6M=
github.com/golang-jwt/jwt/v5 v5.2.2 h1:Rl4B7itRWVtYIHFrSNd7vhTiz9UpLdi6gZhZ3wEeDy8=
github.com/golang-jwt/jwt/v5 v5.2.2/go.mod h1:pqrtFR0X4osieyHYxtmOUWsAWrfe1Q5UVIyoH402zdk=
github.com/google/go-cmp v0.5.9/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
github.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/gorilla/websocket v1.5.3 h1:saDtZ6Pbx/0u+bgYQ3q96pZgCzfhKXGPqt7kZ72aNNg=
github.com/gorilla/websocket v1.5.3/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=
github.com/jackc/pgpassfile v1.0.0 h1:/6Hmqy13Ss2zCq62VdNG8tM1wchn8zjSGOBJ6icpsIM=
github.com/jackc/pgpassfile v1.0.0/go.mod h1:CEx0iS5ambNFdcRtxPj5JhEz+xB6uRky5eyVu/W2HEg=
github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 h1:iCEnooe7UlwOQYpKFhBabPMi4aNAfoODPEFNiAnClxo=
github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761/go.mod h1:5TJZWKEWniPve33vlWYSoGYefn3gLQRzjfDlhSJ9ZKM=
github.com/jackc/pgx/v5 v5.7.4 h1:9wKznZrhWa2QiHL+NjTSPP6yjl3451BX3imWDnokYlg=
github.com/jackc/pgx/v5 v5.7.4/go.mod h1:ncY89UGWxg82EykZUwSpUKEfccBGGYq1xjrOpsbsfGQ=
github.com/jackc/puddle/v2 v2.2.2 h1:PR8nw+E/1w0GLuRFSmiioY6UooMp6KJv0/61nB7icHo=
github.com/jackc/puddle/v2 v2.2.2/go.mod h1:vriiEXHvEE654aYKXXjOvZM39qJ0q+azkZFrfEOc3H4=
github.com/jinzhu/inflection v1.0.0 h1:K317FqzuhWc8YvSVlFMCCUb36O/S9MCKRDI7QkRKD/E=
github.com/jinzhu/inflection v1.0.0/go.mod h1:h+uFLlag+Qp1Va5pdKtLDYj+kHp5pxUVkryuEj+Srlc=
github.com/jinzhu/now v1.1.5 h1:/o9tlHleP7gOFmsnYNz3RGnqzefHA47wQpKrrdTIwXQ=
github.com/jinzhu/now v1.1.5/go.mod h1:d3SSVoowX0Lcu0IBviAWJpolVfI5UJVZZ7cO71lE/z8=
github.com/joho/godotenv v1.5.1 h1:7eLL/+HRGLY0ldzfGMeQkb7vMd0as4CfYvUVzLqw0N0=
github.com/joho/godotenv v1.5.1/go.mod h1:f4LDr5Voq0i2e/R5DDNOoa2zzDfwtkZa6DnEwAbqwq4=
github.com/josharian/intern v1.0.0 h1:vlS4z54oSdjm0bgjRigI+G1HpF+tI+9rE5LLzOg8HmY=
github.com/josharian/intern v1.0.0/go.mod h1:5DoeVV0s6jJacbCEi61lwdGj/aVlrQvzHFFd8Hwg//Y=
github.com/json-iterator/go v1.1.12 h1:PV8peI4a0ysnczrg+LtxykD8LfKY9ML6u2jnxaEnrnM=
github.com/json-iterator/go v1.1.12/go.mod h1:e30LSqwooZae/UwlEbR2852Gd8hjQvJoHmT4TnhNGBo=
github.com/klauspost/cpuid/v2 v2.0.9/go.mod h1:FInQzS24/EEf25PyTYn52gqo7WaD8xa0213Md/qVLRg=
github.com/klauspost/cpuid/v2 v2.2.10 h1:tBs3QSyvjDyFTq3uoc/9xFpCuOsJQFNPiAhYdw2skhE=
github.com/klauspost/cpuid/v2 v2.2.10/go.mod h1:hqwkgyIinND0mEev00jJYCxPNVRVXFQeu1XKlok6oO0=
github.com/knz/go-libedit v1.10.1/go.mod h1:MZTVkCWyz0oBc7JOWP3wNAzd002ZbM/5hgShxwh4x8M=
github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
github.com/leodido/go-urn v1.4.0 h1:WT9HwE9SGECu3lg4d/dIA+jxlljEa1/ffXKmRjqdmIQ=
github.com/leodido/go-urn v1.4.0/go.mod h1:bvxc+MVxLKB4z00jd1z+Dvzr47oO32F/QSNjSBOlFxI=
github.com/mailru/easyjson v0.9.0 h1:PrnmzHw7262yW8sTBwxi1PdJA3Iw/EKBa8psRf7d9a4=
github.com/mailru/easyjson v0.9.0/go.mod h1:1+xMtQp2MRNVL/V1bOzuP3aP8VNwRW55fQUto+XFtTU=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/mitchellh/mapstructure v1.5.0 h1:jeMsZIYE/09sWLaz43PL7Gy6RuMjD2eJVyuac5Z2hdY=
github.com/mitchellh/mapstructure v1.5.0/go.mod h1:bFUtVrKA4DC2yAKiSyO/QUcy7e+RRV2QTWOzhPopBRo=
github.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd h1:TRLaZ9cD/w8PVh93nsPXa1VrQ6jlwL5oN8l14QlcNfg=
github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
github.com/modern-go/reflect2 v1.0.2 h1:xBagoLtFs94CBntxluKeaWgTMpvLxC4ur3nMaC9Gz0M=
github.com/modern-go/reflect2 v1.0.2/go.mod h1:yWuevngMOJpCy52FWWMvUC8ws7m/LJsjYzDa0/r8luk=
github.com/oklog/ulid v1.3.1 h1:EGfNDEx6MqHz8B3uNV6QAib1UR2Lm97sHi3ocA6ESJ4=
github.com/oklog/ulid v1.3.1/go.mod h1:CirwcVhetQ6Lv90oh/F+FBtV6XMibvdAFo93nm5qn4U=
github.com/pelletier/go-toml/v2 v2.2.4 h1:mye9XuhQ6gvn5h28+VilKrrPoQVanw5PMw/TB0t5Ec4=
github.com/pelletier/go-toml/v2 v2.2.4/go.mod h1:2gIqNv+qfxSVS7cM2xJQKtLSTLUE9V8t9Stt+h56mCY=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/russross/blackfriday/v2 v2.1.0 h1:JIOH55/0cWyOuilr9/qlrm0BSXldqnqwMsf35Ld67mk=
github.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=
github.com/shurcooL/sanitized_anchor_name v1.0.0 h1:PdmoCO6wvbs+7yrJyMORt4/BmY5IYyJwS/kOiWx8mHo=
github.com/shurcooL/sanitized_anchor_name v1.0.0/go.mod h1:1NzhyTcUVG4SuEtjjoZeVRXNmyL/1OwPU0+IJeTBvfc=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=
github.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=
github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=
github.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
github.com/swaggo/files v1.0.1 h1:J1bVJ4XHZNq0I46UU90611i9/YzdrF7x92oX1ig5IdE=
github.com/swaggo/files v1.0.1/go.mod h1:0qXmMNH6sXNf+73t65aKeB+ApmgxdnkQzVTAj2uaMUg=
github.com/swaggo/gin-swagger v1.6.0 h1:y8sxvQ3E20/RCyrXeFfg60r6H0Z+SwpTjMYsMm+zy8M=
github.com/swaggo/gin-swagger v1.6.0/go.mod h1:BG00cCEy294xtVpyIAHG6+e2Qzj/xKlRdOqDkvq0uzo=
github.com/swaggo/swag v1.16.4 h1:clWJtd9LStiG3VeijiCfOVODP6VpHtKdQy9ELFG3s1A=
github.com/swaggo/swag v1.16.4/go.mod h1:VBsHJRsDvfYvqoiMKnsdwhNV9LEMHgEDZcyVYX0sxPg=
github.com/twitchyliquid64/golang-asm v0.15.1 h1:SU5vSMR7hnwNxj24w34ZyCi/FmDZTkS4MhqMhdFk5YI=
github.com/twitchyliquid64/golang-asm v0.15.1/go.mod h1:a1lVb/DtPvCB8fslRZhAngC2+aY1QWCk3Cedj/Gdt08=
github.com/ugorji/go/codec v1.2.12 h1:9LC83zGrHhuUA9l16C9AHXAqEV/2wBQ4nkvumAE65EE=
github.com/ugorji/go/codec v1.2.12/go.mod h1:UNopzCgEMSXjBc6AOMqYvWC1ktqTAfzJZUZgYf6w6lg=
github.com/urfave/cli/v2 v2.27.6 h1:VdRdS98FNhKZ8/Az8B7MTyGQmpIr36O1EHybx/LaZ4g=
github.com/urfave/cli/v2 v2.27.6/go.mod h1:3Sevf16NykTbInEnD0yKkjDAeZDS0A6bzhBH5hrMvTQ=
github.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1 h1:gEOO8jv9F4OT7lGCjxCBTO/36wtF6j2nSip77qHd4x4=
github.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1/go.mod h1:Ohn+xnUBiLI6FVj/9LpzZWtj1/D6lUovWYBkxHVV3aM=
github.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=
go.mongodb.org/mongo-driver v1.14.0 h1:P98w8egYRjYe3XDjxhYJagTokP/H6HzlsnojRgZRd80=
go.mongodb.org/mongo-driver v1.14.0/go.mod h1:Vzb0Mk/pa7e6cWw85R4F/endUC3u0U9jGcNU603k65c=
golang.org/x/arch v0.16.0 h1:foMtLTdyOmIniqWCHjY6+JxuC54XP1fDwx4N0ASyW+U=
golang.org/x/arch v0.16.0/go.mod h1:JmwW7aLIoRUKgaTzhkiEFxvcEiQGyOg9BMonBJUS7EE=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=
golang.org/x/crypto v0.37.0 h1:kJNSjF/Xp7kU0iB2Z+9viTPMW4EqqsrywMXLJOOsXSE=
golang.org/x/crypto v0.37.0/go.mod h1:vg+k43peMZ0pUMhYmVAWysMK35e6ioLh3wB8ZCAfbVc=
golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=
golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
golang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=
golang.org/x/net v0.7.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=
golang.org/x/net v0.39.0 h1:ZCu7HMWDxpXpaiKdhzIfaltL9Lp31x/3fCP11bc6/fY=
golang.org/x/net v0.39.0/go.mod h1:X7NRbYVEA+ewNkCNyJ513WmMdQ3BineSwVtN2zD/d+E=
golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.13.0 h1:AauUjRAJ9OSnvULf/ARrrVywoJDy0YS2AwQ98I37610=
golang.org/x/sync v0.13.0/go.mod h1:1dzgHSNfp02xaA81J2MS99Qcpr2w7fw1gpm99rleRqA=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.32.0 h1:s77OFDvIQeibCmezSnk/q6iAfkdiQaJi4VzroCFrN20=
golang.org/x/sys v0.32.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=
golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=
golang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=
golang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=
golang.org/x/text v0.24.0 h1:dd5Bzh4yt5KYA8f9CJHCP4FB4D51c2c6JvN37xJJkJ0=
golang.org/x/text v0.24.0/go.mod h1:L8rBsPeo2pSS+xqN0d5u2ikmjtmoJbDBT1b7nHvFCdU=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=
golang.org/x/tools v0.32.0 h1:Q7N1vhpkQv7ybVzLFtTjvQya2ewbwNDZzUgfXGqtMWU=
golang.org/x/tools v0.32.0/go.mod h1:ZxrU41P/wAbZD8EDa6dDCa6XfpkhJ7HFMjHJXfBDu8s=
golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
google.golang.org/protobuf v1.36.6 h1:z1NpPI8ku2WgiWnf+t9wTPsn6eP1L7ksHUlkfLvd9xY=
google.golang.org/protobuf v1.36.6/go.mod h1:jduwjTPXsFjZGTmRluh+L6NjiWu7pchiJ2/5YcXBHnY=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=
gopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gorm.io/driver/postgres v1.5.11 h1:ubBVAfbKEUld/twyKZ0IYn9rSQh448EdelLYk9Mv314=
gorm.io/driver/postgres v1.5.11/go.mod h1:DX3GReXH+3FPWGrrgffdvCk3DQ1dwDPdmbenSkweRGI=
gorm.io/gorm v1.25.12 h1:I0u8i2hWQItBq1WfE0o2+WuL9+8L21K9e2HHSTE/0f8=
gorm.io/gorm v1.25.12/go.mod h1:xh7N7RHfYlNc5EmcI/El95gXusucDrQnHXe0+CgWcLQ=
nullprogram.com/x/optparse v1.0.0/go.mod h1:KdyPE+Igbe0jQUrVfMqDMeJQIJZEuyV7pjYmp6pbG50=
rsc.io/pdf v0.1.1/go.mod h1:n8OzWcQ6Sp37PL01nO98y4iUCRdTGarVfzxY20ICaU4=
sigs.k8s.io/yaml v1.4.0 h1:Mk1wCc2gy/F0THH0TAp1QYyJNzRm2KCLy3o5ASXVI5E=
sigs.k8s.io/yaml v1.4.0/go.mod h1:Ejl7/uTz7PSA4eKMyQCUTnhZYNmLIl+5c2lQPGR2BPY=


================================================================================

Filename: internal/database/database.go
Content:
package database

import (
	"fmt"
	"log"
	"os"
	"time"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"

	"geoguessr-backend/internal/models"

)

var DB *gorm.DB

func Connect() error {

	dbHost := os.Getenv("DB_HOST")
	if dbHost == "" {
		dbHost = "localhost"
	}
	dbPort := os.Getenv("DB_PORT")
	if dbPort == "" {
		dbPort = "5432"
	}
	dbUser := os.Getenv("DB_USER")
	if dbUser == "" {
		dbUser = "postgres"
	}
	dbPassword := os.Getenv("DB_PASSWORD")
	if dbPassword == "" {
		log.Println("WARNING: DB_PASSWORD environment variable not set.")

		dbPassword = "mysecretpassword"
	}
	dbName := os.Getenv("DB_NAME")
	if dbName == "" {
		dbName = "geoguessr"
	}
	dbSSLMode := os.Getenv("DB_SSLMODE")
	if dbSSLMode == "" {
		dbSSLMode = "disable"
	}

	dsn := fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%s sslmode=%s TimeZone=UTC",
		dbHost, dbUser, dbPassword, dbName, dbPort, dbSSLMode)

	
	logLevel := logger.Warn // <<< Change from logger.Info to logger.Warn
	if os.Getenv("GORM_LOG_LEVEL") == "info" {
		logLevel = logger.Info // Allow overriding via env var if needed
	}

	newLogger := logger.New(
		log.New(os.Stdout, "\r\n", log.LstdFlags), // io writer
		logger.Config{
			SlowThreshold:             time.Second * 2, // Slow SQL threshold (optional)
			LogLevel:                  logLevel,         // Set the desired log level
			IgnoreRecordNotFoundError: true,            // Don't log ErrRecordNotFound errors (usually expected)
			ParameterizedQueries:      false,           // Don't include params in Info level logs (optional)
			Colorful:                  true,            // Enable color (optional)
		},
	)
	// ---------------------------

	var err error
	DB, err = gorm.Open(postgres.Open(dsn), &gorm.Config{
		Logger: newLogger, // <<< Use the configured logger
	})

	if err != nil {
		return fmt.Errorf("failed to connect to database: %w", err)
	}

	log.Println("Database connection established successfully.")
	log.Println("Running auto migrations...")
	err = DB.AutoMigrate(
		&models.Location{},
		&models.User{},
		&models.Game{},
		&models.Round{},
	)
	if err != nil {
		return fmt.Errorf("failed to auto migrate database: %w", err)
	}
	log.Println("Auto migrations completed.")

	return nil
}

func GetDB() *gorm.DB {
	return DB
}

================================================================================

Filename: internal/handlers/auth_handler.go
Content:

package handlers

import (
	"log"
	"net/http"
	"strings" 

	"geoguessr-backend/internal/database" 
	"geoguessr-backend/internal/models"    
	"geoguessr-backend/internal/utils"     

	"github.com/gin-gonic/gin"
	"github.com/go-playground/validator/v10" 
	"golang.org/x/crypto/bcrypt"
	"gorm.io/gorm"
)


var validate = validator.New()

// Register godoc
// @Summary      Register a new user
// @Description  Creates a new user account with username, email, and password.
// @Tags         Auth
// @Accept       json
// @Produce      json
// @Param        userInput body models.RegisterInput true "User Registration Info"
// @Success      201  {object}  map[string]interface{}  "User registered successfully (returns basic user info)"
// @Failure      400  {object}  map[string]string "Invalid input format or validation failed"
// @Failure      409  {object}  map[string]string "Conflict: Username or Email already exists"
// @Failure      500  {object}  map[string]string "Internal server error (hashing, DB create)"
// @Router       /auth/register [post]
func Register(c *gin.Context) {
	var input models.RegisterInput

	
	if err := c.ShouldBindJSON(&input); err != nil {
		log.Printf("Register Error - Binding: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input format"})
		return
	}

	
	if err := validate.Struct(input); err != nil {
		log.Printf("Register Error - Validation: %v", err)
		
		c.JSON(http.StatusBadRequest, gin.H{"error": "Validation failed: " + err.Error()})
		return
	}

	db := database.GetDB()

	
	var existingUser models.User
	err := db.Where("email = ? OR username = ?", input.Email, input.Username).First(&existingUser).Error
	if err == nil {
		
		errorMsg := "Conflict: "
		if strings.EqualFold(existingUser.Email, input.Email) { 
			errorMsg += "Email already exists."
		} else {
			errorMsg += "Username already exists."
		}
		log.Printf("Register Error - Conflict: %s", errorMsg)
		c.JSON(http.StatusConflict, gin.H{"error": errorMsg})
		return
	} else if err != gorm.ErrRecordNotFound {
		
		log.Printf("Register Error - DB Check: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Database error checking user existence"})
		return
	}
	

	
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		log.Printf("Register Error - Hashing: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to process password"})
		return
	}

	
	newUser := models.User{
		Username:     input.Username,
		Email:        input.Email,
		PasswordHash: string(hashedPassword),
	}

	
	result := db.Create(&newUser)
	if result.Error != nil {
		log.Printf("Register Error - DB Create: %v", result.Error)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to register user"})
		return
	}

	log.Printf("User registered successfully: %s (%s)", newUser.Username, newUser.Email)
	
	c.JSON(http.StatusCreated, gin.H{
		"message": "User registered successfully",
		"user": gin.H{
			"id":       newUser.ID,
			"username": newUser.Username,
			"email":    newUser.Email,
		},
	})
}

// Login godoc
// @Summary      Log in a user
// @Description  Authenticates a user with email and password, returns a JWT token upon success.
// @Tags         Auth
// @Accept       json
// @Produce      json
// @Param        credentials body models.LoginInput true "User Login Credentials"
// @Success      200  {object}  map[string]interface{} "Login successful (returns JWT token and basic user info)"
// @Failure      400  {object}  map[string]string "Invalid input format or validation failed"
// @Failure      401  {object}  map[string]string "Invalid credentials (user not found or password mismatch)"
// @Failure      500  {object}  map[string]string "Internal server error (DB find, token generation)"
// @Router       /auth/login [post]
func Login(c *gin.Context) {
	var input models.LoginInput

	
	if err := c.ShouldBindJSON(&input); err != nil {
		log.Printf("Login Error - Binding: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input format"})
		return
	}

	
	if err := validate.Struct(input); err != nil {
		log.Printf("Login Error - Validation: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Validation failed: " + err.Error()})
		return
	}

	db := database.GetDB()
	var user models.User

	
	
	
	result := db.Where("email = ?", input.Email).First(&user) 
	if result.Error != nil {
		if result.Error == gorm.ErrRecordNotFound {
			log.Printf("Login Error - User not found: %s", input.Email)
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"}) 
		} else {
			log.Printf("Login Error - DB Find: %v", result.Error)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Database error finding user"})
		}
		return
	}

	
	err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(input.Password))
	if err != nil {
		
		log.Printf("Login Error - Password mismatch for user: %s", input.Email)
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"}) 
		return
	}

	
	token, err := utils.GenerateToken(user.ID)
	if err != nil {
		log.Printf("Login Error - Token Generation: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to generate login token"})
		return
	}

	log.Printf("User logged in successfully: %s (%d)", user.Username, user.ID)
	
	c.JSON(http.StatusOK, gin.H{
		"message": "Login successful",
		"token":   token,
		"user": gin.H{ 
			"id":       user.ID,
			"username": user.Username,
			"email":    user.Email,
		},
	})
}

================================================================================

Filename: internal/handlers/game_handler.go
Content:
package handlers

import (
	"log"
	"net/http"
	"strconv"
	"time"

	"geoguessr-backend/internal/database"
	"geoguessr-backend/internal/models"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
)

const defaultRounds = 5

type GameLocationResponse struct {
	ID        uint    `json:"id"`
	Latitude  float64 `json:"lat"`
	Longitude float64 `json:"lng"`
}

// StartGame godoc
// @Summary      Start a new game
// @Description  Fetches a specified number of random locations for a new game session.
// @Tags         Game
// @Produce      json
// @Param        rounds query int false "Number of rounds (default: 5)" mininum(1) maximum(10)
// @Success      200 {object} map[string]interface{} "Game started successfully (returns gameId placeholder and locations)"
// @Failure      500 {object} map[string]string "Internal server error (failed to fetch locations)"
// @Router       /game/start [get]
func StartGame(c *gin.Context) {
	log.Println("Handler: StartGame invoked")

	roundsStr := c.DefaultQuery("rounds", strconv.Itoa(defaultRounds))
	rounds, err := strconv.Atoi(roundsStr)
	if err != nil || rounds <= 0 {
		rounds = defaultRounds
	}
	log.Printf("Handler: Requesting %d rounds", rounds)

	db := database.GetDB()

	var locations []models.Location
	var responseLocations []GameLocationResponse

	result := db.Model(&models.Location{}).
		Order("RANDOM()").
		Limit(rounds).
		Find(&locations)

	if result.Error != nil {
		log.Printf("Error fetching locations: %v", result.Error)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch game locations"})
		return
	}

	if len(locations) < rounds {

		log.Printf("Warning: Found only %d locations, requested %d", len(locations), rounds)

		if len(locations) == 0 {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "No locations found in database"})
			return
		}
	}

	for _, loc := range locations {
		responseLocations = append(responseLocations, GameLocationResponse{
			ID:        loc.ID,
			Latitude:  loc.Latitude,
			Longitude: loc.Longitude,
		})
	}

	log.Printf("Handler: Successfully fetched %d locations", len(responseLocations))
	c.JSON(http.StatusOK, gin.H{
		"gameId":    "mock_backend_game_" + strconv.Itoa(int(time.Now().Unix())),
		"locations": responseLocations,
	})
}

// FinishGame saves the results of a completed game
// @Summary      Submit game results
// @Description  Saves the total score and round details for a completed game session for the authenticated user.
// @Tags         Game
// @Accept       json
// @Produce      json
// @Param        gameResult body models.SubmitGameInput true "Completed Game Data"
// @Success      201  {object}  map[string]interface{} "Game results saved successfully"
// @Failure      400  {object}  map[string]string "Invalid input format or validation failed"
// @Failure      401  {object}  map[string]string "Unauthorized (invalid/missing token)"
// @Failure      500  {object}  map[string]string "Internal server error (database error)"
// @Security     BearerAuth
// @Router       /game/finish [post]
func FinishGame(c *gin.Context) {
	var input models.SubmitGameInput
	var newGame models.Game // <<< Declare newGame OUTSIDE the transaction scope

	// 1. Get User ID from context
	userIDAny, exists := c.Get("userID")
	if !exists {
		log.Println("FinishGame Error: userID not found in context")
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User authentication not found"})
		return
	}
	userID, ok := userIDAny.(uint)
	if !ok {
		log.Println("FinishGame Error: userID in context is not uint")
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Internal server error processing user identity"})
		return
	}
	log.Printf("FinishGame Handler: Processing submission for user ID: %d", userID)

	// 2. Bind JSON input
	if err := c.ShouldBindJSON(&input); err != nil {
		log.Printf("FinishGame Error - Binding: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input format: " + err.Error()})
		return
	}

	// 3. Validate input struct
	if err := validate.Struct(input); err != nil {
		log.Printf("FinishGame Error - Validation: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Validation failed: " + err.Error()})
		return
	}

	db := database.GetDB()

	// --- Save Game and Rounds within a Transaction ---
	err := db.Transaction(func(tx *gorm.DB) error {
		// 4. Create the main Game record
		// Assign to the newGame declared outside
		newGame = models.Game{
			UserID:       userID,
			TotalScore:   input.TotalScore,
			RoundsPlayed: input.RoundsPlayed,
		}
		if err := tx.Create(&newGame).Error; err != nil {
			log.Printf("FinishGame Error - DB Create Game: %v", err)
			return err
		}
		log.Printf("FinishGame - Created Game record ID: %d", newGame.ID)

		// 5. Create Round records linked to the Game
		for _, roundInput := range input.Rounds {
			newRound := models.Round{
				GameID:      newGame.ID, // Use ID from the created game
				LocationID:  roundInput.LocationID,
				RoundNumber: roundInput.RoundNumber,
				GuessLat:    roundInput.GuessLat,
				GuessLng:    roundInput.GuessLng,
				ActualLat:   roundInput.ActualLat,
				ActualLng:   roundInput.ActualLng,
				DistanceKm:  roundInput.DistanceKm,
				Score:       roundInput.Score,
			}
			if err := tx.Create(&newRound).Error; err != nil {
				log.Printf("FinishGame Error - DB Create Round %d: %v", roundInput.RoundNumber, err)
				return err
			}
		}
		log.Printf("FinishGame - Successfully created %d Round records for Game ID: %d", len(input.Rounds), newGame.ID)
		return nil
	})
	// --- End Transaction ---

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to save game results due to database error"})
		return
	}

	// 6. Return Success Response (newGame is now accessible here)
	log.Printf("FinishGame - Successfully saved results for User ID: %d", userID)
	c.JSON(http.StatusCreated, gin.H{
		"message": "Game results saved successfully",
		"gameId":  newGame.ID,
	})
}


================================================================================

Filename: internal/middleware/auth.go
Content:
// internal/middleware/auth.go
package middleware

import (
	"log"
	"net/http"

	"geoguessr-backend/internal/utils" // Adjust path

	"github.com/gin-gonic/gin"
)

// AuthRequired is a middleware function to protect routes
func AuthRequired() gin.HandlerFunc {
	return func(c *gin.Context) {
		tokenString := utils.ExtractToken(c) // Get token from "Bearer <token>" header
		if tokenString == "" {
			log.Println("Auth Middleware: No token provided")
			c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "Authorization token required"})
			return
		}

		token, err := utils.ValidateToken(tokenString) // Validate signature, expiry, etc.
		if err != nil {
			log.Printf("Auth Middleware: Invalid token: %v", err)
			c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "Invalid or expired token"})
			return
		}

		// Token is valid, extract user ID
		userID, err := utils.ExtractUserIDFromToken(token)
		if err != nil {
			log.Printf("Auth Middleware: Failed to extract userID from valid token: %v", err)
			c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "Invalid token claims"})
			return
		}

		// Set user ID in the context for subsequent handlers to use
		c.Set("userID", userID)
		log.Printf("Auth Middleware: User %d authenticated", userID)

		// Proceed to the next handler
		c.Next()
	}
}


================================================================================

Filename: internal/models/game.go
Content:
// internal/models/game.go
package models

import (
	"time"

)

// Game represents a completed game session by a user
type Game struct {
	ID           uint      `gorm:"primaryKey"`
	UserID       uint      `gorm:"not null;index"` // Foreign key to User table
	User         User      // GORM association (belongs to User) - optional but useful for preloading
	TotalScore   int       `gorm:"not null"`
	RoundsPlayed int       `gorm:"not null"` // Typically 5, but could be variable
	CreatedAt    time.Time // When the game was completed/saved
	UpdatedAt    time.Time

	Rounds []Round `gorm:"foreignKey:GameID"` // GORM association (has many Rounds)
}
// RoundResultInput represents the data for a single round sent from frontend
type RoundResultInput struct {
	RoundNumber int     `json:"roundNumber" validate:"required,min=1"`
	LocationID  uint    `json:"locationId" validate:"required,min=1"`
	GuessLat    float64 `json:"guessLat" validate:"required"`
	GuessLng    float64 `json:"guessLng" validate:"required"`
	ActualLat   float64 `json:"actualLat" validate:"required"` // Send actual coords for verification/record
	ActualLng   float64 `json:"actualLng" validate:"required"`
	DistanceKm  float64 `json:"distanceKm" validate:"min=0"`
	Score       int     `json:"score" validate:"required,min=0"`
}

// SubmitGameInput represents the complete game data sent from frontend
type SubmitGameInput struct {
	// GameID      string             `json:"gameId"` // We might generate ID on backend instead
	TotalScore   int                `json:"totalScore" validate:"required,min=0"`
	RoundsPlayed int                `json:"roundsPlayed" validate:"required,min=1"`
	Rounds       []RoundResultInput `json:"rounds" validate:"required,min=1,dive"` // 'dive' validates each element in slice
}

================================================================================

Filename: scripts/manual_locations.json
Content:
[
    {
        "latitude": 40.75798,
        "longitude": -73.9855,
        "description": "Times Square, NYC, USA",
        "source": "manual"
    },
    {
        "latitude": 34.0522,
        "longitude": -118.2437,
        "description": "Los Angeles, CA, USA",
        "source": "manual"
    },
    {
        "latitude": -22.9068,
        "longitude": -43.1729,
        "description": "Rio de Janeiro, Brazil",
        "source": "manual"
    }
]

================================================================================

Filename: scripts/populate_locations.go
Content:
// scripts/populate_locations.go
package main

import (
	"encoding/json"
	// "encoding/xml" // Keep commented unless using OSM
	"flag"
	"fmt"
	"io"
	"log"
	"math/rand" // For shuffling
	"net/http"
	"net/url"
	"os"
	"runtime" // For NumCPU
	"sync"
	"sync/atomic"
	"time"

	"github.com/joho/godotenv"
	"gorm.io/gorm"

	// Use internal packages
	"geoguessr-backend/internal/database"
	"geoguessr-backend/internal/models"
)

// --- Struct Definitions ---

// Region defines a geographical area (from regions.json)
type Region struct {
	Name        string  `json:"name"`
	MinLat      float64 `json:"minLat"`
	MaxLat      float64 `json:"maxLat"`
	MinLng      float64 `json:"minLng"`
	MaxLng      float64 `json:"maxLng"`
	Description string  `json:"description"`
	GridDensity float64 `json:"gridDensity"`
	HasOSMData  bool    `json:"hasOSMData"`
	Include     bool    `json:"include"` // New field to determine if the region should be included
}

// CandidateLocation represents a potential location to verify (from files or generation)
type CandidateLocation struct {
	Latitude    float64 `json:"latitude"`
	Longitude   float64 `json:"longitude"`
	Description string  `json:"description"`
	Source      string  `json:"source"` // e.g., "manual", "grid", "osm"
}

// StreetViewMetadataResponse represents the relevant parts of the Google API response
type StreetViewMetadataResponse struct {
	Status    string         `json:"status"`    // "OK", "ZERO_RESULTS", etc.
	Location  *LatLngLiteral `json:"location"`  // Pointer to handle potential null on non-OK status
	Copyright string         `json:"copyright"` // Can add if needed
	Date      string         `json:"date"`      // Can add if needed
	PanoID    string         `json:"pano_id"`   // Can add if needed
}

// LatLngLiteral represents a latitude-longitude pair from Google API
type LatLngLiteral struct {
	Lat float64 `json:"lat"`
	Lng float64 `json:"lng"`
}

// --- Helper Functions ---

// loadJSONFile reads and unmarshals a JSON file into the target interface
func loadJSONFile(filePath string, target interface{}) error {
	data, err := os.ReadFile(filePath)
	if err != nil {
		// Treat missing manual file as non-fatal, just return empty
		if os.IsNotExist(err) && filePath == "./scripts/manual_locations.json" {
			log.Printf("Info: %s not found, skipping manual locations.", filePath)
			return nil // Return nil to indicate okay, just no data
		}
		return fmt.Errorf("error reading %s: %w", filePath, err)
	}
	if err := json.Unmarshal(data, target); err != nil {
		return fmt.Errorf("error parsing %s: %w", filePath, err)
	}
	return nil
}

// generateGridCoordinates generates grid-based candidate locations for all regions
func generateGridCoordinates(regions []Region) []CandidateLocation {
	var candidates []CandidateLocation
	log.Println("Generating grid coordinates...")
	totalGenerated := 0
	for _, region := range regions {
		if !region.Include {
			log.Printf("Skipping region '%s' as it is marked to be excluded.", region.Name)
			continue
		}
		regionGenerated := 0
		latSteps := int((region.MaxLat - region.MinLat) / region.GridDensity)
		lngSteps := int((region.MaxLng - region.MinLng) / region.GridDensity)

		// Estimate points to prevent huge loops if density is tiny
		estimatedPoints := (latSteps + 1) * (lngSteps + 1)
		if estimatedPoints > 1000000 { // Safety cap per region
			log.Printf("Warning: Estimated points for region '%s' (%d) exceeds safety cap. Adjust density or bounds.", region.Name, estimatedPoints)
			continue
		}

		for i := 0; i <= latSteps; i++ {
			for j := 0; j <= lngSteps; j++ {
				lat := region.MinLat + float64(i)*region.GridDensity
				lng := region.MinLng + float64(j)*region.GridDensity
				// Ensure point is within precise bounds (floating point safety)
				if lat <= region.MaxLat && lng <= region.MaxLng {
					candidates = append(candidates, CandidateLocation{
						Latitude:    lat,
						Longitude:   lng,
						Description: fmt.Sprintf("Grid point in %s", region.Description),
						Source:      "grid",
					})
					regionGenerated++
				}
			}
		}
		totalGenerated += regionGenerated
	}
	log.Printf("Finished generating grid coordinates. Total raw grid points: %d", totalGenerated)
	return candidates
}

// limitGridLocations randomly samples a subset if the list is too large
func limitGridLocations(locations []CandidateLocation, maxCount int) []CandidateLocation {
	if maxCount <= 0 || len(locations) <= maxCount {
		return locations // No limiting needed or disabled
	}
	log.Printf("Limiting %d grid locations down to %d points using random sampling...", len(locations), maxCount)
	// rand.Seed is handled in main now
	rand.Shuffle(len(locations), func(i, j int) {
		locations[i], locations[j] = locations[j], locations[i]
	})
	return locations[:maxCount]
}

// locationExistsInDB checks if a similar location exists within tolerance
func locationExistsInDB(db *gorm.DB, lat, lng float64) (bool, uint) {
	const tolerance = 0.001 // ~110 meters latitude, varies longitude
	var location models.Location
	// Only select ID for efficiency when just checking existence
	err := db.Select("id").Where("latitude BETWEEN ? AND ?", lat-tolerance, lat+tolerance).
		Where("longitude BETWEEN ? AND ?", lng-tolerance, lng+tolerance).
		First(&location).Error

	if err == nil {
		return true, location.ID // Found existing
	}
	if err != gorm.ErrRecordNotFound {
		// Log actual DB errors, not just "not found"
		log.Printf("DB Check Error: %v for coords (%f, %f)", err, lat, lng)
	}
	return false, 0
}

// saveLocationToDB saves a validated location to the database using the internal model
func saveLocationToDB(db *gorm.DB, metadata *StreetViewMetadataResponse, description string) (uint, error) {
	location := models.Location{ // Use the model from internal/models
		Latitude:    metadata.Location.Lat, // Use validated coordinates from Google
		Longitude:   metadata.Location.Lng,
		Description: description, // Keep original or generate based on source
		// Country/Region could be added via reverse geocoding later
	}
	result := db.Create(&location) // Capture GORM result
	if result.Error != nil {
		return 0, result.Error
	}
	return location.ID, nil // Return the ID of the newly created record
}

// getStreetViewMetadata calls the Google Street View Metadata API
func getStreetViewMetadata(apiKey string, lat, lng float64) (*StreetViewMetadataResponse, error) {
	baseURL := "https://maps.googleapis.com/maps/api/streetview/metadata"
	params := url.Values{}
	params.Add("location", fmt.Sprintf("%.6f,%.6f", lat, lng)) // Use precision
	params.Add("key", apiKey)
	params.Add("source", "outdoor") // Filter for official Google coverage
	fullURL := baseURL + "?" + params.Encode()

	// Use default HTTP client (or configure one with timeout)
	resp, err := http.Get(fullURL)
	if err != nil {
		return nil, fmt.Errorf("http GET failed: %w", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed reading response body: %w", err)
	}

	// Try to unmarshal into the response struct regardless of HTTP status
	// This helps capture API-level errors like OVER_QUERY_LIMIT in the JSON body
	var metadata StreetViewMetadataResponse
	jsonErr := json.Unmarshal(body, &metadata)

	// Check HTTP status first
	if resp.StatusCode != http.StatusOK {
		errMsg := fmt.Sprintf("api http status: %s", resp.Status)
		// If JSON parsing worked and we have a status, include it
		if jsonErr == nil && metadata.Status != "" {
			errMsg += fmt.Sprintf(" (API Status: %s)", metadata.Status)
		} else {
			// Otherwise include raw body for debugging non-JSON errors
			errMsg += fmt.Sprintf(", body: %s", string(body))
		}
		return &metadata, fmt.Errorf(errMsg) // Return partial metadata if available + error
	}

	// HTTP OK, but check JSON parsing and internal status
	if jsonErr != nil {
		return nil, fmt.Errorf("failed unmarshalling OK response body: %w, body: %s", jsonErr, string(body))
	}
	if metadata.Status != "OK" {
		// API call succeeded at HTTP level, but Google couldn't find imagery/etc.
		return &metadata, fmt.Errorf("api status: %s", metadata.Status)
	}
	if metadata.Location == nil {
		// Should not happen if status is OK, but defensively check
		return &metadata, fmt.Errorf("api status OK but missing location data")
	}

	// If we reach here, all checks passed
	return &metadata, nil
}
func loadRegions() []Region {
	var regions []Region // Initialize empty slice
	filePath := "./scripts/regions.json"
	err := loadJSONFile(filePath, &regions) // <<< Use helper, pass pointer
	if err != nil {
		// Make region loading fatal as it's likely required
		log.Fatalf("FATAL: %v", err)
	}
	log.Printf("Loaded %d regions from %s", len(regions), filePath)
	return regions
}

// loadManualLocations loads manual locations using the helper
func loadManualLocations() []CandidateLocation {
	var locations []CandidateLocation // Initialize empty slice
	filePath := "./scripts/manual_locations.json"
	err := loadJSONFile(filePath, &locations) // <<< Use helper, pass pointer
	if err != nil {
		// Warn but don't make it fatal for optional manual locations
		log.Printf("Warning: Could not load/parse %s: %v", filePath, err)
		return []CandidateLocation{} // Return empty slice on error
	}
	// Handle case where file exists but is empty "[]" or if loadJSONFile returned nil error for non-existent file
	if locations == nil {
		locations = []CandidateLocation{}
	}
	log.Printf("Loaded %d manual locations from %s", len(locations), filePath)
	return locations
}

// --- Main Logic ---

func main() {
	// --- Flags ---
	batchSize := flag.Int("batch-size", 0, "Max number of candidate locations to process (0 for all)")
	maxGridPerRegion := flag.Int("max-grid", 20000, "Maximum number of grid points per region to generate (adjust based on density)") // Increased default
	workerCount := flag.Int("workers", runtime.NumCPU()*2, "Number of concurrent workers")
	apiDelayMs := flag.Int("delay", 25, "Base delay in milliseconds between API calls PER WORKER (increase if rate limited)")
	progressInterval := flag.Int("progress", 500, "Log progress every N processed locations")
	flag.Parse()

	log.Printf("Starting population script with BatchSize=%d, MaxGridPerRegion=%d, Workers=%d, APIDelay=%dms",
		*batchSize, *maxGridPerRegion, *workerCount, *apiDelayMs)

	// --- Env & DB Setup ---
	err := godotenv.Load() // Load .env file from current directory
	if err != nil {
		// Don't treat as fatal, might use system env vars
		log.Println("Info: .env file not found or failed to load. Will rely on system environment variables.")
	}
	apiKey := os.Getenv("GOOGLE_MAPS_API_KEY")
	if apiKey == "" {
		log.Fatal("FATAL: GOOGLE_MAPS_API_KEY environment variable not set.")
	}

	if err := database.Connect(); err != nil { // Connect uses GORM logger settings from database package
		log.Fatalf("FATAL: Error connecting to database: %v", err)
	}
	db := database.GetDB() // Use the getter from the database package
	log.Println("Database connection ready.")

	// --- Load Candidates ---
	regions := loadRegions() // Calls the refactored version
	manualLocations := loadManualLocations()
	log.Printf("Loaded %d regions and %d manual locations.", len(regions), len(manualLocations))

	gridLocations := generateGridCoordinates(regions)
	gridLocations = limitGridLocations(gridLocations, *maxGridPerRegion*len(regions)) // Limit total grid points globally

	allCandidates := append(manualLocations, gridLocations...)
	log.Printf("Total candidate locations generated: %d", len(allCandidates))

	// Shuffle and Slice candidates
	// rand.Seed(time.Now().UnixNano()) // Seed globally once
	rand.New(rand.NewSource(time.Now().UnixNano())) // Use non-deprecated way if needed, though Shuffle uses global
	rand.Shuffle(len(allCandidates), func(i, j int) {
		allCandidates[i], allCandidates[j] = allCandidates[j], allCandidates[i]
	})

	// Determine actual number to process based on batchSize flag
	numToProcess := len(allCandidates)
	if *batchSize > 0 && *batchSize < len(allCandidates) {
		numToProcess = *batchSize
		allCandidates = allCandidates[:numToProcess]
		log.Printf("Processing first %d shuffled candidates based on batch-size flag.", numToProcess)
	} else {
		log.Printf("Processing all %d shuffled candidates.", numToProcess)
	}
	if numToProcess == 0 {
		log.Println("No candidates to process. Exiting.")
		return
	}

	// --- Setup Concurrency & Stats ---
	var processed, validated, skipped, errors int32 // Atomic counters
	startTime := time.Now()
	apiCallDelay := time.Duration(*apiDelayMs) * time.Millisecond

	jobs := make(chan CandidateLocation, numToProcess) // Buffered channel for jobs
	resultsLog := make(chan string, *workerCount)      // Optional: channel for concise results logging
	var wg sync.WaitGroup

	// --- Start Workers ---
	log.Printf("Launching %d workers...", *workerCount)
	for i := 0; i < *workerCount; i++ {
		wg.Add(1)
		go func(workerID int) {
			defer wg.Done()
			// Small initial stagger for workers
			time.Sleep(time.Duration(rand.Intn(50*workerID+10)) * time.Millisecond)

			for candidate := range jobs {
				currentProcessed := atomic.AddInt32(&processed, 1) // Increment processed count first

				// 1. Check DB Existence
				exists, existingID := locationExistsInDB(db, candidate.Latitude, candidate.Longitude)
				if exists {
					atomic.AddInt32(&skipped, 1)
					resultsLog <- fmt.Sprintf("W%d SkipExist: %d", workerID, existingID) // Optional detailed log
					continue                                                             // Skip to next job
				}

				// 2. Call Google Metadata API (with delay)
				time.Sleep(apiCallDelay) // Apply delay before each API call for this worker
				metadata, err := getStreetViewMetadata(apiKey, candidate.Latitude, candidate.Longitude)

				// 3. Handle API Response/Error
				if err != nil {
					errMsg := err.Error()
					statusMsg := ""
					if metadata != nil { // Metadata might be non-nil even on error (e.g., status errors)
						statusMsg = metadata.Status
					}

					// Check if it's just ZERO_RESULTS (expected skip)
					if statusMsg == "ZERO_RESULTS" || errMsg == "api status: ZERO_RESULTS" {
						atomic.AddInt32(&skipped, 1)
						// resultsLog <- fmt.Sprintf("W%d SkipAPI(ZERO): %.4f,%.4f", workerID, candidate.Latitude, candidate.Longitude)
					} else {
						// Log other errors more visibly
						log.Printf("Worker %d API Error: %v (Status: %s) for Candidate: %.4f,%.4f (%s)",
							workerID, err, statusMsg, candidate.Latitude, candidate.Longitude, candidate.Source)
						atomic.AddInt32(&errors, 1)
					}
					continue // Skip to next job
				}

				// 4. Save Valid Location to DB (Status is guaranteed OK here)
				newID, dbErr := saveLocationToDB(db, metadata, candidate.Description)
				if dbErr != nil {
					log.Printf("Worker %d DB Error saving %.4f,%.4f: %v", workerID, metadata.Location.Lat, metadata.Location.Lng, dbErr)
					atomic.AddInt32(&errors, 1)
				} else {
					atomic.AddInt32(&validated, 1)
					resultsLog <- fmt.Sprintf("Saved %d: %.4f,%.4f (%s)", newID, metadata.Location.Lat, metadata.Location.Lng, candidate.Description) // Log success
				}

				// --- Log Progress Periodically (from worker 0) ---
				if workerID == 0 && int(currentProcessed)%(*progressInterval) == 0 {
					elapsed := time.Since(startTime).Round(time.Second)
					percent := float64(currentProcessed) / float64(numToProcess) * 100
					v := atomic.LoadInt32(&validated)
					s := atomic.LoadInt32(&skipped)
					e := atomic.LoadInt32(&errors)
					log.Printf("Progress: %d/%d (%.1f%%) | Valid: %d | Skip: %d | Err: %d | Elapsed: %v",
						currentProcessed, numToProcess, percent, v, s, e, elapsed)
				}
			}
		}(i)
	}

	// --- Feed Jobs ---
	log.Printf("Feeding %d jobs to workers...", numToProcess)
	for i := 0; i < numToProcess; i++ {
		jobs <- allCandidates[i]
	}
	close(jobs) // Signal no more jobs are coming
	log.Println("All jobs sent.")

	// --- Process Results Log (Optional) ---
	// Goroutine to handle logging results concurrently without blocking workers
	var logWg sync.WaitGroup
	logWg.Add(1)
	go func() {
		defer logWg.Done()
		count := 0
		for res := range resultsLog {
			log.Println(res) // Log each saved item
			count++
		}
		log.Printf("Result logger finished after receiving %d messages.", count)
	}()

	// --- Wait & Final Stats ---
	log.Println("Waiting for workers to finish processing...")
	wg.Wait()         // Wait for all workers in the main WaitGroup
	close(resultsLog) // Close the results channel *after* all workers are done sending
	logWg.Wait()      // Wait for the result logger goroutine to finish processing the channel
	log.Println("All workers finished.")

	duration := time.Since(startTime).Round(time.Second)
	finalProcessed := atomic.LoadInt32(&processed)
	finalValidated := atomic.LoadInt32(&validated)
	finalSkipped := atomic.LoadInt32(&skipped)
	finalErrors := atomic.LoadInt32(&errors)

	log.Println("\n========== FINAL STATISTICS ==========")
	log.Printf("Total Candidates Processed: %d", finalProcessed)
	log.Printf("Successfully Validated & Saved: %d", finalValidated)
	log.Printf("Skipped (Exists or No Coverage): %d", finalSkipped)
	log.Printf("Errors (API or DB): %d", finalErrors)
	log.Printf("Total Runtime: %v", duration)
	if finalProcessed > 0 {
		log.Printf("Avg. Time/Candidate: %v", duration/time.Duration(finalProcessed))
	}
	log.Println("======================================")
}


================================================================================

Filename: scripts/regions.json
Content:
[
    {
        "name": "Western Europe",
        "minLat": 43.0,
        "maxLat": 55.0,
        "minLng": -5.0,
        "maxLng": 15.0,
        "description": "France, Germany, Italy, etc.",
        "gridDensity": 0.05,
        "hasOSMData": true,
        "include": false
    },
    {
        "name": "US East Coast",
        "minLat": 35.0,
        "maxLat": 45.0,
        "minLng": -78.0,
        "maxLng": -70.0,
        "description": "Boston to Washington DC",
        "gridDensity": 0.05,
        "hasOSMData": true,
        "include": false
    },
    {
        "name": "Japan",
        "minLat": 33.0,
        "maxLat": 37.0,
        "minLng": 135.0,
        "maxLng": 141.0,
        "description": "Tokyo, Kyoto, Osaka region",
        "gridDensity": 0.1,
        "hasOSMData": true,
        "include": false
    },
    {
        "name": "Australia East Coast",
        "minLat": -38.0,
        "maxLat": -28.0,
        "minLng": 150.0,
        "maxLng": 153.0,
        "description": "Sydney to Brisbane",
        "gridDensity": 0.05,
        "hasOSMData": true,
        "include": false
    },
    {
        "name": "India",
        "minLat": 8.0,
        "maxLat": 37.0,
        "minLng": 78.0,
        "maxLng": 92.0,
        "description": "Delhi, Mumbai, Bangalore region",
        "gridDensity": 0.1,
        "hasOSMData": true,
        "include": true
    },
    {
        "name": "Canada",
        "minLat": 42.0,
        "maxLat": 60.0,
        "minLng": -140.0,
        "maxLng": -50.0,
        "description": "Toronto to Vancouver",
        "gridDensity": 0.05,
        "hasOSMData": true,
        "include": false
    },
    
    {
        "name": "Central Africa",
        "minLat": -20.0,
        "maxLat": 10.0,
        "minLng": 10.0,
        "maxLng": 40.0,
        "description": "Democratic Republic of the Congo region",
        "gridDensity": 0.1,
        "hasOSMData": true,
        "include": false
    },
    {
        "name": "South Africa",
        "minLat": -34.5,
        "maxLat": -25.5,
        "minLng": 18.0,
        "maxLng": 31.0,
        "description": "Cape Town to Johannesburg",
        "gridDensity": 0.1,
        "hasOSMData": true,
        "include": false
    },
    {
        "name": "US West Coast",
        "minLat": 32.0,
        "maxLat": 48.0,
        "minLng": -125.0,
        "maxLng": -115.0,
        "description": "California to Washington",
        "gridDensity": 0.05,
        "hasOSMData": true,
        "include": false
    },
    {
        "name": "Brazil",
        "minLat": -20.0,
        "maxLat": -5.0,
        "minLng": -55.0,
        "maxLng": -35.0,
        "description": "Brazilian coast and interior",
        "gridDensity": 0.1,
        "hasOSMData": true,
        "include": false
    },
    {
        "name": "Scandinavia",
        "minLat": 55.0,
        "maxLat": 70.0,
        "minLng": 5.0,
        "maxLng": 30.0,
        "description": "Norway, Sweden, Finland",
        "gridDensity": 0.07,
        "hasOSMData": true,
        "include": true
    },
    {
        "name": "Southeast Asia",
        "minLat": -10.0,
        "maxLat": 15.0,
        "minLng": 95.0,
        "maxLng": 130.0,
        "description": "Thailand, Vietnam, Indonesia, etc.",
        "gridDensity": 0.1,
        "hasOSMData": true,
        "include": true
    },
    {
        "name": "Middle East",
        "minLat": 20.0,
        "maxLat": 35.0,
        "minLng": 35.0,
        "maxLng": 60.0,
        "description": "Saudi Arabia, Iran, Iraq, etc.",
        "gridDensity": 0.08,
        "hasOSMData": true,
        "include": true
    },
    {
        "name": "Eastern Europe",
        "minLat": 45.0,
        "maxLat": 60.0,
        "minLng": 20.0,
        "maxLng": 40.0,
        "description": "Poland, Ukraine, Russia, etc.",
        "gridDensity": 0.06,
        "hasOSMData": true,
        "include": true
    },
    {
        "name": "Andes Mountains",
        "minLat": -40.0,
        "maxLat": -10.0,
        "minLng": -75.0,
        "maxLng": -65.0,
        "description": "Chile, Peru, Bolivia region",
        "gridDensity": 0.09,
        "hasOSMData": true,
        "include": true
    }
]

================================================================================


================================================================================

Filename: scripts/manual_locations.json
Content:
[
    {
        "latitude": 40.75798,
        "longitude": -73.9855,
        "description": "Times Square, NYC, USA",
        "source": "manual"
    },
    {
        "latitude": 34.0522,
        "longitude": -118.2437,
        "description": "Los Angeles, CA, USA",
        "source": "manual"
    },
    {
        "latitude": -22.9068,
        "longitude": -43.1729,
        "description": "Rio de Janeiro, Brazil",
        "source": "manual"
    }
]

================================================================================

Filename: scripts/populate_locations.go
Content:
// scripts/populate_locations.go
package main

import (
	"encoding/json"
	// "encoding/xml" // Keep commented unless using OSM
	"flag"
	"fmt"
	"io"
	"log"
	"math/rand" // For shuffling
	"net/http"
	"net/url"
	"os"
	"runtime" // For NumCPU
	"sync"
	"sync/atomic"
	"time"

	"github.com/joho/godotenv"
	"gorm.io/gorm"

	// Use internal packages
	"geoguessr-backend/internal/database"
	"geoguessr-backend/internal/models"
)

// --- Struct Definitions ---

// Region defines a geographical area (from regions.json)
type Region struct {
	Name        string  `json:"name"`
	MinLat      float64 `json:"minLat"`
	MaxLat      float64 `json:"maxLat"`
	MinLng      float64 `json:"minLng"`
	MaxLng      float64 `json:"maxLng"`
	Description string  `json:"description"`
	GridDensity float64 `json:"gridDensity"`
	HasOSMData  bool    `json:"hasOSMData"`
	Include     bool    `json:"include"` // New field to determine if the region should be included
}

// CandidateLocation represents a potential location to verify (from files or generation)
type CandidateLocation struct {
	Latitude    float64 `json:"latitude"`
	Longitude   float64 `json:"longitude"`
	Description string  `json:"description"`
	Source      string  `json:"source"` // e.g., "manual", "grid", "osm"
}

// StreetViewMetadataResponse represents the relevant parts of the Google API response
type StreetViewMetadataResponse struct {
	Status    string         `json:"status"`    // "OK", "ZERO_RESULTS", etc.
	Location  *LatLngLiteral `json:"location"`  // Pointer to handle potential null on non-OK status
	Copyright string         `json:"copyright"` // Can add if needed
	Date      string         `json:"date"`      // Can add if needed
	PanoID    string         `json:"pano_id"`   // Can add if needed
}

// LatLngLiteral represents a latitude-longitude pair from Google API
type LatLngLiteral struct {
	Lat float64 `json:"lat"`
	Lng float64 `json:"lng"`
}

// --- Helper Functions ---

// loadJSONFile reads and unmarshals a JSON file into the target interface
func loadJSONFile(filePath string, target interface{}) error {
	data, err := os.ReadFile(filePath)
	if err != nil {
		// Treat missing manual file as non-fatal, just return empty
		if os.IsNotExist(err) && filePath == "./scripts/manual_locations.json" {
			log.Printf("Info: %s not found, skipping manual locations.", filePath)
			return nil // Return nil to indicate okay, just no data
		}
		return fmt.Errorf("error reading %s: %w", filePath, err)
	}
	if err := json.Unmarshal(data, target); err != nil {
		return fmt.Errorf("error parsing %s: %w", filePath, err)
	}
	return nil
}

// generateGridCoordinates generates grid-based candidate locations for all regions
func generateGridCoordinates(regions []Region) []CandidateLocation {
	var candidates []CandidateLocation
	log.Println("Generating grid coordinates...")
	totalGenerated := 0
	for _, region := range regions {
		if !region.Include {
			log.Printf("Skipping region '%s' as it is marked to be excluded.", region.Name)
			continue
		}
		regionGenerated := 0
		latSteps := int((region.MaxLat - region.MinLat) / region.GridDensity)
		lngSteps := int((region.MaxLng - region.MinLng) / region.GridDensity)

		// Estimate points to prevent huge loops if density is tiny
		estimatedPoints := (latSteps + 1) * (lngSteps + 1)
		if estimatedPoints > 1000000 { // Safety cap per region
			log.Printf("Warning: Estimated points for region '%s' (%d) exceeds safety cap. Adjust density or bounds.", region.Name, estimatedPoints)
			continue
		}

		for i := 0; i <= latSteps; i++ {
			for j := 0; j <= lngSteps; j++ {
				lat := region.MinLat + float64(i)*region.GridDensity
				lng := region.MinLng + float64(j)*region.GridDensity
				// Ensure point is within precise bounds (floating point safety)
				if lat <= region.MaxLat && lng <= region.MaxLng {
					candidates = append(candidates, CandidateLocation{
						Latitude:    lat,
						Longitude:   lng,
						Description: fmt.Sprintf("Grid point in %s", region.Description),
						Source:      "grid",
					})
					regionGenerated++
				}
			}
		}
		totalGenerated += regionGenerated
	}
	log.Printf("Finished generating grid coordinates. Total raw grid points: %d", totalGenerated)
	return candidates
}

// limitGridLocations randomly samples a subset if the list is too large
func limitGridLocations(locations []CandidateLocation, maxCount int) []CandidateLocation {
	if maxCount <= 0 || len(locations) <= maxCount {
		return locations // No limiting needed or disabled
	}
	log.Printf("Limiting %d grid locations down to %d points using random sampling...", len(locations), maxCount)
	// rand.Seed is handled in main now
	rand.Shuffle(len(locations), func(i, j int) {
		locations[i], locations[j] = locations[j], locations[i]
	})
	return locations[:maxCount]
}

// locationExistsInDB checks if a similar location exists within tolerance
func locationExistsInDB(db *gorm.DB, lat, lng float64) (bool, uint) {
	const tolerance = 0.001 // ~110 meters latitude, varies longitude
	var location models.Location
	// Only select ID for efficiency when just checking existence
	err := db.Select("id").Where("latitude BETWEEN ? AND ?", lat-tolerance, lat+tolerance).
		Where("longitude BETWEEN ? AND ?", lng-tolerance, lng+tolerance).
		First(&location).Error

	if err == nil {
		return true, location.ID // Found existing
	}
	if err != gorm.ErrRecordNotFound {
		// Log actual DB errors, not just "not found"
		log.Printf("DB Check Error: %v for coords (%f, %f)", err, lat, lng)
	}
	return false, 0
}

// saveLocationToDB saves a validated location to the database using the internal model
func saveLocationToDB(db *gorm.DB, metadata *StreetViewMetadataResponse, description string) (uint, error) {
	location := models.Location{ // Use the model from internal/models
		Latitude:    metadata.Location.Lat, // Use validated coordinates from Google
		Longitude:   metadata.Location.Lng,
		Description: description, // Keep original or generate based on source
		// Country/Region could be added via reverse geocoding later
	}
	result := db.Create(&location) // Capture GORM result
	if result.Error != nil {
		return 0, result.Error
	}
	return location.ID, nil // Return the ID of the newly created record
}

// getStreetViewMetadata calls the Google Street View Metadata API
func getStreetViewMetadata(apiKey string, lat, lng float64) (*StreetViewMetadataResponse, error) {
	baseURL := "https://maps.googleapis.com/maps/api/streetview/metadata"
	params := url.Values{}
	params.Add("location", fmt.Sprintf("%.6f,%.6f", lat, lng)) // Use precision
	params.Add("key", apiKey)
	params.Add("source", "outdoor") // Filter for official Google coverage
	fullURL := baseURL + "?" + params.Encode()

	// Use default HTTP client (or configure one with timeout)
	resp, err := http.Get(fullURL)
	if err != nil {
		return nil, fmt.Errorf("http GET failed: %w", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed reading response body: %w", err)
	}

	// Try to unmarshal into the response struct regardless of HTTP status
	// This helps capture API-level errors like OVER_QUERY_LIMIT in the JSON body
	var metadata StreetViewMetadataResponse
	jsonErr := json.Unmarshal(body, &metadata)

	// Check HTTP status first
	if resp.StatusCode != http.StatusOK {
		errMsg := fmt.Sprintf("api http status: %s", resp.Status)
		// If JSON parsing worked and we have a status, include it
		if jsonErr == nil && metadata.Status != "" {
			errMsg += fmt.Sprintf(" (API Status: %s)", metadata.Status)
		} else {
			// Otherwise include raw body for debugging non-JSON errors
			errMsg += fmt.Sprintf(", body: %s", string(body))
		}
		return &metadata, fmt.Errorf(errMsg) // Return partial metadata if available + error
	}

	// HTTP OK, but check JSON parsing and internal status
	if jsonErr != nil {
		return nil, fmt.Errorf("failed unmarshalling OK response body: %w, body: %s", jsonErr, string(body))
	}
	if metadata.Status != "OK" {
		// API call succeeded at HTTP level, but Google couldn't find imagery/etc.
		return &metadata, fmt.Errorf("api status: %s", metadata.Status)
	}
	if metadata.Location == nil {
		// Should not happen if status is OK, but defensively check
		return &metadata, fmt.Errorf("api status OK but missing location data")
	}

	// If we reach here, all checks passed
	return &metadata, nil
}
func loadRegions() []Region {
	var regions []Region // Initialize empty slice
	filePath := "./scripts/regions.json"
	err := loadJSONFile(filePath, &regions) // <<< Use helper, pass pointer
	if err != nil {
		// Make region loading fatal as it's likely required
		log.Fatalf("FATAL: %v", err)
	}
	log.Printf("Loaded %d regions from %s", len(regions), filePath)
	return regions
}

// loadManualLocations loads manual locations using the helper
func loadManualLocations() []CandidateLocation {
	var locations []CandidateLocation // Initialize empty slice
	filePath := "./scripts/manual_locations.json"
	err := loadJSONFile(filePath, &locations) // <<< Use helper, pass pointer
	if err != nil {
		// Warn but don't make it fatal for optional manual locations
		log.Printf("Warning: Could not load/parse %s: %v", filePath, err)
		return []CandidateLocation{} // Return empty slice on error
	}
	// Handle case where file exists but is empty "[]" or if loadJSONFile returned nil error for non-existent file
	if locations == nil {
		locations = []CandidateLocation{}
	}
	log.Printf("Loaded %d manual locations from %s", len(locations), filePath)
	return locations
}

// --- Main Logic ---

func main() {
	// --- Flags ---
	batchSize := flag.Int("batch-size", 0, "Max number of candidate locations to process (0 for all)")
	maxGridPerRegion := flag.Int("max-grid", 20000, "Maximum number of grid points per region to generate (adjust based on density)") // Increased default
	workerCount := flag.Int("workers", runtime.NumCPU()*2, "Number of concurrent workers")
	apiDelayMs := flag.Int("delay", 25, "Base delay in milliseconds between API calls PER WORKER (increase if rate limited)")
	progressInterval := flag.Int("progress", 500, "Log progress every N processed locations")
	flag.Parse()

	log.Printf("Starting population script with BatchSize=%d, MaxGridPerRegion=%d, Workers=%d, APIDelay=%dms",
		*batchSize, *maxGridPerRegion, *workerCount, *apiDelayMs)

	// --- Env & DB Setup ---
	err := godotenv.Load() // Load .env file from current directory
	if err != nil {
		// Don't treat as fatal, might use system env vars
		log.Println("Info: .env file not found or failed to load. Will rely on system environment variables.")
	}
	apiKey := os.Getenv("GOOGLE_MAPS_API_KEY")
	if apiKey == "" {
		log.Fatal("FATAL: GOOGLE_MAPS_API_KEY environment variable not set.")
	}

	if err := database.Connect(); err != nil { // Connect uses GORM logger settings from database package
		log.Fatalf("FATAL: Error connecting to database: %v", err)
	}
	db := database.GetDB() // Use the getter from the database package
	log.Println("Database connection ready.")

	// --- Load Candidates ---
	regions := loadRegions() // Calls the refactored version
	manualLocations := loadManualLocations()
	log.Printf("Loaded %d regions and %d manual locations.", len(regions), len(manualLocations))

	gridLocations := generateGridCoordinates(regions)
	gridLocations = limitGridLocations(gridLocations, *maxGridPerRegion*len(regions)) // Limit total grid points globally

	allCandidates := append(manualLocations, gridLocations...)
	log.Printf("Total candidate locations generated: %d", len(allCandidates))

	// Shuffle and Slice candidates
	// rand.Seed(time.Now().UnixNano()) // Seed globally once
	rand.New(rand.NewSource(time.Now().UnixNano())) // Use non-deprecated way if needed, though Shuffle uses global
	rand.Shuffle(len(allCandidates), func(i, j int) {
		allCandidates[i], allCandidates[j] = allCandidates[j], allCandidates[i]
	})

	// Determine actual number to process based on batchSize flag
	numToProcess := len(allCandidates)
	if *batchSize > 0 && *batchSize < len(allCandidates) {
		numToProcess = *batchSize
		allCandidates = allCandidates[:numToProcess]
		log.Printf("Processing first %d shuffled candidates based on batch-size flag.", numToProcess)
	} else {
		log.Printf("Processing all %d shuffled candidates.", numToProcess)
	}
	if numToProcess == 0 {
		log.Println("No candidates to process. Exiting.")
		return
	}

	// --- Setup Concurrency & Stats ---
	var processed, validated, skipped, errors int32 // Atomic counters
	startTime := time.Now()
	apiCallDelay := time.Duration(*apiDelayMs) * time.Millisecond

	jobs := make(chan CandidateLocation, numToProcess) // Buffered channel for jobs
	resultsLog := make(chan string, *workerCount)      // Optional: channel for concise results logging
	var wg sync.WaitGroup

	// --- Start Workers ---
	log.Printf("Launching %d workers...", *workerCount)
	for i := 0; i < *workerCount; i++ {
		wg.Add(1)
		go func(workerID int) {
			defer wg.Done()
			// Small initial stagger for workers
			time.Sleep(time.Duration(rand.Intn(50*workerID+10)) * time.Millisecond)

			for candidate := range jobs {
				currentProcessed := atomic.AddInt32(&processed, 1) // Increment processed count first

				// 1. Check DB Existence
				exists, existingID := locationExistsInDB(db, candidate.Latitude, candidate.Longitude)
				if exists {
					atomic.AddInt32(&skipped, 1)
					resultsLog <- fmt.Sprintf("W%d SkipExist: %d", workerID, existingID) // Optional detailed log
					continue                                                             // Skip to next job
				}

				// 2. Call Google Metadata API (with delay)
				time.Sleep(apiCallDelay) // Apply delay before each API call for this worker
				metadata, err := getStreetViewMetadata(apiKey, candidate.Latitude, candidate.Longitude)

				// 3. Handle API Response/Error
				if err != nil {
					errMsg := err.Error()
					statusMsg := ""
					if metadata != nil { // Metadata might be non-nil even on error (e.g., status errors)
						statusMsg = metadata.Status
					}

					// Check if it's just ZERO_RESULTS (expected skip)
					if statusMsg == "ZERO_RESULTS" || errMsg == "api status: ZERO_RESULTS" {
						atomic.AddInt32(&skipped, 1)
						// resultsLog <- fmt.Sprintf("W%d SkipAPI(ZERO): %.4f,%.4f", workerID, candidate.Latitude, candidate.Longitude)
					} else {
						// Log other errors more visibly
						log.Printf("Worker %d API Error: %v (Status: %s) for Candidate: %.4f,%.4f (%s)",
							workerID, err, statusMsg, candidate.Latitude, candidate.Longitude, candidate.Source)
						atomic.AddInt32(&errors, 1)
					}
					continue // Skip to next job
				}

				// 4. Save Valid Location to DB (Status is guaranteed OK here)
				newID, dbErr := saveLocationToDB(db, metadata, candidate.Description)
				if dbErr != nil {
					log.Printf("Worker %d DB Error saving %.4f,%.4f: %v", workerID, metadata.Location.Lat, metadata.Location.Lng, dbErr)
					atomic.AddInt32(&errors, 1)
				} else {
					atomic.AddInt32(&validated, 1)
					resultsLog <- fmt.Sprintf("Saved %d: %.4f,%.4f (%s)", newID, metadata.Location.Lat, metadata.Location.Lng, candidate.Description) // Log success
				}

				// --- Log Progress Periodically (from worker 0) ---
				if workerID == 0 && int(currentProcessed)%(*progressInterval) == 0 {
					elapsed := time.Since(startTime).Round(time.Second)
					percent := float64(currentProcessed) / float64(numToProcess) * 100
					v := atomic.LoadInt32(&validated)
					s := atomic.LoadInt32(&skipped)
					e := atomic.LoadInt32(&errors)
					log.Printf("Progress: %d/%d (%.1f%%) | Valid: %d | Skip: %d | Err: %d | Elapsed: %v",
						currentProcessed, numToProcess, percent, v, s, e, elapsed)
				}
			}
		}(i)
	}

	// --- Feed Jobs ---
	log.Printf("Feeding %d jobs to workers...", numToProcess)
	for i := 0; i < numToProcess; i++ {
		jobs <- allCandidates[i]
	}
	close(jobs) // Signal no more jobs are coming
	log.Println("All jobs sent.")

	// --- Process Results Log (Optional) ---
	// Goroutine to handle logging results concurrently without blocking workers
	var logWg sync.WaitGroup
	logWg.Add(1)
	go func() {
		defer logWg.Done()
		count := 0
		for res := range resultsLog {
			log.Println(res) // Log each saved item
			count++
		}
		log.Printf("Result logger finished after receiving %d messages.", count)
	}()

	// --- Wait & Final Stats ---
	log.Println("Waiting for workers to finish processing...")
	wg.Wait()         // Wait for all workers in the main WaitGroup
	close(resultsLog) // Close the results channel *after* all workers are done sending
	logWg.Wait()      // Wait for the result logger goroutine to finish processing the channel
	log.Println("All workers finished.")

	duration := time.Since(startTime).Round(time.Second)
	finalProcessed := atomic.LoadInt32(&processed)
	finalValidated := atomic.LoadInt32(&validated)
	finalSkipped := atomic.LoadInt32(&skipped)
	finalErrors := atomic.LoadInt32(&errors)

	log.Println("\n========== FINAL STATISTICS ==========")
	log.Printf("Total Candidates Processed: %d", finalProcessed)
	log.Printf("Successfully Validated & Saved: %d", finalValidated)
	log.Printf("Skipped (Exists or No Coverage): %d", finalSkipped)
	log.Printf("Errors (API or DB): %d", finalErrors)
	log.Printf("Total Runtime: %v", duration)
	if finalProcessed > 0 {
		log.Printf("Avg. Time/Candidate: %v", duration/time.Duration(finalProcessed))
	}
	log.Println("======================================")
}


================================================================================

Filename: scripts/regions.json
Content:
[
    {
        "name": "Western Europe",
        "minLat": 43.0,
        "maxLat": 55.0,
        "minLng": -5.0,
        "maxLng": 15.0,
        "description": "France, Germany, Italy, etc.",
        "gridDensity": 0.05,
        "hasOSMData": true,
        "include": false
    },
    {
        "name": "US East Coast",
        "minLat": 35.0,
        "maxLat": 45.0,
        "minLng": -78.0,
        "maxLng": -70.0,
        "description": "Boston to Washington DC",
        "gridDensity": 0.05,
        "hasOSMData": true,
        "include": false
    },
    {
        "name": "Japan",
        "minLat": 33.0,
        "maxLat": 37.0,
        "minLng": 135.0,
        "maxLng": 141.0,
        "description": "Tokyo, Kyoto, Osaka region",
        "gridDensity": 0.1,
        "hasOSMData": true,
        "include": false
    },
    {
        "name": "Australia East Coast",
        "minLat": -38.0,
        "maxLat": -28.0,
        "minLng": 150.0,
        "maxLng": 153.0,
        "description": "Sydney to Brisbane",
        "gridDensity": 0.05,
        "hasOSMData": true,
        "include": false
    },
    {
        "name": "India",
        "minLat": 8.0,
        "maxLat": 37.0,
        "minLng": 78.0,
        "maxLng": 92.0,
        "description": "Delhi, Mumbai, Bangalore region",
        "gridDensity": 0.1,
        "hasOSMData": true,
        "include": true
    },
    {
        "name": "Canada",
        "minLat": 42.0,
        "maxLat": 60.0,
        "minLng": -140.0,
        "maxLng": -50.0,
        "description": "Toronto to Vancouver",
        "gridDensity": 0.05,
        "hasOSMData": true,
        "include": false
    },
    
    {
        "name": "Central Africa",
        "minLat": -20.0,
        "maxLat": 10.0,
        "minLng": 10.0,
        "maxLng": 40.0,
        "description": "Democratic Republic of the Congo region",
        "gridDensity": 0.1,
        "hasOSMData": true,
        "include": false
    },
    {
        "name": "South Africa",
        "minLat": -34.5,
        "maxLat": -25.5,
        "minLng": 18.0,
        "maxLng": 31.0,
        "description": "Cape Town to Johannesburg",
        "gridDensity": 0.1,
        "hasOSMData": true,
        "include": false
    },
    {
        "name": "US West Coast",
        "minLat": 32.0,
        "maxLat": 48.0,
        "minLng": -125.0,
        "maxLng": -115.0,
        "description": "California to Washington",
        "gridDensity": 0.05,
        "hasOSMData": true,
        "include": false
    },
    {
        "name": "Brazil",
        "minLat": -20.0,
        "maxLat": -5.0,
        "minLng": -55.0,
        "maxLng": -35.0,
        "description": "Brazilian coast and interior",
        "gridDensity": 0.1,
        "hasOSMData": true,
        "include": false
    },
    {
        "name": "Scandinavia",
        "minLat": 55.0,
        "maxLat": 70.0,
        "minLng": 5.0,
        "maxLng": 30.0,
        "description": "Norway, Sweden, Finland",
        "gridDensity": 0.07,
        "hasOSMData": true,
        "include": true
    },
    {
        "name": "Southeast Asia",
        "minLat": -10.0,
        "maxLat": 15.0,
        "minLng": 95.0,
        "maxLng": 130.0,
        "description": "Thailand, Vietnam, Indonesia, etc.",
        "gridDensity": 0.1,
        "hasOSMData": true,
        "include": true
    },
    {
        "name": "Middle East",
        "minLat": 20.0,
        "maxLat": 35.0,
        "minLng": 35.0,
        "maxLng": 60.0,
        "description": "Saudi Arabia, Iran, Iraq, etc.",
        "gridDensity": 0.08,
        "hasOSMData": true,
        "include": true
    },
    {
        "name": "Eastern Europe",
        "minLat": 45.0,
        "maxLat": 60.0,
        "minLng": 20.0,
        "maxLng": 40.0,
        "description": "Poland, Ukraine, Russia, etc.",
        "gridDensity": 0.06,
        "hasOSMData": true,
        "include": true
    },
    {
        "name": "Andes Mountains",
        "minLat": -40.0,
        "maxLat": -10.0,
        "minLng": -75.0,
        "maxLng": -65.0,
        "description": "Chile, Peru, Bolivia region",
        "gridDensity": 0.09,
        "hasOSMData": true,
        "include": true
    }
]

================================================================================
