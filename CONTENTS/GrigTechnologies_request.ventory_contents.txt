
Filename: .github/create_json_file.sh
Content:
#!/bin/bash

# Check if the correct number of arguments is provided
if [ "$#" -ne 2 ]; then
    echo "Usage: $0 '<json_string>' <output_file.json>"
    exit 1
fi

# Read arguments
JSON_STRING="$1"
OUTPUT_FILE="$2"

# Write the JSON string to the output file without escaping quotes
echo "$JSON_STRING" > "$OUTPUT_FILE"

# Confirm the creation of the file
echo "JSON file created at: $OUTPUT_FILE"


================================================================================

Filename: .github/workflows/dev.yml
Content:
name: Build and Push Docker Image (DEVELOPMENT)

# Run the workflow when code is pushed to the main branch
on:
  push:
    branches:
      - dev

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      # Checkout the code from your repository
      - name: Checkout code
        uses: actions/checkout@v4

      # Set up Docker Buildx (for advanced Docker builds)
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      # create configurations (.json) files from GitHub secrets
      - name: Create configuration files
        run: |
          # Make sure the script is executable
          chmod +x ./.github/create_json_file.sh
          
          # Create flask_config.json using the bash script and GitHub secret
          ./.github/create_json_file.sh "${{ secrets.FLASK_CONFIG }}" ./configs/flask_config.json
          
          # Create firebase_adminSDK.json using the bash script and GitHub secret
          ./.github/create_json_file.sh "${{ secrets.FIREBASE_ADMIN_SDK }}" ./configs/firebase_adminSDK.json

      # Log in to Docker Hub
      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # Build the Docker image
      - name: Build Docker Image
        run: docker build -t grigtechnologies/dev.request.ventory:latest .

      # Push the Docker image to Docker Hub
      - name: Push Docker Image
        run: docker push grigtechnologies/dev.request.ventory:latest


================================================================================

Filename: .github/workflows/main.yml
Content:
name: Build and Push Docker Image (Production)

# Run the workflow when code is pushed to the main branch
on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      # Checkout the code from your repository
      - name: Checkout code
        uses: actions/checkout@v4

      # Set up Docker Buildx (for advanced Docker builds)
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      # create configurations (.json) files from GitHub secrets
      - name: Create configuration files
        run: |
          # Make sure the script is executable
          chmod +x ./.github/create_json_file.sh
          
          # Create flask_config.json using the bash script and GitHub secret
          ./.github/create_json_file.sh "${{ secrets.FLASK_CONFIG }}" ./configs/flask_config.json
          
          # Create firebase_adminSDK.json using the bash script and GitHub secret
          ./.github/create_json_file.sh "${{ secrets.FIREBASE_ADMIN_SDK }}" ./configs/firebase_adminSDK.json

      # Log in to Docker Hub
      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # Build the Docker image
      - name: Build Docker Image
        run: docker build -t grigtechnologies/request.ventory:latest .

      # Push the Docker image to Docker Hub
      - name: Push Docker Image
        run: docker push grigtechnologies/request.ventory:latest


================================================================================

Filename: .gitignore
Content:
bin
lib
.idea
.DS_Store
pyvenv.cfg
__pycache__/
.venv

configs/*
!configs/README.md
!configs/__init__.py
!configs/json_to_github_secrets.py
!configs/restx_config.json

/Scripts/git

logs/*
!logs/__init__.py
logs/index.log



================================================================================

Filename: Dockerfile
Content:
# Use the official Python image
FROM python:3.9

# Set the working directory in the container
WORKDIR /request_ventory

# Copy the current directory contents into the container
COPY . /request_ventory

# Install Python dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Expose the port Flask will run on
EXPOSE 5000

# Run the Flask app using Gunicorn
CMD ["gunicorn", "-b", "0.0.0.0:5000", "app:app"]


================================================================================

Filename: LICENSE
Content:
request.ventory License
©2024 Grig Technologies Pvt Ltd · Ventory® · All rights reserved.
Version 1.0 Beta

1. License Grant
Permission is hereby granted to Grig Technologies Pvt. Ltd., its employees, and authorized contributors to view, modify, and contribute to the codebase of this project for internal use only.

2. Usage Restrictions
This project and its code, files, documentation, or any related materials may only be used within Grig Technologies or as authorized by Grig Technologies in writing.
No part of this project, including the code, documents, or other assets, may be shared, published, distributed, or disclosed to any third party, in whole or in part, without express written permission from Grig Technologies.
Contributors are not allowed to use or share the contents of this project in any form for personal, commercial, or public use outside the scope of this project.

3. Contribution Guidelines
Authorized contributors may only contribute code to the project.
Contributors must not copy or replicate any part of this project for use outside the project or share contributions with others without explicit written permission from Grig Technologies.
All contributions to this project are subject to approval and may be rejected by Grig Technologies at its sole discretion.

4. Confidentiality
This project contains proprietary and confidential information of Grig Technologies. By accessing and contributing to this project, contributors agree to maintain its confidentiality and not disclose any information regarding this project, either directly or indirectly, to unauthorized parties.

5. Intellectual Property
All contributions made to this project become the sole property of Grig Technologies. Contributors agree to waive all claims to intellectual property rights over any contribution.

6. Termination of Access
Grig Technologies reserves the right to terminate any contributor's access to this project at any time without prior notice, if the terms of this license are violated or for any other reason deemed necessary by Grig Technologies.

7. Legal Actions
Any violation of this license may result in legal action by Grig Technologies, including but not limited to, claims for damages or injunctions.

================================================================================

Filename: README.md
Content:
# request.ventory
Version 1.0 Beta

- [LICENSE](LICENSE)
- [ADMIN](https://github.com/shubhamistic)

©2024 Grig Technologies Pvt Ltd · Ventory® · All rights reserved.

================================================================================

Filename: app.py
Content:
from flask import Flask
from flask_cors import CORS
from flask_jwt_extended import JWTManager
from configs import validate_and_configure_app
from defaults import run_defaults
from logs import LOGGING
from restx import RESTX
from routes import (
    auth_api,
    inventory_api,
    user_api
)
from supabase import init_db

# Define the app
app = Flask(__name__, template_folder='mailer/templates')

# validate and configure the app
validate_and_configure_app(app)

# Define extensions/middlewares
CORS(app)            # cors
JWTManager(app)      # jwt
RESTX.init_app(app)  # restx
LOGGING(app)         # logging

# Define the namespaces
RESTX.add_namespace(auth_api, path='/auth')
RESTX.add_namespace(inventory_api, path='/inventory')
RESTX.add_namespace(user_api, path='/user')

init_db()
if __name__ == '__main__':
    # Run default operations
    run_defaults()

    # Run the flask server
    app.run(
        debug=True,
        host="0.0.0.0",
        port=5000
    )


================================================================================

Filename: configs/README.md
Content:
# CONFIGS
this directory contains the configuration files required for the project.

### list of files in configs directory:
- firebase_adminSDK.json (contains firebase configuration)
- flask_config.json (contains flask and email related configurations)

================================================================================

Filename: configs/__init__.py
Content:
from datetime import timedelta
from utils import get_data_from_json_file


# configure the app
def validate_and_configure_app(app):
    # ----- validate and configure flask app ---------------------------------------------------------------------------
    # get the flask config:
    flask_config = get_data_from_json_file("configs/flask_config.json")
    # configure SECRET_KEY:
    app.config['SECRET_KEY'] = flask_config['SECRET_KEY']
    # Configure JWT:
    app.config['JWT_ACCESS_TOKEN_EXPIRES'] = timedelta(seconds=int(flask_config['JWT_ACCESS_TOKEN_EXPIRES']))
    app.config['JWT_REFRESH_TOKEN_EXPIRES'] = timedelta(seconds=int(flask_config['JWT_REFRESH_TOKEN_EXPIRES']))
    # Configure email:
    app.config['MAIL_SERVER'] = flask_config['MAIL_SERVER']
    app.config['MAIL_PORT'] = flask_config['MAIL_PORT']
    app.config['MAIL_USE_SSL'] = flask_config['MAIL_USE_SSL']
    app.config['MAIL_USERNAME'] = flask_config['MAIL_USERNAME']
    app.config['MAIL_PASSWORD'] = flask_config['MAIL_PASSWORD']
    app.config['MAIL_DEFAULT_SENDER'] = flask_config['MAIL_DEFAULT_SENDER']

    # ----- validate firebase_adminSDK ---------------------------------------------------------------------------------
    get_data_from_json_file("configs/firebase_adminSDK.json")


================================================================================

Filename: configs/json_to_github_secrets.py
Content:
import json


def convert_json_to_escaped_string(file_path):
    # Read the JSON file
    with open(file_path, 'r') as json_file:
        data = json.load(json_file)

    # Convert the JSON data to a string and escape quotes
    json_string = json.dumps(data)
    escaped_string = json_string.replace('"', '\\"')

    return escaped_string


if __name__ == '__main__':
    # ------------------------------------------------------------------------------------------------------------------
    file_path = 'firebase_adminSDK.json'  # Replace with your JSON file path
    escaped_json = convert_json_to_escaped_string(file_path)
    print("-----", file_path, "-----\n")
    print(escaped_json, "\n")

    # ------------------------------------------------------------------------------------------------------------------

    file_path = 'flask_config.json'  # Replace with your JSON file path
    escaped_json = convert_json_to_escaped_string(file_path)
    print("-----", file_path, "-----\n")
    print(escaped_json, "\n")
    # ------------------------------------------------------------------------------------------------------------------

    file_path = 'restx_config.json'  # Replace with your JSON file path
    escaped_json = convert_json_to_escaped_string(file_path)
    print("-----", file_path, "-----\n")
    print(escaped_json, "\n")
    # ------------------------------------------------------------------------------------------------------------------


================================================================================

Filename: configs/restx_config.json
Content:
{
  "title": "request.ventory",
  "description": "©2024 Grig Technologies Pvt Ltd · Ventory® · All rights reserved.\nClick to <a href='https://grigtechnologies.atlassian.net/wiki/spaces/requestven/pages/65750/Swagger' target='_blank'>visit docs</a>",
  "version": "1.0 Beta",
  "authorizations": {
    "Bearer": {
      "type": "apiKey",
      "in": "header",
      "name": "Authorization",
      "description": "JWT inventory_access_token. Example (Header): {'Authorization': 'Bearer {inventory_access_token}'. <a href='https://grigtechnologies.atlassian.net/wiki/spaces/requestven/pages/720909/How+to+get+Inventory+Access+Token' target='_blank'>How to get Inventory Access Token</a>"
    }
  }
}

================================================================================

Filename: controllers/__init__.py
Content:
from controllers.auth_controllers import permissions_required, get_jwt_user_id

================================================================================

Filename: controllers/auth_controllers/__init__.py
Content:
from controllers.auth_controllers.authenticate_inventory import permissions_required, get_jwt_user_id
from controllers.auth_controllers.handle_authenticate_post import handle_authenticate_post
from controllers.auth_controllers.handle_change_inventory_post import handle_change_inventory_post
from controllers.auth_controllers.handle_check_email_post import handle_check_email_post
from controllers.auth_controllers.handle_check_mobile_post import handle_check_mobile_post
from controllers.auth_controllers.handle_email_auth_send_otp_post import handle_email_auth_send_otp_post
from controllers.auth_controllers.handle_email_auth_verify_otp_post import handle_email_auth_verify_otp_post
from controllers.auth_controllers.handle_renew_user_token_post import handle_renew_user_token_post

================================================================================

Filename: controllers/auth_controllers/authenticate_inventory.py
Content:
from flask import request
from flask_restx import abort
from flask_jwt_extended import get_jwt_identity
from functools import wraps
from models.users import get_user_by_id
from utils import fetch_jwt_additional_claim


def authenticate_inventory(user_id, inventory_id):
    if not inventory_id:
        # return the error response if no inventory id provided
        return {
            "success": False,
            "error_code": 404,
            "message": "No inventory ID provided!"
        }

    # get the user info
    user = get_user_by_id(user_id)

    if not user:
        # return the error response if user not found
        return {
            "success": False,
            "error_code": 404,
            "message": "User not found!"
        }

    # iterate over all the inventories that user actually contains and
    # verify if the inventory id belongs to the user or not
    for inventory_key in user['inventoryInfo']:
        # if the user owns the inventory, return
        if inventory_key == inventory_id:
            return {
                "success": True,
                "user": user
            }

    # return the error if the user does not own the inventory
    return {
        "success": False,
        "error_code": 401,
        "message": "Unauthorized InventoryId or Invalid Permissions!"
    }


def permissions_required():
    def decorator(f):
        @wraps(f)
        def wrapper(*args, **kwargs):
            # Extract the jwt_token from the request header
            auth_header = request.headers.get('Authorization')
            if not auth_header:
                abort(401, "Unauthorized!")

            token = auth_header.split()[1]  # removing the 'Bearer' from the token

            # Extract inventory_id and user_id from the token
            inventory_id = get_jwt_identity()
            user_id = fetch_jwt_additional_claim(
                token=token,
                claim="userId"
            )

            # Call the authentication logic
            auth_response = authenticate_inventory(
                user_id=user_id,
                inventory_id=inventory_id
            )

            # Check if authentication was successful or not
            if not auth_response["success"]:
                abort(
                    code=auth_response["error_code"],
                    message=auth_response["message"]
                )

            # If authorized, proceed with the request
            return f(*args, **kwargs)
        return wrapper
    return decorator


# get the user id from the additional claims from the jwt token
def get_jwt_user_id():
    # Extract the jwt_token from the request header
    auth_header = request.headers.get('Authorization')
    token = auth_header.split()[1]  # removing the 'Bearer' from the token
    # fetch user_id from the additional claims
    user_id = fetch_jwt_additional_claim(
        token=token,
        claim="userId"
    )
    # return the user_id
    return user_id


================================================================================

Filename: controllers/auth_controllers/handle_authenticate_post.py
Content:
from models.users import get_user_id, get_user_by_id
from handlers.response_data_handlers import http_error, http_success
from utils import decode_token, create_user_access_token, create_user_refresh_token


def handle_authenticate_post(validated_data):
    # All data is already validated and sanitized
    token = validated_data['token']
    provider = validated_data['provider']  # ventory/google

    # decode the token based on the provider
    decoded_token = decode_token(token=token, provider=provider)

    # check if token decoded successfully or not
    if not decoded_token:
        return http_error.error_400(message="Invalid Token or Provider!")

    # check if user already exists or not
    phone_number = decoded_token.get("phone_number", None)
    email = decoded_token.get("email", None)

    # get the user id using either phone_number or email_id
    user_id = get_user_id(mobile=phone_number, email=email)

    if user_id:
        # get user info from database
        user = get_user_by_id(user_id=user_id)

        # generate JWT user_access_token & user_refresh_token
        user_access_token = create_user_access_token(user_id=user_id)
        user_refresh_token = create_user_refresh_token(user_id=user_id)

        # return the response with user record and user_access_token
        return http_success.success_200(
            data={
                "user": user,
                "user_access_token": f"Bearer {user_access_token}",
                "user_refresh_token": f"Bearer {user_refresh_token}",
            },
            message="User successfully authenticated!"
        )

    # abort if user not found
    return http_error.error_404(message="User not found!")


================================================================================

Filename: controllers/auth_controllers/handle_change_inventory_post.py
Content:
from models.users import get_user_by_id
from handlers.response_data_handlers import http_error, http_success
from utils import create_inventory_access_token


def handle_change_inventory_post(user_id, validated_data):
    # All data is already validated and sanitized
    inventory_id = validated_data['inventoryId']

    # get user info from database
    user = get_user_by_id(user_id=user_id)

    if not user:
        # abort if user not found
        return http_error.error_404(message="Error: User not found!")

    if not inventory_id:
        # abort if inventory_id not provided
        return http_error.error_400(message="Inventory Id not provided!")

    # remove the other inventory_ids from the user and keep the information of requested inventory_id only
    requested_inventory = user['inventoryInfo'].get(inventory_id, None)

    if requested_inventory is None:
        return http_error.error_404(message="Error: Inventory not found!")

    # generate JWT inventory_access_token
    access_token = create_inventory_access_token(
        inventory_id=inventory_id,
        user_id=user_id
    )

    # return the response
    return http_success.success_200(
        message="Inventory Changed Successfully!",
        data={
            "currentInventory": inventory_id,
            "inventory_access_token": f'Bearer {access_token}',
        }
    )

================================================================================

Filename: controllers/auth_controllers/handle_check_email_post.py
Content:
from models.users import get_user_id
from handlers.response_data_handlers import http_error


def handle_check_email_post(validated_data):
    # Get email id from the request
    email = validated_data["email"]

    # check if user with requested mobile already exists or not
    user_id = get_user_id(
        mobile=None,
        email=email.lower() if email else email
    )

    if user_id:
        # user found
        return http_error.error_409(message="User already exists!")

    # user not found
    return http_error.error_404(message="User not found!")

================================================================================

Filename: controllers/auth_controllers/handle_check_mobile_post.py
Content:
from models.users import get_user_id
from handlers.response_data_handlers import http_error


def handle_check_mobile_post(validated_data):
    # Get mobile number from the request
    mobile = validated_data["mobile"]

    # check if user with requested mobile already exists or not
    user_id = get_user_id(
        mobile=mobile,
        email=None
    )

    if user_id:
        # user found
        return http_error.error_409(message="User already exists!")

    # user not found
    return http_error.error_404(message="User not found!")


================================================================================

Filename: controllers/auth_controllers/handle_email_auth_send_otp_post.py
Content:
from random import randint
from mailer import send_email
from handlers.response_data_handlers import http_error, http_success
from utils import create_session_token, validate_session_token


def handle_email_auth_send_otp_post(validated_data):
    # All data is already validated and sanitized
    email = validated_data['email']

    # Generate a random 6 digit OTP
    otp = str(randint(100000, 999999))

    # send the email
    send_mail_response = send_email(
        email=email,
        subject="OTP for Ventory",
        mail_code="MAIL_101",
        otp=otp
    )

    if send_mail_response["success"]:
        # create a session token and pack otp and email
        session_token = create_session_token(
            data={
                "otp": otp,
                "email": email.lower()
            }
        )

        # return the response
        return http_success.success_200(
            data={"session_token": session_token},
            message="OTP sent successfully!"
        )

    # abort if failed to send the email
    return http_error.error_500(message="Mailbox Unavailable!")

================================================================================

Filename: controllers/auth_controllers/handle_email_auth_verify_otp_post.py
Content:
from flask_jwt_extended import create_access_token
from datetime import timedelta
from handlers.response_data_handlers import http_error, http_success
from utils import create_session_token, validate_session_token


def handle_email_auth_verify_otp_post(validated_data):
    # All data is already validated and sanitized
    otp = validated_data['otp']
    session_token = validated_data['session_token']

    # validate and decrypt session token
    session_token_data = validate_session_token(session_token)

    if session_token_data:
        sent_otp = session_token_data.get('otp')
        linked_email = session_token_data.get('email')

        if otp == sent_otp:
            # generate JWT ventory_token for email
            ventory_token = create_access_token(
                identity="ventory.in",
                additional_claims={'email': linked_email},
                expires_delta=timedelta(minutes=30)
            )

            # return the response
            return http_success.success_200(
                data={"ventory_token": ventory_token},
                message="OTP successfully verified!"
            )

        # abort if the provided otp is incorrect
        return http_error.error_401(message="Incorrect OTP!")

    # abort if the session_token is invalid
    return http_error.error_401(message="Invalid Session Token!")

================================================================================

Filename: controllers/auth_controllers/handle_renew_user_token_post.py
Content:
from models.users import get_user_by_id
from handlers.response_data_handlers import http_error, http_success
from utils import create_user_access_token


# function to get user_access_token in exchange for user_refresh_token
def handle_renew_user_token_post(user_id):
    # get the user record from the database
    user = get_user_by_id(user_id=user_id)

    if user:
        # generate JWT access token
        user_access_token = create_user_access_token(user_id=user_id)

        return http_success.success_200(
            data={
                "user": user,
                "user_access_token": f'Bearer {user_access_token}'
            },
            message="Authentication Successful!"
        )

    # abort if user not found
    return http_error.error_404(message="User not found!")


================================================================================

Filename: controllers/inventory_controller.py
Content:
from controllers import auth_controllers
from flask import abort
from models import inventory as inventory_db
from utils import resolve_category_name, is_item_id_exists


def handle_delete_item(request, user_id, inventory_id):
    request_data = request.get_json()
    # authenticate
    auth_controllers.handle_authenticate_inventory(inventory_id, user_id)
    # get the category id and item id from the request
    category = request_data.get('category')
    item_id = request_data.get('itemId')
    # check if item_id and category are present or not
    if category and item_id:
        # get the inventory
        inventory = inventory_db.getInventory(inventory_id)
        # resolve the category name received
        category_id = resolve_category_name(inventory, category)
        if not category_id:
            abort(422, "Invalid Category Id!")
        # get the image id
        image_id = inventory[category_id]["items"][item_id]["imageId"]
        # delete the existing image if any
        inventory_db.deleteImage(inventory_id, category_id, item_id, image_id)
        # request firebase: delete the item
        response = inventory_db.deleteItem(inventory_id, category_id, item_id, inventory)
        if response:
            return {
                "message": "Item Successfully Deleted!",
                "itemId": item_id
            }
        abort(500, "Error: Database operation failed!")
    abort(400, "Error: Either inventory_id or category_id or item_id field not provided!")


def handle_add_image(request, user_id, inventory_id):
    # authenticate
    auth_controllers.handle_authenticate_inventory(inventory_id, user_id)

    # get the category id, item id, image file part from the request
    category = request.form.get('category')
    item_id = request.form.get('itemId')
    item_image = request.files['image']

    if item_id and item_image:
        # get the inventory
        inventory = inventory_db.getInventory(inventory_id)

        # resolve the category name received
        for category_key in inventory["order"]:
            if inventory[category_key]["categoryName"] == category:
                category_id = category_key
                break
        else:
            abort(422, "Invalid Category Id!")

        # get the image id
        image_id = inventory[category_id]["items"][item_id]["imageId"]

        # delete previous image if any
        if image_id:
            inventory_db.deleteImage(inventory_id, category_id, item_id, image_id)

        # update the imageUrl in firestore
        response = inventory_db.addImage(inventory_id, category_id, item_id, item_image)

        if response:
            return {
                "message": "Item Image Successfully Uploaded!"
            }

        abort(400, "Error: Updating image url request failed!")

    abort(400, 'Error: No file part!')


def handle_delete_image(request, user_id, inventory_id):
    # authenticate
    auth_controllers.handle_authenticate_inventory(inventory_id, user_id)
    # get the category id and item id from the request
    request_data = request.get_json()
    category = request_data.get('category')
    item_id = request_data.get('itemId')

    if item_id:
        # get the inventory
        inventory = inventory_db.getInventory(inventory_id)

        # resolve the category name received
        for category_key in inventory["order"]:
            if inventory[category_key]["categoryName"] == category:
                category_id = category_key
                break
        else:
            abort(422, "Invalid Category Id!")

        # get the image id
        image_id = inventory[category_id]["items"][item_id]["imageId"]

        # delete the existing image if any
        response = inventory_db.deleteImage(inventory_id, category_id, item_id, image_id)

        if response:
            return {
                "message": "Item Image Successfully Deleted!"
            }

        abort(400, "Error: Updating image url request failed!")

    abort(400, 'Error: No file part!')


# -----ADD AN IMAGE TO THE INVENTORY MORE IMAGES------------------------------------------------------------------------
def handle_add_more_image(request, user_id, inventory_id):
    # authenticate
    auth_controllers.handle_authenticate_inventory(inventory_id, user_id)
    # get the image file part and image index from the request
    image = request.files['image']
    image_index = request.form.get('imageIndex')
    # check if image_index is of type 'int', if true, then convert image_index to int else abort the request
    image_index = int(image_index) if image_index.isdigit() else abort(400, 'Error: Invalid image index!')
    if image and (0 <= image_index < 10):
        # get the inventory
        inventory = inventory_db.getInventory(inventory_id)
        # get the image id
        image_id = inventory["info"]["moreImages"][image_index]
        # delete previous image if any
        if image_id == '':
            # upload the image on the firebase
            response = inventory_db.addMoreImage(image, inventory_id, inventory["info"]["moreImages"], image_index)
            # return the response
            if response:
                return {"message": "Image Successfully Uploaded!"}
        # error: database error
        abort(400, "Error: image upload failed!")
    # error: file part not provided
    abort(400, 'Error: No file part or Invalid image index!')


# -----DELETE AN IMAGE FROM THE INVENTORY MORE IMAGES-------------------------------------------------------------------
def handle_delete_more_image(request, user_id, inventory_id):
    # authenticate
    auth_controllers.handle_authenticate_inventory(inventory_id, user_id)
    # get the image index from the request
    request_data = request.get_json()
    image_index = request_data.get('imageIndex')
    if 0 <= image_index < 10:
        # get the inventory
        inventory = inventory_db.getInventory(inventory_id)
        # get the image id
        image_id = inventory["info"]["moreImages"][image_index]
        # delete the image
        if image_id:
            response = inventory_db.deleteMoreImage(inventory_id, image_id, inventory["info"]["moreImages"],
                                                    image_index)
            if response:
                return {"message": "Image Successfully Deleted!"}
        else:
            return {"message": "Image Successfully Deleted!"}
        # error: database error
        abort(400, "Error: image url update request failed!")
    # error: file part not provided
    abort(400, 'Error: Invalid image index!')


def handle_update_item_availability(request, user_id, inventory_id):
    # authenticate
    auth_controllers.handle_authenticate_inventory(inventory_id, user_id)
    # get the category id and item id from the request
    request_data = request.get_json()
    category = request_data.get('category')
    item_id = request_data.get('itemId')
    availability = request_data.get('availability')
    if category and item_id:
        # get the inventory
        inventory = inventory_db.getInventory(inventory_id)
        # resolve the category name received
        for category_key in inventory["order"]:
            if inventory[category_key]["categoryName"] == category:
                category_id = category_key
                break
        else:
            abort(422, "Invalid Category Id!")
        # request firebase: delete the item
        response = inventory_db.updateItemAvailability(inventory_id, category_id, item_id, availability)
        # return the response
        if response:
            return {
                "message": "Item Availability Successfully Updated!",
                "newAvailability": availability
            }

        abort(500, "Error: Database operation failed!")

    abort(400, "Error: Either inventory_id or category_id or item_id field not provided!")


================================================================================

Filename: controllers/inventory_controllers/__init__.py
Content:
from controllers.inventory_controllers.handle_add_image import handle_add_image
from controllers.inventory_controllers.handle_add_item import handle_add_item
from controllers.inventory_controllers.handle_edit_item import handle_edit_item

================================================================================

Filename: controllers/inventory_controllers/handle_add_image.py
Content:
import uuid
from flask_restx import abort
from models import inventory as inventory_db
from models.inventory import update_item, add_image_to_storage, delete_image_from_storage
from utils import inventory_utils


def handle_add_image(processed_image, validated_data, inventory_id):
    """
    Handle adding an image to an inventory item

    Args:
        validated_data (dict): Validated request data
        processed_image (bytes): Processed and validated image file
        inventory_id (str): ID of the inventory
    """
    # Get the validated fields
    item_category = validated_data['category']
    item_id = validated_data['itemId']
    image_index = validated_data['imageIndex']

    # Get the inventory from the database
    inventory = inventory_db.getInventory(inventory_id)
    if not inventory:
        abort(404, "Inventory not found")

    # Resolve the category name
    category_id = inventory_utils.resolve_category_name(inventory, item_category)
    if not category_id:
        abort(400, "Invalid item category provided")

    # Check if the item exists in the given category
    if not inventory_utils.is_item_id_exists(inventory, category_id, item_id):
        abort(400, "Invalid item ID provided")

    image_ids = inventory[category_id]["items"][item_id]["imageIds"]
    prev_image_id = image_ids[image_index]

    # Generate a new uuid
    image_id = str(uuid.uuid4())

    # Upload the image in storage
    image_upload_response = add_image_to_storage(
        inventory_id=inventory_id,
        image_id=image_id,
        image_file=processed_image
    )

    if not image_upload_response["success"]:
        abort(500, "Failed to upload image")

    # Update the image_ids list
    image_ids[image_index] = image_id

    # Update item in database
    db_response = update_item(
        inventory_id=inventory_id,
        category_id=category_id,
        item_id=item_id,
        item_info={"imageIds": image_ids}
    )

    if db_response["success"]:
        if prev_image_id:
            # delete the old image
            delete_response = delete_image_from_storage(inventory_id, prev_image_id)
            if not delete_response["success"]:
                abort(500, delete_response["message"])

        return {
            "message": "Item successfully updated",
            "itemId": item_id,
            "categoryId": category_id,
            "imageIds": image_ids
        }
    else:
        if image_id:
            # delete the newly added image
            delete_response = delete_image_from_storage(inventory_id, image_id)
            if not delete_response["success"]:
                abort(500, delete_response["message"])

        abort(500, "Failed to update item in database")


================================================================================

Filename: controllers/inventory_controllers/handle_add_item.py
Content:
from handlers.response_data_handlers import http_error
from models import inventory as inventory_db
from models.inventory import create_item
from utils import inventory_utils


def handle_add_item(validated_data, inventory_id):

    # All data is already validated and sanitized
    sanitized_item_category = validated_data['category'].upper()
    item_info_sanitized = validated_data['item']

    # get the inventory from the database
    inventory = inventory_db.getInventory(inventory_id)
    # resolve the category name received
    category_id = inventory_utils.resolve_category_name(inventory, sanitized_item_category)

    if not category_id:
        # create a new category and get the category_id name if not exists
        response = inventory_db.createNewCategory(inventory_id, sanitized_item_category)
        category_id = response["category_id"]

    if category_id:
        # store item in database
        db_response = create_item(
            inventory_id=inventory_id,
            category_id=category_id,
            item_info=item_info_sanitized
        )

        if db_response["success"]:
            return {
                "message": "Item Successfully added!",
                "itemId": db_response["item_id"],
                "categoryId": category_id
            }

    return http_error.error_500("Internal Server Error")


================================================================================

Filename: controllers/inventory_controllers/handle_edit_item.py
Content:
from handlers.default_data_handlers import get_default_category_info
from handlers.response_data_handlers import http_error
from models import inventory as inventory_db
from models.inventory import update_item
from utils import inventory_utils


def handle_edit_item(validated_data, inventory_id):

    # Extract validated data
    item_info = validated_data.get("item")
    item_category = validated_data.get("category").upper()
    item_id = validated_data.get("itemId")

    # Get the inventory from the database
    inventory = inventory_db.getInventory(inventory_id)

    # Resolve the category name received
    category_id = inventory_utils.resolve_category_name(inventory, item_category)

    if not category_id:
        return http_error.error_400(message="Invalid Item Category Provided!")

    # Check if the item exists in the given category
    if not inventory_utils.is_item_id_exists(inventory, category_id, item_id):
        return http_error.error_400(message="Invalid Item Id Provided!")

    # Update item in database
    db_response = update_item(
        inventory_id=inventory_id,
        category_id=category_id,
        item_id=item_id,
        item_info=item_info
    )

    if db_response["success"]:
        return {
            "message": "Item Successfully Updated!",
            "itemId": item_id,
            "categoryId": category_id
        }

    return http_error.error_500(message="Internal Server Error")


================================================================================

Filename: controllers/user_controllers/__init__.py
Content:
from controllers.user_controllers.handle_user_post import handle_user_post
from controllers.user_controllers.handle_inventory_post import handle_inventory_post
from controllers.user_controllers.handle_inventory_put import handle_inventory_put

================================================================================

Filename: controllers/user_controllers/handle_inventory_post.py
Content:
from models.inventory import create_inventory, delete_inventory
from models.users import create_inventory_info
from handlers.response_data_handlers import http_error, http_success
from utils import create_inventory_access_token


def handle_inventory_post(user_id, validated_data):
    """
    This function handles creating the
        1) new inventory document inside inventory collection
        2):
        (a) updating the user inventoryInfo field with new inventory doc_id &
        (b) adding information about inventory corresponding to the new inventory doc_id created
        inside the user document.
    """
    # create a new inventory
    inventory_creation_response = create_inventory()

    # check if a new inventory is created successfully or not
    if not inventory_creation_response["success"]:
        return http_error.error_500(message="Error Creating Inventory")

    # fetch the inventory id from the inventory creation response
    inventory_id = inventory_creation_response["inventory_id"]

    # updating the inventory info in the user document
    update_result = create_inventory_info(user_id, inventory_id, validated_data)

    if update_result["success"]:
        # return the success response
        return http_success.success_201(
            data={
                "inventory_access_token": create_inventory_access_token(
                    inventory_id=inventory_id,
                    user_id=user_id
                ),
                "inventory": inventory_creation_response["inventory"]
            },
            message="Inventory Created Successfully!"
        )
    else:
        # if unable to update inventory info delete the created inventory
        delete_inventory(inventory_id)

        # return the error response
        return http_error.error_500(message="Failed to update inventory info!")


================================================================================

Filename: controllers/user_controllers/handle_inventory_put.py
Content:
from handlers.response_data_handlers import http_error, http_success
from models.users import update_inventory_info


def handle_inventory_put(user_id, inventory_id, validated_data):
    """This function handles updating the inventoryInfo field inside the user document."""

    # Update the database with only the sanitized fields
    update_result = update_inventory_info(user_id, inventory_id, validated_data)

    # Check if the update was successful
    if update_result["success"]:
        # return the success response
        return http_success.success_200(
            message="Inventory information updated successfully!",
            data={}
        )

    else:
        # Handle the case where the update fails due to any reason (e.g., database error)
        return http_error.error_500(message="Failed to update shop information. Please try again.")


================================================================================

Filename: controllers/user_controllers/handle_user_post.py
Content:
from models.users import create_user, get_user_id
from handlers.response_data_handlers import http_error, http_success
from utils import decode_token, create_user_access_token, create_user_refresh_token


def handle_user_post(validated_data):
    # All data is already validated and sanitized
    display_name = validated_data['displayName']
    token = validated_data['token']
    provider = validated_data['provider']  # ventory/google

    # decode the token based on the provider
    decoded_token = decode_token(token=token, provider=provider)

    # check if token decoded successfully or not
    if not decoded_token:
        return http_error.error_400(message="Invalid Token or Provider!")

    # get the credential (mobile or email)
    mobile = decoded_token.get('phone_number')
    email = decoded_token.get('email')

    # fetch the user id based on any one of the credential
    user_id = get_user_id(mobile=mobile, email=email)

    if not user_id:
        # if user not exists, create a new user
        # create user record
        user = {
            "displayName": display_name,
            "mobile": mobile,
            "email": email,
            "inventoryInfo": {}
        }

        # add user record in the database
        db_response = create_user(user)

        if db_response["success"]:
            # get the user, user_id from the database response
            user = db_response["user"]
            user_id = db_response["user_id"]

            # generate JWT user_access_token
            user_access_token = create_user_access_token(user_id=user_id)
            user_refresh_token = create_user_refresh_token(user_id=user_id)

            # return the response with user record and user_access_token
            return http_success.success_201(
                data={
                    "user": user,
                    "user_access_token": f"Bearer {user_access_token}",
                    "user_refresh_token": f"Bearer {user_refresh_token}"
                },
                message="User successfully created!"
            )

        return http_error.error_500(message="Internal Server Error!")

    # if user already exists (return conflict)
    return http_error.error_409(message="User already exists!")

================================================================================

Filename: defaults/__init__.py
Content:
from models import db
from utils import get_data_from_json_file


# refs
DEFAULTS_REF = db.collection("defaults")


def run_defaults():
    global DEFAULTS_REF

    # -----1| DEFAULTS/SHOP_CATEGORIES----------------------------------------------------------------------------------
    default_categories_info = get_data_from_json_file("defaults/default_categories.json")
    DEFAULTS_REF.document('default_categories').set(default_categories_info)
    print("1| defaults/default_categories created")

    # -----2| DEFAULTS/DEFAULT_PRICE------------------------------------------------------------------------------------
    default_price_info = get_data_from_json_file("defaults/default_price.json")
    DEFAULTS_REF.document('default_prices').set(default_price_info)
    print("2| defaults/default_prices created")

    # -----3| DEFAULTS/DEFAULT_TAGS-------------------------------------------------------------------------------------
    default_tags_info = get_data_from_json_file("defaults/default_tags.json")
    DEFAULTS_REF.document('default_tags').set(default_tags_info)
    print("3| defaults/default_tags created")


================================================================================

Filename: defaults/default_categories.json
Content:
{
  "Consumables": {
    "information": "N-D-V-T-I-NI",
    "values": [
      "Food and beverages",
      "Snacks and confectionery",
      "Cleaning supplies",
      "Personal care products",
      "Medications and supplements",
      "other"
    ]
  },
  "Household": {
    "information": "N-D-V-T",
    "values": [
      "Furniture",
      "Kitchenware",
      "Bedding and linens",
      "Cleaning tools",
      "Home decor",
      "Lighting",
      "other"
    ]
  },
  "Electronics": {
    "information": "N-D-V-T",
    "values": [
      "Computers and accessories",
      "Mobile phones and tablets",
      "Home appliances",
      "Audio and video equipment",
      "Gaming consoles and accessories",
      "Cameras and photography equipment",
      "Wearable technology",
      "other"
    ]
  },
  "Clothing and Accessories": {
    "information": "N-D-V-T",
    "values": [
      "Men's clothing",
      "Women's clothing",
      "Children's clothing",
      "Shoes",
      "Jewelry and watches",
      "Handbags and wallets",
      "Hats, scarves, and gloves",
      "other"
    ]
  },
  "Automotive": {
    "information": "N-D-V-T",
    "values": [
      "Car parts and accessories",
      "Car care products",
      "Tires and wheels",
      "Motorcycle parts",
      "Car electronics",
      "Car safety and security",
      "other"
    ]
  },
  "Outdoor and Garden": {
    "information": "N-D-V-T",
    "values": [
      "Gardening tools and supplies",
      "Outdoor furniture",
      "Barbecue and grilling",
      "Camping gear",
      "Sports equipment",
      "Lawn care",
      "Outdoor lighting",
      "other"
    ]
  },
  "Toys and Games": {
    "information": "N-D-V-T",
    "values": [
      "Board games",
      "Puzzles",
      "Action figures",
      "Educational toys",
      "Video games",
      "Dolls and plush toys",
      "Remote control toys",
      "other"
    ]
  },
  "Office Supplies": {
    "information": "N-D-V-T",
    "values": [
      "Stationery",
      "Printers and ink",
      "Office furniture",
      "Storage solutions",
      "Writing instruments",
      "Paper products",
      "Calendars and planners",
      "other"
    ]
  },
  "Health and Fitness": {
    "information": "N-D-V-T",
    "values": [
      "Exercise equipment",
      "Health supplements",
      "Yoga and meditation supplies",
      "Fitness apparel",
      "Personal care devices",
      "Health monitors",
      "Medical equipment",
      "other"
    ]
  },
  "Books and Media": {
    "information": "N-D-V-T",
    "values": [
      "Fiction and non-fiction books",
      "Magazines",
      "Music CDs and vinyl",
      "Movies and TV series",
      "Educational materials",
      "E-books",
      "Audiobooks",
      "other"
    ]
  },
  "Pet Supplies": {
    "information": "N-D-V-T-I",
    "values": [
      "Pet food",
      "Pet toys",
      "Pet grooming products",
      "Pet health products",
      "Pet bedding and carriers",
      "Aquarium supplies",
      "Pet training aids",
      "other"
    ]
  },
  "Beauty and Personal Care": {
    "information": "N-D-V-T-I",
    "values": [
      "Skincare products",
      "Haircare products",
      "Makeup",
      "Fragrances",
      "Bath and body products",
      "Men's grooming products",
      "Beauty tools",
      "other"
    ]
  },
  "Crafts and Hobbies": {
    "information": "N-D-V-T",
    "values": [
      "Art supplies",
      "Sewing and knitting supplies",
      "Model building",
      "Scrapbooking",
      "Musical instruments",
      "Collectibles",
      "DIY kits",
      "other"
    ]
  },
  "Travel and Luggage": {
    "information": "N-D-V-T",
    "values": [
      "Suitcases",
      "Travel accessories",
      "Backpacks",
      "Travel organizers",
      "Travel pillows and blankets",
      "Luggage tags and locks",
      "other"
    ]
  },
  "Baby and Kids": {
    "information": "N-D-V-T",
    "values": [
      "Baby clothing",
      "Baby gear (strollers, car seats, etc.)",
      "Baby feeding products",
      "Baby toys",
      "Nursery furniture",
      "Diapers and wipes",
      "Baby health and safety",
      "other"
    ]
  },
  "Home Improvement": {
    "information": "N-D-V-T",
    "values": [
      "Tools and hardware",
      "Paint and wallpaper",
      "Plumbing supplies",
      "Electrical supplies",
      "Building materials",
      "Home security",
      "other"
    ]
  },
  "Musical Instruments": {
    "information": "N-D-V-T",
    "values": [
      "Guitars and accessories",
      "Keyboards and pianos",
      "Drums and percussion",
      "Brass and woodwind instruments",
      "String instruments",
      "Music production equipment",
      "other"
    ]
  },
  "Grocery": {
    "information": "N-D-V-T-I-NI",
    "values": [
      "Fresh produce",
      "Meat and seafood",
      "Dairy products",
      "Bakery items",
      "Pantry staples",
      "Frozen foods",
      "Beverages",
      "other"
    ]
  },
  "Stationery and Gifts": {
    "information": "N-D-V-T",
    "values": [
      "Greeting cards",
      "Gift wrap and bags",
      "Party supplies",
      "Candles",
      "Novelties and souvenirs",
      "Photo albums and frames",
      "other"
    ]
  },
  "Luxury Items": {
    "information": "N-D-V-T",
    "values": [
      "Designer clothing and accessories",
      "High-end electronics",
      "Fine jewelry",
      "Luxury watches",
      "Art and antiques",
      "Collectible wines and spirits",
      "other"
    ]
  }
}

================================================================================

Filename: defaults/default_price.json
Content:
{
  "prices_list": [
    "FREE",
    "ASK"
  ],
  "currencies_accepted": [
    "₹"
  ]
}

================================================================================

Filename: defaults/default_tags.json
Content:
{
  "VEG": "green",
  "VEGAN": "Green",
  "NON VEG": "tomato",
  "CONTAINS EGG": "Brown",
  "BEST SELLER": "goldenrod",
  "SALE": "Red",
  "NEW ARRIVAL": "#11998E",
  "CLEARANCE": "goldenrod",
  "LIMITED EDITION": "goldenrod",
  "POPULAR": "dodgerblue",
  "ORGANIC": "#33c58e",
  "HANDMADE": "Brown",
  "GLUTEN-FREE": "Green",
  "LOCAL": "#614385",
  "IMPORTED": "goldenrod",
  "ECO-FRIENDLY": "Green",
  "FAIR TRADE": "dodgerblue",
  "RECYCLED": "Gray",
  "LOW STOCK": "goldenrod",
  "HIGH DEMAND": "tomato",
  "SEASONAL": "goldenrod",
  "GIFT IDEA": "#FF5F6D",
  "CUSTOMIZABLE": "#614385"
}

================================================================================

Filename: handlers/__init__.py
Content:


================================================================================

Filename: handlers/default_data_handlers/get_default_category_info.py
Content:
from utils import get_data_from_json_file


DEFAULT_CATEGORIES_INFO = get_data_from_json_file("defaults/default_categories.json")


def get_category_info(category):
    global DEFAULT_CATEGORIES_INFO

    for _category, value in DEFAULT_CATEGORIES_INFO.items():
        if _category == category:
            return value["information"]

    return None


def get_default_shop_categories():
    global DEFAULT_CATEGORIES_INFO
    return list(DEFAULT_CATEGORIES_INFO.keys())


================================================================================

Filename: handlers/default_data_handlers/get_default_price_info.py
Content:
from utils import get_data_from_json_file


DEFAULT_PRICE_INFO = get_data_from_json_file("defaults/default_price.json")


def get_default_price_list():
    global DEFAULT_PRICE_INFO
    return DEFAULT_PRICE_INFO["prices_list"]


def get_accepted_currencies_list():
    global DEFAULT_PRICE_INFO
    return DEFAULT_PRICE_INFO["currencies_accepted"]


================================================================================

Filename: handlers/response_data_handlers/__init__.py
Content:
from .http_error import *
from .http_success import *
from .respond_json import *


================================================================================

Filename: handlers/response_data_handlers/http_error.py
Content:
def error_400(message=None):
    return {
        "error": "Missing Values",
        "message": message
    }, 400


def error_401(message=None):
    return {
        "error": "Unauthorized",
        "message": message
    }, 401


def error_404(message=None):
    return {
        "error": "Not Found",
        "message": message
    }, 404


def error_409(message=None):
    return {
        "error": "Conflict",
        "message": message
    }, 409


def error_500(message=None):
    return {
        "error": "Internal Server Error",
        "message": message
    }, 500


================================================================================

Filename: handlers/response_data_handlers/http_success.py
Content:
def success_200(data, message="OK!"):
    data.update({'message': message})
    return data, 200

def success_201(data, message="Created!"):
    data.update({'message': message})
    return data, 200


================================================================================

Filename: handlers/response_data_handlers/respond_json.py
Content:
import json
from datetime import datetime
from flask import make_response
from google.api_core.datetime_helpers import DatetimeWithNanoseconds


class FirebaseJSONEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, DatetimeWithNanoseconds):  # Explicitly check for Firebase timestamp type
            return obj.isoformat()
        elif hasattr(obj, '_seconds') and hasattr(obj, '_nanoseconds'):
            return datetime.fromtimestamp(obj._seconds).isoformat()
        elif isinstance(obj, datetime):
            return obj.isoformat()
        return super().default(obj)


# Configure Flask-RestX to use custom encoder
def output_json(data, code, headers=None):
    dumped = json.dumps(data, cls=FirebaseJSONEncoder)
    response = make_response(dumped, code)
    response.headers.extend(headers or {})
    response.headers['Content-Type'] = 'application/json'
    return response


================================================================================

Filename: k8s/certificate.yaml
Content:
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: request-ventory-certificate
  namespace: request-ventory-namespace
spec:
  secretName: request-ventory-certificate-secret
  issuerRef:
    name: letsencrypt-prod
    kind: ClusterIssuer
  commonName: request.ventory.in
  dnsNames:
    - request.ventory.in


================================================================================

Filename: k8s/cluster-issuer.yaml
Content:
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-prod
spec:
  acme:
    server: https://acme-v02.api.letsencrypt.org/directory
    email: grigtechnologiespvtltd@gmail.com
    privateKeySecretRef:
      name: letsencrypt-prod
    solvers:
    - http01:
        ingress:
          class: nginx


================================================================================

Filename: k8s/deployment.yaml
Content:
apiVersion: apps/v1
kind: Deployment
metadata:
  name: request-ventory-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: request-ventory
  template:
    metadata:
      labels:
        app: request-ventory
    spec:
      containers:
      - name: request-ventory
        image: grigtechnologies/request.ventory:latest
        imagePullPolicy: Always
        ports:
        - containerPort: 5000
      imagePullSecrets:
      - name: regcred
---
apiVersion: v1
kind: Service
metadata:
  name: request-ventory-service
spec:
  type: ClusterIP
  ports:
    - port: 80
      targetPort: 5000
  selector:
    app: request-ventory


================================================================================

Filename: k8s/ingress.yaml
Content:
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: request-ventory-ingress
  namespace: request-ventory-namespace
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    cert-manager.io/cluster-issuer: letsencrypt-prod
    acme.cert-manager.io/http01-ingress-class: "nginx"
spec:
  ingressClassName: nginx
  rules:
  - host: request.ventory.in
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: request-ventory-service
            port:
              number: 80
  tls:
  - hosts:
    - request.ventory.in
    secretName: request-ventory-certificate-secret


================================================================================

Filename: kustomization.yaml
Content:
resources:
  - k8s/certificate.yaml
  - k8s/cluster-issuer.yaml
  - k8s/ingress.yaml
  - k8s/deployment.yaml

================================================================================

Filename: logs/__init__.py
Content:
import os
import time
import uuid
import logging
from logging.handlers import RotatingFileHandler
from flask import request, g


# Logging setup
LOGS_DIRECTORY = 'logs'
if not os.path.exists(LOGS_DIRECTORY):
    os.makedirs(LOGS_DIRECTORY)


def get_logger(namespace, route):
    global LOGS_DIRECTORY

    logger_name = f"{namespace}.{route}"
    logger = logging.getLogger(logger_name)
    logger.setLevel(logging.INFO)

    # Check if the logger already has handlers to prevent duplicates
    if not logger.hasHandlers():
        # Create directory for this namespace if it doesn't exist
        namespace_dir = os.path.join(LOGS_DIRECTORY, namespace)
        if not os.path.exists(namespace_dir):
            os.makedirs(namespace_dir)

        # Create a rotating file handler for this logger
        handler = RotatingFileHandler(
            os.path.join(namespace_dir, f"{route}.log"),
            maxBytes=10485760,  # 10MB
            backupCount=10
        )
        handler.setLevel(logging.INFO)

        # Create a logging format
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)

        # Add the handler to the logger
        logger.addHandler(handler)

    return logger


def LOGGING(app):
    # Middleware to log requests and responses
    @app.before_request
    def before_request():
        g.start_time = time.time()
        g.request_id = str(uuid.uuid4())

        # Determine which logger to use based on the request path
        path_parts = request.path.strip('/').split('/')
        namespace = path_parts[0] if path_parts else 'main'
        route = path_parts[1] if len(path_parts) > 1 else 'index'
        g.logger = get_logger(namespace, route)

        g.logger.info(f"Request started: {request.method} {request.path} - ID: {g.request_id}")

    @app.after_request
    def after_request(response):
        diff = time.time() - g.start_time
        g.logger.info(f"Request completed: {response.status_code} in {diff:.2f}s - ID: {g.request_id}")
        return response

    # Error handler
    @app.errorhandler(Exception)
    def handle_exception(e):
        g.logger.exception(f"An error occurred: {str(e)} - ID: {g.request_id}")
        return {'message': 'An internal error occurred'}, 500

================================================================================

Filename: mailer/README.md
Content:
# Mailer Documentation

This directory handles all email-related functionalities, Each email template and functionality is organized using a coding scheme to ensure consistency and clarity.

### Naming Conventions
All email templates are named using the following structure: MAIL_<code_name>

## Code Series

### 100 Series: `/auth` Route
The 100 series is dedicated to emails related to the `/auth` route, primarily dealing with user authentication and verification processes.

- **Code 101:** Sending OTP (One-Time Password) to customers for authentication.


================================================================================

Filename: mailer/__init__.py
Content:
from flask import current_app, render_template
from flask_mail import Mail, Message


def send_email(email, subject, mail_code, **kwargs):
    mail = Mail(current_app)

    # if kwargs are present, then pass those kwargs to render_template
    html = render_template(
        template_name_or_list=f'{mail_code}.html',
        **kwargs
    )

    msg = Message(
        subject=subject,
        sender=tuple(current_app.config['MAIL_DEFAULT_SENDER']),
        recipients=[email],
        html=html
    )

    try:
        mail.send(msg)
        return {"success": True}

    except Exception as e:
        print(e)
        return {
            "success": True,
            "error": str(e)
        }


================================================================================

Filename: mailer/templates/MAIL_101.html
Content:
<!DOCTYPE html>

<html lang="en">
    <head>
        <style>
            p b {
                background-color: black;
                color: white;
            }
        </style>
    </head>
    <body>
        <p><b>{{otp}}</b> is your verification code for Ventory account.</p>
        <p>If you didn’t ask for OTP, you can ignore this email.</p>
        <p>Thanks,</p>
        <p>team ventory</p>
    </body>
</html>

================================================================================

Filename: models/__init__.py
Content:
import firebase_admin
from firebase_admin import credentials
from firebase_admin import firestore

# Initialize Firebase Admin SDK
cred = credentials.Certificate('./configs/firebase_adminSDK.json')
firebase_admin.initialize_app(cred, {
    'storageBucket': 'scanwithventory-82f53.appspot.com'
})

# Get a Firestore client
db = firestore.client()


================================================================================

Filename: models/inventory.py
Content:
from firebase_admin import storage
from google.cloud.firestore_v1.transforms import ArrayUnion, DELETE_FIELD
from datetime import datetime
import uuid
import re
from models import db


# Reference to the "inventory" collection
inventory_ref = db.collection('inventory')


def getInventory(inventory_id):
    # get the inventory document from the database
    inventory_doc_ref = inventory_ref.document(inventory_id)
    inventory_doc = inventory_doc_ref.get()

    return inventory_doc.to_dict() if inventory_doc.exists else None


def createNewCategory(inventory_id, category_name):
    # Generate a new uuid for category and update the document
    category_id = re.sub(r'-', '_', str(uuid.uuid4()))

    update_result = inventory_ref.document(inventory_id).update({
        f'{category_id}.categoryName': category_name.upper(),
        f'{category_id}.items': {'order': []},
        f'order': ArrayUnion([category_id]),
        'updatedAt': datetime.now()
    })

    return {"category_id": category_id} if update_result.update_time else None


def deleteCategory(inventory_id, category_id, inventory):
    # delete the category id from the category order array
    new_category_order_array = []
    for _category_id_ in inventory['order']:
        if _category_id_ != category_id:
            new_category_order_array.append(_category_id_)

    # delete the category and update the document
    update_result = inventory_ref.document(inventory_id).update({
        f'{category_id}': DELETE_FIELD,
        'order': new_category_order_array,
        'updatedAt': datetime.now()
    })

    return True if update_result.update_time else None


def createItem(inventory_id, category_id, item):
    # Generate a new uuid for item and update the document
    item_id = re.sub(r'-', '_', str(uuid.uuid4()))

    # add image id to item
    item['imageId'] = ''

    update_result = inventory_ref.document(inventory_id).update({
        f'{category_id}.items.{item_id}': item,
        f'{category_id}.items.order': ArrayUnion([item_id]),
        'updatedAt': datetime.now()
    })

    return {"item_id": item_id} if update_result.update_time else None


def deleteItem(inventory_id, category_id, item_id, inventory):
    # delete the item id from the item order array
    new_item_order_array = []
    for _item_id_ in inventory[category_id]['items']['order']:
        if _item_id_ != item_id:
            new_item_order_array.append(_item_id_)

    # delete category if no item remaining in that category
    if not new_item_order_array:
        response = deleteCategory(inventory_id, category_id, inventory)

        if response:
            return True

    # delete the item and update the document
    update_result = inventory_ref.document(inventory_id).update({
        f'{category_id}.items.{item_id}': DELETE_FIELD,
        f'{category_id}.items.order': new_item_order_array,
        'updatedAt': datetime.now()
    })

    return True if update_result.update_time else None


def addImage(inventory_id, category_id, item_id, item_image):
    # Generate a new uuid for item image and update the document
    image_id = str(uuid.uuid4())

    image_name = f"{inventory_id}/{image_id}"
    bucket = storage.bucket()
    blob = bucket.blob(image_name)
    blob.upload_from_string(item_image.read(), content_type=item_image.content_type)
    blob.make_public()

    # delete the item and update the document
    update_result = inventory_ref.document(inventory_id).update({
        f'{category_id}.items.{item_id}.imageId': image_id,
        'updatedAt': datetime.now()
    })

    return True if update_result.update_time else None


def deleteImage(inventory_id, category_id, item_id, image_id):
    bucket = storage.bucket()
    blob = bucket.blob(f"{inventory_id}/{image_id}")
    blob.delete() if blob.exists() else None

    # delete the item and update the document
    update_result = inventory_ref.document(inventory_id).update({
        f'{category_id}.items.{item_id}.imageId': '',
        'updatedAt': datetime.now()
    })

    return True if update_result.update_time else None


def updateItemAvailability(inventory_id, category_id, item_id, availability):
    update_result = inventory_ref.document(inventory_id).update({
        f'{category_id}.items.{item_id}.availability': availability,
        'updatedAt': datetime.now()
    })

    return True if update_result.update_time else None


def addMoreImage(image, inventory_id, more_image_ids_array, image_index):
    # Generate a new uuid for item image
    image_id = str(uuid.uuid4())
    # upload the image to the firebase bucket storage
    image_name = f"{inventory_id}/info/moreImages/{image_id}"
    bucket = storage.bucket()
    blob = bucket.blob(image_name)
    blob.upload_from_string(image.read(), content_type=image.content_type)
    blob.make_public()
    # mark the image_id to the firestore document
    more_image_ids_array[image_index] = image_id
    update_result = inventory_ref.document(inventory_id).update({
        'info.moreImages': more_image_ids_array,
        'updatedAt': datetime.now()
    })
    # return the response
    return True if update_result.update_time else None


def deleteMoreImage(inventory_id, image_id, more_image_ids_array, image_index):
    bucket = storage.bucket()
    blob = bucket.blob(f"{inventory_id}/info/moreImages/{image_id}")
    blob.delete() if blob.exists() else None

    # delete the item_id and update the document
    more_image_ids_array[image_index] = ''
    update_result = inventory_ref.document(inventory_id).update({
        'info.moreImages': more_image_ids_array,
        'updatedAt': datetime.now()
    })

    return True if update_result.update_time else None


================================================================================

Filename: models/inventory/__init__.py
Content:
from models import db
from models.inventory.add_image_to_storage import *
from models.inventory.create_category import create_category
from models.inventory.create_inventory import create_inventory as _create_inventory
from models.inventory.create_item import create_item as _create_item
from models.inventory.delete_category import delete_category
from models.inventory.delete_image_from_storage import *
from models.inventory.delete_inventory import delete_inventory as _delete_inventory
from models.inventory.update_item import update_item as _update_item

INVENTORY_REF = db.collection('inventory')


def create_item(inventory_id, category_id, item_info):
    global INVENTORY_REF
    return _create_item(
        inventory_ref=INVENTORY_REF,
        inventory_id=inventory_id,
        category_id=category_id,
        item_info=item_info
    )


def update_item(inventory_id, category_id, item_id, item_info):
    global INVENTORY_REF
    return _update_item(
        inventory_ref=INVENTORY_REF,
        inventory_id=inventory_id,
        category_id=category_id,
        item_id=item_id,
        item_info=item_info
    )


def getInventory(inventory_id):
    global INVENTORY_REF
    # get the inventory document from the database
    inventory_doc_ref = INVENTORY_REF.document(inventory_id)
    inventory_doc = inventory_doc_ref.get()

    return inventory_doc.to_dict() if inventory_doc.exists else None


def create_inventory():
    global INVENTORY_REF
    return _create_inventory(inventory_ref=INVENTORY_REF)


def delete_inventory(inventory_id):
    global INVENTORY_REF
    return _delete_inventory(
        inventory_ref=INVENTORY_REF,
        inventory_id=inventory_id
    )


def createNewCategory(inventory_id, category_name):
    global INVENTORY_REF
    return create_category(
        inventory_ref=INVENTORY_REF,
        inventory_id=inventory_id,
        category_name=category_name
    )


def deleteCategory(inventory_id, category_id, inventory):
    global INVENTORY_REF
    return delete_category(
        inventory_ref=INVENTORY_REF,
        inventory_id=inventory_id,
        category_id=category_id,
        inventory=inventory
    )


================================================================================

Filename: models/inventory/add_image_to_storage.py
Content:
import logging
import firebase_admin
from firebase_admin import storage


def add_image_to_storage(inventory_id, image_id, image_file):
    """
    Uploads an image to Firebase Storage.

    Args:
    inventory_id (str): The ID of the inventory.
    image_id (str): The ID of the image.
    image_file (io.BytesIO): The image file as a BytesIO object.

    Returns:
    dict: A dictionary containing 'success' (bool) and 'message' (str) keys.
    """
    try:
        # Ensure Firebase app is initialized
        if not firebase_admin._apps:
            firebase_admin.initialize_app()

        # Get a reference to the storage service
        bucket = storage.bucket()

        # Create the full path for the image
        image_path = f"{inventory_id}/{image_id}"

        # Create a blob and upload the file's content
        blob = bucket.blob(image_path)

        # Determine content type
        content_type = getattr(image_file, 'content_type', 'image/png')

        # Upload the file
        blob.upload_from_string(
            image_file.getvalue(),
            content_type=content_type
        )

        # Make the blob publicly accessible
        blob.make_public()

        # Get the public URL
        public_url = blob.public_url

        return {
            "success": True,
            "message": "Image uploaded successfully",
            "public_url": public_url
        }

    except firebase_admin.exceptions.FirebaseError as e:
        logging.error(f"Firebase Error: {str(e)}")
        return {
            "success": False,
            "message": f"Failed to upload image: {str(e)}"
        }
    except Exception as e:
        logging.error(f"Unexpected error: {str(e)}")
        return {
            "success": False,
            "message": "An unexpected error occurred while uploading the image"
        }


================================================================================

Filename: models/inventory/create_category.py
Content:
import re
import uuid
from datetime import datetime
from google.cloud.firestore_v1 import ArrayUnion


def create_category(inventory_id, category_name, inventory_ref):
    # Generate a new uuid for category and update the document
    category_id = re.sub(r'-', '_', str(uuid.uuid4()))

    update_result = inventory_ref.document(inventory_id).update({
        f'{category_id}.categoryName': category_name.upper(),
        f'{category_id}.items': {'order': []},
        f'order': ArrayUnion([category_id]),
        'updatedAt': datetime.now()
    })

    return {"category_id": category_id} if update_result.update_time else None


================================================================================

Filename: models/inventory/create_inventory.py
Content:
from datetime import datetime, timezone


def create_inventory(inventory_ref):
    # create a new inventory in the collection
    inventory = {
        'order': [],
        'createdAt': datetime.now(timezone.utc),
        'updatedAt': datetime.now(timezone.utc)
    }

    doc_ref = inventory_ref.add(inventory)

    # Return result
    if doc_ref:
        return {
            "success": True,
            "inventory_id": doc_ref[1].id,
            "inventory": inventory
        }

    return {"success": False}


================================================================================

Filename: models/inventory/create_item.py
Content:
from google.cloud.firestore_v1.transforms import ArrayUnion
from datetime import datetime
from utils.uuid_utils import generate_uuid


def create_item(inventory_ref, inventory_id, category_id, item_info):
    # Generate uuid for the new item
    item_id = generate_uuid()

    # initialize image id field form the new item
    item_info['imageIds'] = ["" for _ in range(10)]

    # update the user's inventory document with new item
    update_result = inventory_ref.document(inventory_id).update({
        f'{category_id}.items.{item_id}': item_info,
        f'{category_id}.items.order': ArrayUnion([item_id]),
        'updatedAt': datetime.now()
    })

    # return the db response
    if update_result.update_time:
        return {
            "success": True,
            "item_id": item_id
        }

    return {
        "success": False
    }


================================================================================

Filename: models/inventory/delete_category.py
Content:
from datetime import datetime

from google.cloud.firestore_v1 import DELETE_FIELD


def delete_category(inventory_id, category_id, inventory, inventory_ref):
    # delete the category id from the category order array
    new_category_order_array = []
    for _category_id_ in inventory['order']:
        if _category_id_ != category_id:
            new_category_order_array.append(_category_id_)

    # delete the category and update the document
    update_result = inventory_ref.document(inventory_id).update({
        f'{category_id}': DELETE_FIELD,
        'order': new_category_order_array,
        'updatedAt': datetime.now()
    })

    return True if update_result.update_time else None


================================================================================

Filename: models/inventory/delete_image_from_storage.py
Content:
import logging
import firebase_admin
from firebase_admin import storage


def delete_image_from_storage(inventory_id, image_id):
    """
    Deletes an image from Firebase Storage.

    Args:
    inventory_id (str): The ID of the inventory.
    image_id (str): The ID of the image to delete.

    Returns:
    dict: A dictionary containing 'success' (bool) and 'message' (str) keys.
    """
    try:
        # Ensure Firebase app is initialized
        if not firebase_admin._apps:
            firebase_admin.initialize_app()

        # Get a reference to the storage service
        bucket = storage.bucket()

        # Create the full path for the image
        image_path = f"{inventory_id}/{image_id}"

        # Get the blob
        blob = bucket.blob(image_path)

        # Delete the blob
        blob.delete()

        return {
            "success": True,
            "message": f"Image {image_id} deleted successfully from inventory {inventory_id}"
        }

    except firebase_admin.exceptions.FirebaseError as e:
        logging.error(f"Firebase Error: {str(e)}")
        return {
            "success": False,
            "message": f"Failed to delete image: {str(e)}"
        }
    except Exception as e:
        logging.error(f"Unexpected error: {str(e)}")
        return {
            "success": False,
            "message": "An unexpected error occurred while deleting the image"
        }


================================================================================

Filename: models/inventory/delete_inventory.py
Content:
def delete_inventory(inventory_ref, inventory_id):
    try:
        inventory_ref.document(inventory_id).delete()
        return {"success": True}
    except Exception:
        return {"success": False}


================================================================================

Filename: models/inventory/update_item.py
Content:
from datetime import datetime


def update_item(inventory_ref, inventory_id, category_id, item_id, item_info):
    # Prepare the update data
    update_item_info = {'updatedAt': datetime.now()}

    # Only update the fields that are provided in item_info
    for field, value in item_info.items():
        update_item_info[f'{category_id}.items.{item_id}.{field}'] = value

    # Update the user's inventory document with edited item
    update_result = inventory_ref.document(inventory_id).update(update_item_info)

    # Return the db response
    if update_result.update_time:
        return {"success": True}

    return {"success": False}


================================================================================

Filename: models/user.py
Content:
from google.cloud.firestore_v1.base_query import FieldFilter
from google.cloud.firestore_v1.transforms import ArrayUnion
from models import db


# Reference to the "users" collection
users_ref = db.collection('users')


def createUser(user_record):
    # add a user into the database
    doc_ref = users_ref.add(user_record)
    return doc_ref[1].id


def getUserCredentials(mobile, email):
    if email:
        query = users_ref.where(filter=FieldFilter('email', '==', email))
    else:
        query = users_ref.where(filter=FieldFilter('mobile', '==', mobile))

    # get only the user password from the database
    query = query.select(['password'])
    query_results = next(query.stream(), None)

    if query_results:
        return {
            'id': query_results.id,
            'password': query_results.get('password')
        }

    return None


def getUserFromId(doc_id):
    # get the user record from the database
    user = users_ref.document(doc_id).get().to_dict()

    for inventory_id, inventory in user['inventory'].items():
        # convert shopLocation which of type GeoPoint to a normal list with [latitude, longitude]
        shop_location = user['inventory'][inventory_id].get('shopLocation')
        if shop_location:
            user['inventory'][inventory_id]['shopLocation'] = [shop_location.latitude, shop_location.longitude]

    return user if user else None


def getUserInventoryReference(doc_id):
    # get only the user inventory from the database
    inventory_snapshot = users_ref.document(doc_id).get(field_paths=['inventory'])

    if inventory_snapshot:
        inventory_doc_ref = inventory_snapshot.get('inventory')

        return inventory_doc_ref

    return None


def addInventoryToUser(shop_name, inventory_id, user_id):
    update_result = users_ref.document(user_id).update({
        f'inventory': ArrayUnion([{
            "shopName": shop_name,
            "inventoryId": inventory_id
        }])
    })

    return True if update_result.update_time else None


================================================================================

Filename: models/users/__init__.py
Content:
from models import db
from models.users.create_inventory_info import create_inventory_info as _create_inventory_info
from models.users.update_inventory_info import update_inventory_info as _update_inventory_info
from models.users.create_user import create_user as _create_user
from models.users.get_user_id import get_user_id as _get_user_id
from models.users.get_user_by_id import get_user_by_id as _get_user_by_id


USERS_REF = db.collection('users')


def create_inventory_info(user_id, inventory_id, registration_data):
    global USERS_REF
    return _create_inventory_info(
        users_ref=USERS_REF,
        user_id=user_id,
        inventory_id=inventory_id,
        data=registration_data
    )

def update_inventory_info(user_id, inventory_id, data):
    global USERS_REF
    return _update_inventory_info(
        users_ref=USERS_REF,
        user_id=user_id,
        inventory_id=inventory_id,
        data=data
    )

def create_user(user):
    global USERS_REF
    return _create_user(
        users_ref=USERS_REF,
        user=user
    )

def get_user_id(mobile, email):
    global USERS_REF
    return _get_user_id(
        users_ref=USERS_REF,
        mobile=mobile,
        email=email
    )

def get_user_by_id(user_id):
    global USERS_REF
    return _get_user_by_id(
        users_ref=USERS_REF,
        user_id=user_id
    )


================================================================================

Filename: models/users/create_inventory_info.py
Content:
from datetime import datetime, timezone


def create_inventory_info(users_ref, user_id, inventory_id, data):
    inventory_info = {
        'createdAt': datetime.now(timezone.utc),
        'updatedAt': datetime.now(timezone.utc)
    }
    inventory_info.update(data)

    update_result = users_ref.document(user_id).update({
        f'inventoryInfo.{inventory_id}': inventory_info
    })

    # Return result
    if update_result.update_time:
        return {"success": True}

    return {"success": False}


================================================================================

Filename: models/users/create_user.py
Content:
from datetime import datetime, timezone


def create_user(users_ref, user):
    user_info = {
        'createdAt': datetime.now(timezone.utc),
        'updatedAt': datetime.now(timezone.utc)
    }
    user_info.update(user)

    # add the user record to database
    doc_ref = users_ref.add(user_info)

    # Return result
    if doc_ref:
        return {
            "success": True,
            "user_id": doc_ref[1].id,
            "user": user_info
        }

    return {"success": False}


================================================================================

Filename: models/users/get_user_by_id.py
Content:
def get_user_by_id(users_ref, user_id):
    # get the user record from the database
    user = users_ref.document(user_id).get().to_dict()

    return user if user else None


================================================================================

Filename: models/users/get_user_id.py
Content:
from google.cloud.firestore_v1.base_query import FieldFilter


def get_user_id(users_ref, mobile, email):
    if mobile:
        query = users_ref.where(filter=FieldFilter('mobile', '==', mobile))
    elif email:
        query = users_ref.where(filter=FieldFilter('email', '==', email))
    else:
        return None

    # get only the document.id from the database
    query_results = query.stream()
    document = next(query_results, None)

    if document:
        return document.id

    return None


================================================================================

Filename: models/users/update_inventory_info.py
Content:
from datetime import datetime, timezone


def update_inventory_info(users_ref, user_id, inventory_id, data):
    # Prepare the update data with the updated timestamp
    update_data = {f'inventoryInfo.{inventory_id}.{key}': value for key, value in data.items()}
    update_data[f'inventoryInfo.{inventory_id}.updatedAt'] = datetime.now(timezone.utc)

    # Update the database with only the provided fields
    update_result = users_ref.document(user_id).update(update_data)

    # Return result
    if update_result.update_time:
        return {"success": True}

    return {"success": False}


================================================================================

Filename: requirements.txt
Content:
aniso8601==9.0.1
async-timeout==4.0.3
attrs==23.1.0
blinker==1.6.2
CacheControl==0.13.1
cachelib==0.10.2
cachetools==5.3.1
certifi==2023.7.22
cffi==1.17.0
charset-normalizer==3.2.0
click==8.1.7
cryptography==41.0.7
exceptiongroup==1.1.3
firebase-admin==6.2.0
Flask==2.3.3
Flask-Cors==4.0.0
Flask-JWT-Extended==4.5.2
Flask-Mail==0.9.1
flask-restx==1.3.0
google-api-core==2.11.1
google-api-python-client==2.97.0
google-auth==2.22.0
google-auth-httplib2==0.1.0
google-cloud-core==2.3.3
google-cloud-firestore==2.11.1
google-cloud-storage==2.10.0
google-crc32c==1.5.0
google-resumable-media==2.5.0
googleapis-common-protos==1.60.0
grpcio==1.57.0
grpcio-status==1.57.0
gunicorn==23.0.0
h11==0.14.0
httplib2==0.22.0
idna==3.4
importlib_resources==6.4.5
itsdangerous==2.1.2
Jinja2==3.1.2
jsonschema==4.23.0
jsonschema-specifications==2023.12.1
MarkupSafe==2.1.3
msgpack==1.0.5
outcome==1.2.0
packaging==24.1
phonenumbers==8.13.20
pillow==10.4.0
proto-plus==1.22.3
protobuf==4.24.2
pyasn1==0.5.0
pyasn1-modules==0.3.0
pycparser==2.21
PyJWT==2.8.0
pyparsing==3.1.1
PySocks==1.7.1
pytz==2024.2
referencing==0.35.1
requests==2.31.0
rpds-py==0.20.0
rsa==4.9
selenium==4.14.0
six==1.16.0
sniffio==1.3.0
sortedcontainers==2.4.0
trio==0.22.2
trio-websocket==0.11.1
uritemplate==4.1.1
urllib3==1.26.18
Werkzeug==2.3.7
wsproto==1.2.0
python-dotenv
sqlalchemy
psycopg2

================================================================================

Filename: restx/__init__.py
Content:
import os
from flask_restx import Api
from handlers.response_data_handlers import respond_json
from utils import get_data_from_json_file, generate_uuid

# Allow documentation in dev only
dev = os.environ.get("dev", False)
doc = False
if dev:
    print("dev mode")
    doc = "/api-docs"

# Initialize Flask-RESTX API
RESTX = Api(
    **get_data_from_json_file("configs/restx_config.json"),
    default_swagger_filename=f"{generate_uuid()}.json",
    doc=doc
)

# response middleware
RESTX.representations = {
    'application/json': respond_json.output_json
}


================================================================================

Filename: restx/configs/inventory/item(post).json
Content:
{
  "item": {
    "nested": {
      "name": {
        "validator": "get_sanitized_string",
        "required": true,
        "min_length": 1,
        "max_length": 30
      },
      "description": {
        "validator": "get_sanitized_string",
        "required": false,
        "min_length": 0,
        "max_length": 500
      },
      "variants": {
        "validator": "get_sanitized_item_variants",
        "required": true
      },
      "tags": {
        "validator": "get_sanitized_item_tags",
        "required": false
      },
      "ingredients": {
        "validator": "get_sanitized_item_ingredients",
        "required": false
      },
      "nutritionalInfo": {
        "validator": "get_sanitized_item_nutritional_info",
        "required": false
      }
    }
  },
  "category": {
    "validator": "get_sanitized_string",
    "required": true,
    "min_length": 1,
    "max_length": 10
  }
}



================================================================================

Filename: restx/configs/inventory/item(put).json
Content:
{
  "item": {
    "nested": {
      "name": {
      "validator": "get_sanitized_string",
      "required": false,
      "min_length": 1,
      "max_length": 30
    },
    "description": {
      "validator": "get_sanitized_string",
      "required": false,
      "min_length": 0,
      "max_length": 500
    },
    "variants": {
      "validator": "get_sanitized_item_variants",
      "required": false
    },
    "tags": {
      "validator": "get_sanitized_item_tags",
      "required": false
    },
      "ingredients": {
        "validator": "get_sanitized_item_ingredients",
        "required": false
      },
      "nutritionalInfo": {
        "validator": "get_sanitized_item_nutritional_info",
        "required": false
      }
    }
  },
  "category": {
    "validator": "get_sanitized_string",
    "required": true,
    "min_length": 1,
    "max_length": 10
  },
  "itemId": {
    "validator": "pass",
    "required": true
  }
}



================================================================================

Filename: restx/configs/inventory/item-image(put).json
Content:
{
  "category": {
    "validator": "get_sanitized_string",
    "required": true,
    "min_length": 1,
    "max_length": 10
  },
  "itemId": {
    "required": true,
    "validator": "pass"
  },
  "imageIndex": {
    "required": true,
    "validator": "get_sanitized_index",
    "low": 0,
    "high": 9
  }
}

================================================================================

Filename: restx/docs/__init__.py
Content:
from restx.docs import (
    auth,
    inventory,
    user
)

================================================================================

Filename: restx/docs/auth/__init__.py
Content:
from restx.docs.auth.authenticate import post_authenticate_doc
from restx.docs.auth.change_inventory import post_change_inventory_doc
from restx.docs.auth.email_auth import post_email_auth_send_otp_doc, post_email_auth_verify_otp_doc
from restx.docs.auth.identity_existence import post_check_email_doc, post_check_mobile_doc
from restx.docs.auth.renew_user_token import post_renew_user_token_doc

================================================================================

Filename: restx/docs/auth/authenticate.py
Content:
post_authenticate_doc = {
    "description": 'Get user_access_token in exchange for ventory/google token',
    "responses": {
        400: "Invalid token or provider",
        404: "User not found",
        200: "Success"
    }
}


================================================================================

Filename: restx/docs/auth/change_inventory.py
Content:
post_change_inventory_doc = {
    "security": 'Bearer',
    "description": 'Get inventory_access_token in exchange for user_access_token',
    "responses": {
        400: "Validation Error",
        404: "User not found",
        200: "Success"
    }
}


================================================================================

Filename: restx/docs/auth/email_auth.py
Content:
post_email_auth_send_otp_doc = {
    "description": 'Send authentication OTP to an email id',
    "responses": {
        500: "Mailbox Unavailable",
        400: "Validation Error",
        200: "Success"
    }
}

post_email_auth_verify_otp_doc = {
    "description": 'Verify authentication OTP sent via email id',
    "responses": {
        200: "Success",
        400: "Validation Error",
        401: "Authentication Error"
    }
}




================================================================================

Filename: restx/docs/auth/identity_existence.py
Content:
post_check_email_doc = {
    "description": 'Check if email is registered with ventory or not',
    "responses": {
        409: "ID exists",
        404: "ID does not exists"
    }
}

post_check_mobile_doc = {
    "description": 'Check if mobile is registered with ventory or not',
    "responses": {
        409: "ID exists",
        404: "ID does not exists"
    }
}

================================================================================

Filename: restx/docs/auth/renew_user_token.py
Content:
post_renew_user_token_doc = {
    "security": 'Bearer',
    "description": 'Get user_access_token in exchange for user_refresh_token',
    "responses": {
        409: "ID exists",
        404: "ID does not exists"
    }
}

================================================================================

Filename: restx/docs/inventory/__init__.py
Content:
from restx.docs.inventory.image import post_image_doc
from restx.docs.inventory.item import post_item_doc, put_item_doc


================================================================================

Filename: restx/docs/inventory/image.py
Content:
post_image_doc = {
    "security": 'Bearer',
    "description": "Add a new image to an item",
    "responses": {
        200: 'Image added successfully',
        400: 'Validation Error',
        401: 'Unauthorized'
    }
}

================================================================================

Filename: restx/docs/inventory/item.py
Content:
post_item_doc = {
    "security": 'Bearer',
    "description": "Add a new item to the inventory",
    "responses": {
        200: 'Item added successfully',
        400: 'Validation Error',
        401: 'Unauthorized'
    }
}

put_item_doc = {
    "security": 'Bearer',
    "description": "Edit an existing item in the inventory",
    "responses": {
        200: 'Item edited successfully',
        400: 'Validation Error',
        401: 'Unauthorized'
    }
}


================================================================================

Filename: restx/docs/user/__init__.py
Content:
from restx.docs.user.inventory import post_inventory_doc, put_inventory_doc
from restx.docs.user.user import post_user_doc

================================================================================

Filename: restx/docs/user/inventory.py
Content:
post_inventory_doc = {
    "security": 'Bearer',
    "description": "Create new inventory and add inventory info to the user",
    "responses": {
        200: "Inventory and inventory info created successfully",
        400: "Validation Error",
        401: "Unauthorized",
        500: "Internal Server Error"
    }
}


put_inventory_doc = {
    "security": "Bearer",
    "description": "Update inventory info of the user",
    "responses": {
        200: "Inventory info updated successfully",
        400: "Validation Error",
        401: "Unauthorized",
        500: "Internal Server Error"
    }
}

================================================================================

Filename: restx/docs/user/user.py
Content:
post_user_doc = {
    "description": 'Sign up a new user',
    "responses": {
        400: "Invalid token or provider",
        500: "Internal Server Error",
        409: "User already exists",
        200: "User successfully created"
    }
}


================================================================================

Filename: restx/models/__init__.py
Content:
from restx.models import (
    auth,
    inventory,
    user
)

================================================================================

Filename: restx/models/auth/__init__.py
Content:
from utils import parse_semi_restx_dict_to_restx_model
from restx.models.auth.post_authenticate_model import post_authenticate_semi_restx_dict
from restx.models.auth.post_change_inventory_model import post_change_inventory_semi_restx_dict
from restx.models.auth.post_check_email_model import post_check_email_semi_restx_dict
from restx.models.auth.post_check_mobile_model import post_check_mobile_semi_restx_dict
from restx.models.auth.post_email_auth_send_otp_model import post_email_auth_send_otp_semi_restx_dict
from restx.models.auth.post_email_auth_verify_otp_model import post_email_auth_verify_otp_semi_restx_dict


# parse semi restx dicts to restx models
post_authenticate_model = parse_semi_restx_dict_to_restx_model(post_authenticate_semi_restx_dict)
post_change_inventory_model = parse_semi_restx_dict_to_restx_model(post_change_inventory_semi_restx_dict)
post_check_email_model = parse_semi_restx_dict_to_restx_model(post_check_email_semi_restx_dict)
post_check_mobile_model = parse_semi_restx_dict_to_restx_model(post_check_mobile_semi_restx_dict)
post_email_auth_send_otp_model = parse_semi_restx_dict_to_restx_model(post_email_auth_send_otp_semi_restx_dict)
post_email_auth_verify_otp_model = parse_semi_restx_dict_to_restx_model(post_email_auth_verify_otp_semi_restx_dict)

================================================================================

Filename: restx/models/auth/post_authenticate_model.py
Content:
post_authenticate_semi_restx_dict = {
    "model_name": "[POST] /auth/authenticate",
    "fields": [
        {
            "field_name": "token",
            "field_type": "string",
            "required": True,
            "example": "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
            "description": """ventory_token or google_token""",
        },
        {
            "field_name": "provider",
            "field_type": "string",
            "required": True,
            "example": "ventory",
            "description": """ventory/google""",
        }
    ]
}


================================================================================

Filename: restx/models/auth/post_change_inventory_model.py
Content:
post_change_inventory_semi_restx_dict = {
    "model_name": "[POST] /auth/change-inventory",
    "fields": [
        {
            "field_name": "inventoryId",
            "field_type": "string",
            "required": True,
            "example": "xxxxxxxxxxxxxxxxxxxx",
            "description": """Valid Inventory ID""",
        }
    ]
}


================================================================================

Filename: restx/models/auth/post_check_email_model.py
Content:
post_check_email_semi_restx_dict = {
    "model_name": "[POST] /auth/check-email",
    "fields": [
        {
            "field_name": "email",
            "field_type": "string",
            "required": True,
            "validator": "validate_email",
            "pattern": r"^[a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$",
            "example": "user@example.com",
            "description": """Valid Email Address without (+) character""",
        }
    ]
}


================================================================================

Filename: restx/models/auth/post_check_mobile_model.py
Content:
post_check_mobile_semi_restx_dict = {
    "model_name": "[POST] /auth/check-mobile",
    "fields": [
        {
            "field_name": "mobile",
            "field_type": "string",
            "required": True,
            "validator": "validate_mobile",
            "pattern": r"\+\d{12}",
            "example": "+919876543210",
            "description": """Valid mobile number with country code""",
        }
    ]
}


================================================================================

Filename: restx/models/auth/post_email_auth_send_otp_model.py
Content:
post_email_auth_send_otp_semi_restx_dict = {
    "model_name": "[POST] /auth/email-auth-send-otp",
    "fields": [
        {
            "field_name": "email",
            "field_type": "string",
            "required": True,
            "validator": "validate_email",
            "pattern": r"^[a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$",
            "example": "user@example.com",
            "description": """Valid email address to send OTP to""",
        }
    ]
}


================================================================================

Filename: restx/models/auth/post_email_auth_verify_otp_model.py
Content:
post_email_auth_verify_otp_semi_restx_dict = {
    "model_name": "[POST] /auth/email-auth-verify-otp",
    "fields": [
        {
            "field_name": "otp",
            "field_type": "string",
            "required": True,
            "min_length": 6,
            "max_length": 6,
            "pattern": r"^\d{6}$",
            "example": "123456",
            "description": """Received OTP on the provided email address""",
        },
        {
            "field_name": "session_token",
            "field_type": "string",
            "required": True,
            "example": "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
            "description": """Session token received when OTP was sent""",
        }
    ]
}


================================================================================

Filename: restx/models/inventory/__init__.py
Content:
from restx.models.inventory.item_image_parser import *
from restx.models.inventory.post_item_model import post_item_semi_restx_dict
from restx.models.inventory.put_item_model import put_item_semi_restx_dict
from utils import parse_semi_restx_dict_to_restx_model

post_item_model = parse_semi_restx_dict_to_restx_model(post_item_semi_restx_dict)
put_item_model = parse_semi_restx_dict_to_restx_model(put_item_semi_restx_dict)


================================================================================

Filename: restx/models/inventory/ingredient_model.py
Content:
from flask_restx import fields
from restx import RESTX


ingredient_model = RESTX.model(
    name="Ingredient",
    model={
        "ingredientName": fields.String(description="Name of the ingredient", example="Starch"),
        "ingredientContent": fields.Float(description="Content of the ingredient", example=11.2),
        "unit": fields.String(description="Unit of the ingredient", example="gm")
    }
)

================================================================================

Filename: restx/models/inventory/item_image_parser.py
Content:
from restx import RESTX

post_image_parser = RESTX.parser()


post_image_parser.add_argument(
    name="category",
    type=str,
    required=True,
    location="form",
    help="The category of the item"
)

post_image_parser.add_argument(
    name="itemId",
    type=str,
    required=True,
    location="form",
    help="The Id of the item"
)

post_image_parser.add_argument(
    name="imageIndex",
    type=int,
    required=True,
    location="form",
    help="The index (0-9) at which to add/update the image"
)

post_image_parser.add_argument(
    name="image",
    type="file",
    required=True,
    location="files",
    help="The image file to be uploaded"
)


================================================================================

Filename: restx/models/inventory/item_model.py
Content:
from flask_restx import fields
from restx import RESTX
from restx.models.inventory.variant_model import variant_model
from restx.models.inventory.nutritional_info_model import nutritional_info_model
from restx.models.inventory.ingredient_model import ingredient_model


item_model = RESTX.model(
    name="Item",
    model={
        "name": fields.String(description="Name of the item"),
        "description": fields.String(description="Description of the item"),
        "variants": fields.List(
            description="List of variants of the item",
            cls_or_instance=fields.Nested(variant_model)
        ),
        "tags": fields.List(
            description="List of tags of the item",
            cls_or_instance=fields.String
        ),
        "ingredients": fields.List(
            description="List of ingredients of the item",
            cls_or_instance=fields.Nested(ingredient_model)
        ),
        "nutritionalInfo": fields.Nested(
            description="Nutritional information of the item",
            model=nutritional_info_model
        ),
    }
)


================================================================================

Filename: restx/models/inventory/nutritional_info_model.py
Content:
from flask_restx import fields
from grpc.experimental import experimental_api

from restx import RESTX


nutritional_info_value_model = RESTX.model(
    name="NutritionalValue",
    model={
        "name": fields.String(description="Name of the nutritional component", example="Protein"),
        "value": fields.Float(description="Value of the nutritional component", example=10),
        "unit": fields.String(description="Unit of the nutritional component", example="gm")
    }
)

nutritional_info_model = RESTX.model(
    name="NutritionalInfo",
    model={
        "information": fields.Nested(RESTX.model(
            name="Information",
            model={
                "servingSize": fields.Float(description="Serving size of the item", example=100),
                "measuringSize": fields.Float(description="Measuring size of the item", example=10),
                "unit": fields.String(
                    description="Unit of measurement of serving size and measuring size of the item",
                    example="gm"
                )
            }
        )),
        "values": fields.List(
            cls_or_instance=fields.Nested(nutritional_info_value_model),
            description="List of nutritional values of the item"
        )
    }
)

================================================================================

Filename: restx/models/inventory/post_item_model.py
Content:
from restx.models.inventory.item_model import item_model

post_item_semi_restx_dict = {
    "model_name": "[POST] /inventory/item",
    "fields": [
        {
            "field_name": "category",
            "field_type": "string",
            "required": True,
            "validator": "validate_alphanumeric_string",
            "min_length": 1,
            "max_length": 20,
            "example": "Burger",
            "description": """Category of the item"""
        },
        {
            "field_name": "item",
            "field_type": "nested",
            "required": True,
            "validator": "validate_item",
            "model": item_model,
            "description": """<Model for item>"""
        }
    ]
}


================================================================================

Filename: restx/models/inventory/put_item_model.py
Content:
from restx.models.inventory.item_model import item_model

put_item_semi_restx_dict = {
    "model_name": "[PUT] /inventory/item",
    "fields": [
        {
            "field_name": "category",
            "field_type": "string",
            "required": True,
            "validator": "validate_alphanumeric_string",
            "min_length": 1,
            "max_length": 10,
            "example": "Consumables",
            "description": """Category of the item"""
        },
        {
            "field_name": "itemId",
            "field_type": "string",
            "required": True,
            "example": "xxxxxxxxxxx-xxxxxxxxxxx-xxxxxxxxxx",
            "description": """ItemID of the item"""
        },
        {
            "field_name": "item",
            "field_type": "nested",
            "required": True,
            "validator": "validate_item",
            "model": item_model,
            "description": """<Model for item>"""
        }
    ]
}


================================================================================

Filename: restx/models/inventory/variant_model.py
Content:
from flask_restx import fields
from restx import RESTX


variant_model = RESTX.model(
    name="Variant",
    model={
        "variantName": fields.String(
            description="Name of the variant",
            required=True
        ),
        "variantPrice": fields.String(
            description="Price of the variant",
            required=True,
            example="₹ 123"
        )
    }
)

================================================================================

Filename: restx/models/user/__init__.py
Content:
from utils import parse_semi_restx_dict_to_restx_model
from restx.models.user.post_user_model import post_user_semi_restx_dict
from restx.models.user.post_inventory_model import post_inventory_semi_restx_dict
from restx.models.user.put_inventory_model import put_inventory_semi_restx_dict


# parse semi restx dicts to restx models
post_user_model = parse_semi_restx_dict_to_restx_model(post_user_semi_restx_dict)
post_inventory_model = parse_semi_restx_dict_to_restx_model(post_inventory_semi_restx_dict)
put_inventory_model = parse_semi_restx_dict_to_restx_model(put_inventory_semi_restx_dict)

================================================================================

Filename: restx/models/user/contact_detail_model.py
Content:
from flask_restx import fields
from restx import RESTX


contact_detail_model = RESTX.model(
    name="Contact Detail",
    model={
        "contactName": fields.String(
            required=True,
            min_length=1,
            max_length=30,
            example="John Doe"
        ),
        "email": fields.String(
            required=False,
            example="example@example.com",
        ),
        "mobile": fields.String(
            required=False,
            pattern=r'\+\d{12}',
            example="+919876543210"
        ),
        "isWPAvailable": fields.Boolean(
            required=False,
            example=False
        )
    }
)

================================================================================

Filename: restx/models/user/post_inventory_model.py
Content:
from flask_restx import fields
from restx.models.user.contact_detail_model import contact_detail_model
from restx.models.user.shop_timings_model import shop_timings_model


post_inventory_semi_restx_dict = {
    "model_name": "[POST] /user/inventory",
    "fields": [
        {
            "field_name": "shopName",
            "field_type": "string",
            "required": True,
            "validator": "validate_string",
            "min_length": 1,
            "max_length": 50,
            "example": "Demo Store",
            "description": """AlphaNumeric String"""
        },
        {
            "field_name": "shopOwnerName",
            "field_type": "string",
            "required": True,
            "validator": "validate_string",
            "min_length": 1,
            "max_length": 30,
            "example": "John Doe",
            "description": """AlphaNumeric String (Shop manager's name)"""
        },
        {
            "field_name": "shopCategory",
            "field_type": "string",
            "required": True,
            "validator": "validate_shop_category",
            "example": "Consumables",
            "description": """Shop Category from valid list of categories"""
        },
        {
            "field_name": "shopSubCategory",
            "field_type": "string",
            "required": False,
            "validator": "validate_string",
            "min_length": 0,
            "max_length": 50,
            "default": "",
            "example": "Grocery Store",
            "description": """AlphaNumeric String"""
        },
        {
            "field_name": "shopDescription",
            "field_type": "string",
            "required": False,
            "validator": "validate_string",
            "min_length": 0,
            "max_length": 200,
            "default": "",
            "example": "Example Description",
            "description": """String"""
        },
        {
            "field_name": "shopCoverImageUrl",
            "field_type": "url",
            "required": False,
            "validator": "validate_url",
            "min_length": 0,
            "max_length": 2048,
            "default": "",
            "example": "https://www.example.com/path/to/resource?query=parameter",
            "description": """Valid URL"""
        },
        {
            "field_name": "shopLogoImageUrl",
            "field_type": "url",
            "required": False,
            "validator": "validate_url",
            "min_length": 0,
            "max_length": 2048,
            "default": "",
            "example": "https://www.example.com/path/to/resource?query=parameter",
            "description": """Valid URL"""
        },
        {
            "field_name": "shopImages",
            "field_type": "list",
            "required": False,
            "validator": "validate_list_of_urls",
            "cls_or_instance": fields.Url(
                min_length=0,
                max_length=2048,
                description="""Valid URL"""
            ),
            "min_items": 0,
            "max_items": 10,
            "default": [],
            "example": [
                "https://www.example.com/path/to/resource1?query=parameter",
                "https://www.example.com/path/to/resource2?query=parameter"
            ],
            "description": """List of valid URLs"""
        },
        {
            "field_name": "shopThemeColors",
            "field_type": "list",
            "required": False,
            "validator": "validate_shop_theme_colors",
            "cls_or_instance": fields.String(pattern=r'^#(?:[0-9a-fA-F]{3}){1,2}$'),
            "min_items": 2,
            "max_items": 2,
            "default": ["#516395", "#2E8B57"],
            "example": ["#516395", "#2E8B57"],
            "description": """List ['primaryThemeColorHexCode', 'secondaryThemeColorHexCode']"""
        },
        {
            "field_name": "shopContactDetails",
            "field_type": "list",
            "required": False,
            "validator": "validate_shop_contact_details",
            "cls_or_instance": fields.Nested(model=contact_detail_model),
            "min_items": 0,
            "max_items": 10,
            "default": [],
            "example": [
                {
                    "contactName": "Arun Kumar",
                    "email": "user1@example.com",
                    "mobile": "+919876543210",
                    "isWPAvailable": False
                },
                {
                    "contactName": "Lakshmi Iyer",
                    "email": "user2@example.com",
                    "mobile": "+918765432109",
                    "isWPAvailable": True
                }
            ],
            "description": """List of <Contact Detail Model>s"""
        },
        {
            "field_name": "shopLocation",
            "field_type": "list",
            "required": False,
            "validator": "validate_geo_point",
            "cls_or_instance": fields.Float(),
            "min_items": 2,
            "max_items": 2,
            "default": [],
            "example": [17.3850, 78.4867],
            "description": """
                List of Float coordinates[Latitude, Longitude].
                Range of Latitude: [-90, 90],
                Range of longitude: [-180, 180].
            """
        },
        {
            "field_name": "shopTimings",
            "field_type": "nested",
            "required": True,
            "validator": "validate_shop_timings",
            "model": shop_timings_model,
            "description": """<Shop Timings Model>"""
        },
        {
            "field_name": "shopGSTNumber",
            "field_type": "string",
            "required": False,
            "validator": "validate_gst_number",
            "min_length": 15,
            "max_length": 15,
            "default": "",
            "pattern": r"^[0-9]{2}[A-Z]{5}[0-9]{4}[A-Z]{1}[1-9A-Z]{1}Z[0-9A-Z]{1}$",
            "example": "22AAAAA0000A1Z5",
            "description": """GST-IN number of the shop in valid format"""
        }
    ]
}

================================================================================

Filename: restx/models/user/post_user_model.py
Content:
post_user_semi_restx_dict = {
    "model_name": "[POST] /user/user",
    "fields": [
        {
            "field_name": "displayName",
            "field_type": "string",
            "required": True,
            "validator": "validate_string",
            "min_length": 1,
            "max_length": 30,
            "example": "John Doe",
            "description": """AlphaNumeric String (Account holder's name)"""
        },
        {
            "field_name": "token",
            "field_type": "string",
            "required": True,
            "example": "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
            "description": """ventory_token or google_token"""
        },
        {
            "field_name": "provider",
            "field_type": "string",
            "required": True,
            "example": "ventory",
            "description": """token provider (ventory/google)"""
        }
    ]
}

================================================================================

Filename: restx/models/user/put_inventory_model.py
Content:
from flask_restx import fields
from restx.models.user.contact_detail_model import contact_detail_model
from restx.models.user.shop_timings_model import shop_timings_model


put_inventory_semi_restx_dict = {
    "model_name": "[PUT] /user/inventory",
    "fields": [
        {
            "field_name": "shopName",
            "field_type": "string",
            "required": False,
            "validator": "validate_alphanumeric_string",
            "min_length": 1,
            "max_length": 50,
            "default": None,
            "example": "Demo Store",
            "description": """AlphaNumeric String"""
        },
        {
            "field_name": "shopOwnerName",
            "field_type": "string",
            "required": False,
            "validator": "validate_alphanumeric_string",
            "min_length": 1,
            "max_length": 30,
            "default": None,
            "example": "John Doe",
            "description": """AlphaNumeric String"""
        },
        {
            "field_name": "shopSubCategory",
            "field_type": "string",
            "required": False,
            "validator": "validate_alphanumeric_string",
            "min_length": 0,
            "max_length": 50,
            "default": None,
            "example": "Grocery Store",
            "description": """AlphaNumeric String"""
        },
        {
            "field_name": "shopDescription",
            "field_type": "string",
            "required": False,
            "validator": "validate_string",
            "min_length": 0,
            "max_length": 200,
            "default": None,
            "example": "Example Description",
            "description": """String"""
        },
        {
            "field_name": "shopCoverImageUrl",
            "field_type": "url",
            "required": False,
            "validator": "validate_url",
            "min_length": 0,
            "max_length": 2048,
            "default": None,
            "example": "https://www.example.com/path/to/resource?query=parameter",
            "description": """Valid URL"""
        },
        {
            "field_name": "shopLogoImageUrl",
            "field_type": "url",
            "required": False,
            "validator": "validate_url",
            "min_length": 0,
            "max_length": 2048,
            "default": None,
            "example": "https://www.example.com/path/to/resource?query=parameter",
            "description": """Valid URL"""
        },
        {
            "field_name": "shopImages",
            "field_type": "list",
            "required": False,
            "validator": "validate_urls_list",
            "cls_or_instance": fields.Url(
                min_length=0,
                max_length=2048,
                description="""Valid URL"""
            ),
            "min_items": 0,
            "max_items": 10,
            "default": None,
            "example": [
                "https://www.example.com/path/to/resource1?query=parameter",
                "https://www.example.com/path/to/resource2?query=parameter"
            ],
            "description": """List of valid URLs"""
        },
        {
            "field_name": "shopThemeColors",
            "field_type": "list",
            "required": False,
            "validator": "validate_hex_colors_list",
            "cls_or_instance": fields.String(pattern=r'^#(?:[0-9a-fA-F]{3}){1,2}$'),
            "min_items": 2,
            "max_items": 2,
            "default": None,
            "example": ["#516395", "#2E8B57"],
            "description": """List ['primaryThemeColorHexCode', 'secondaryThemeColorHexCode']"""
        },
        {
            "field_name": "shopContactDetails",
            "field_type": "list",
            "required": False,
            "validator": "validate_shop_contact_details",
            "cls_or_instance": fields.Nested(model=contact_detail_model),
            "min_items": 0,
            "max_items": 10,
            "default": None,
            "example": [
                {
                    "contactName": "Amit Sharma",
                    "email": "user1@example.com",
                    "mobile": "+919876543210",
                    "isWPAvailable": False
                },
                {
                    "contactName": "Priya Singh",
                    "email": "user2@example.com",
                    "mobile": "+918765432109",
                    "isWPAvailable": True
                }
            ],
            "description": """List of <Contact Detail Model>s"""
        },
        {
            "field_name": "shopLocation",
            "field_type": "list",
            "required": False,
            "validator": "validate_location",
            "cls_or_instance": fields.Float(),
            "min_items": 2,
            "max_items": 2,
            "default": None,
            "example": [17.3850, 78.4867],
            "description": """
                List of Float coordinates[Latitude, Longitude].
                Range of Latitude: [-90, 90],
                Range of longitude: [-180, 180].
            """
        },
        {
            "field_name": "shopTimings",
            "field_type": "nested",
            "required": False,
            "validator": "validate_shop_timings",
            "model": shop_timings_model,
            "default": None,
            "description": """<Shop Timings Model>"""
        }
    ]
}

================================================================================

Filename: restx/models/user/shop_timings_model.py
Content:
from flask_restx import fields
from restx import RESTX
from restx.models.user.weekly_timings_model import weekly_timings_model


shop_timings_model = RESTX.model(
    name="Shop Timings",
    model={
        "generalTimings": fields.Nested(
            required=True,
            model=weekly_timings_model
        ),
        "inStore": fields.Nested(
            required=True,
            model=weekly_timings_model
        ),
        "takeaway": fields.Nested(
            required=True,
            model=weekly_timings_model
        ),
        "delivery": fields.Nested(
            required=True,
            model=weekly_timings_model
        )
    }
)

================================================================================

Filename: restx/models/user/weekly_timings_model.py
Content:
from flask_restx import fields
from restx import RESTX


weekly_timings_model = RESTX.model(
    name="Weekly Timings",
    model={
        "isAvailable": fields.Boolean(
            required=True,
            example=True
        ),
        "monday": fields.List(
            required=True,
            cls_or_instance=fields.Integer,
            example=[1000, 1700],
        ),
        "tuesday": fields.List(
            required=True,
            cls_or_instance=fields.Integer,
            example=[1000, 1700]
        ),
        "wednesday": fields.List(
            required=True,
            cls_or_instance=fields.Integer,
            example=[1000, 1700]
        ),
        "thursday": fields.List(
            required=True,
            cls_or_instance=fields.Integer,
            example=[1000, 1700]
        ),
        "friday": fields.List(
            required=True,
            cls_or_instance=fields.Integer,
            example=[1000, 1700]
        ),
        "saturday": fields.List(
            required=True,
            cls_or_instance=fields.Integer,
            example=[1000, 1700]
        ),
        "sunday": fields.List(
            required=True,
            cls_or_instance=fields.Integer,
            example=[1000, 1700]
        )
    }
)

================================================================================

Filename: routes/__init__.py
Content:
from routes.auth import auth_api
from routes.inventory import inventory_api
from routes.user import user_api

================================================================================

Filename: routes/auth.py
Content:
from flask_jwt_extended import jwt_required, get_jwt_identity
from flask_restx import Namespace, Resource
from controllers import auth_controllers
from validators import validate_request_data, get_validated_data
from restx import docs, models


# Create a namespace for /auth/* operations
auth_api = Namespace(name='Authentication')


@auth_api.route('/authenticate')
class Authenticate(Resource):
    @auth_api.expect(models.auth.post_authenticate_model)
    @auth_api.doc(**docs.auth.post_authenticate_doc)
    @validate_request_data(models.auth.post_authenticate_semi_restx_dict)
    def post(self):
        """Get user_access_token in exchange for ventory/google token."""
        return auth_controllers.handle_authenticate_post(
            validated_data=get_validated_data()
        )


@auth_api.route('/change-inventory')
class ChangeInventory(Resource):
    @jwt_required()
    @auth_api.expect(models.auth.post_change_inventory_model)
    @auth_api.doc(**docs.auth.post_change_inventory_doc)
    @validate_request_data(models.auth.post_change_inventory_semi_restx_dict)
    def post(self):
        """Get inventory_access_token in exchange for user_access_token."""
        return auth_controllers.handle_change_inventory_post(
            user_id=get_jwt_identity(),
            validated_data=get_validated_data()
        )


@auth_api.route('/check-email')
class CheckEmail(Resource):
    @auth_api.expect(models.auth.post_check_email_model)
    @auth_api.doc(**docs.auth.post_check_email_doc)
    @validate_request_data(models.auth.post_check_email_semi_restx_dict)
    def post(self):
        """Check if an email id is registered with ventory or not."""
        return auth_controllers.handle_check_email_post(
            validated_data=get_validated_data()
        )


@auth_api.route('/check-mobile')
class CheckMobile(Resource):
    @auth_api.expect(models.auth.post_check_mobile_model)
    @auth_api.doc(**docs.auth.post_check_mobile_doc)
    @validate_request_data(models.auth.post_check_mobile_semi_restx_dict)
    def post(self):
        """Check if a mobile number is registered with ventory or not."""
        return auth_controllers.handle_check_mobile_post(
            validated_data=get_validated_data()
        )


@auth_api.route('/email-auth-send-otp')
class EmailAuthSendOTP(Resource):
    @auth_api.expect(models.auth.post_email_auth_send_otp_model)
    @auth_api.doc(**docs.auth.post_email_auth_send_otp_doc)
    @validate_request_data(models.auth.post_email_auth_send_otp_semi_restx_dict)
    def post(self):
        """Send authentication OTP to an email id."""
        return auth_controllers.handle_email_auth_send_otp_post(
            validated_data=get_validated_data()
        )


@auth_api.route('/email-auth-verify-otp')
class EmailAuthVerifyOTP(Resource):
    @auth_api.expect(models.auth.post_email_auth_verify_otp_model)
    @auth_api.doc(**docs.auth.post_email_auth_verify_otp_doc)
    @validate_request_data(models.auth.post_email_auth_verify_otp_semi_restx_dict)
    def post(self):
        """Verify authentication OTP sent via email id."""
        return auth_controllers.handle_email_auth_verify_otp_post(
            validated_data=get_validated_data()
        )


@auth_api.route('/renew-user-token')
class Renew(Resource):
    @jwt_required(refresh=True)
    @auth_api.doc(**docs.auth.post_renew_user_token_doc)
    def post(self):
        """Get user_access_token in exchange for user_refresh_token."""
        return auth_controllers.handle_renew_user_token_post(
            user_id=get_jwt_identity()
        )

================================================================================

Filename: routes/inventory.py
Content:
from flask import request
from flask_jwt_extended import jwt_required, get_jwt_identity
from flask_restx import Namespace, Resource
from controllers import inventory_controller, inventory_controllers, get_jwt_user_id

from restx import models, docs
from utils.token_utils import fetch_jwt_additional_claim as get_jwt_inventory_id  # temp
from validators import validate_request_data, get_validated_data, validate_request_form, get_validated_form

# Create a namespace for /inventory operations
inventory_api = Namespace(name='Inventory')


# Item Resources
@inventory_api.route('/item')
class Item(Resource):
    @jwt_required()
    @inventory_api.expect(models.inventory.post_item_model)
    @inventory_api.doc(**docs.inventory.post_item_doc)
    @validate_request_data(models.inventory.post_item_semi_restx_dict)
    # @authenticate_inventory
    def post(self):
        """Add a new item to the inventory."""
        return inventory_controllers.handle_add_item(
            inventory_id=get_jwt_identity(),
            validated_data=get_validated_data()
        )

    @jwt_required()
    @inventory_api.expect(models.inventory.put_item_model)
    @inventory_api.doc(**docs.inventory.put_item_doc)
    @validate_request_data(models.inventory.put_item_semi_restx_dict)
    def put(self):
        """Edit an existing item in the inventory."""
        return inventory_controllers.handle_edit_item(
            validated_data=get_validated_data(),
            inventory_id=get_jwt_identity()
        )

    @jwt_required()
    @inventory_api.doc(description='Delete an item from the inventory')
    def delete(self):
        """Delete an item from the inventory."""
        return inventory_controller.handle_delete_item(
            request=request,
            user_id=get_jwt_user_id(),
            inventory_id=get_jwt_identity()
        )


# Item Images Resource
@inventory_api.route('/item-image')
class Image(Resource):
    @jwt_required()
    @inventory_api.expect(models.inventory.post_image_parser)
    @inventory_api.doc(**docs.inventory.post_image_doc)
    @validate_request_form(models.inventory.post_image_parser)
    def put(self):
        """Add an image to an item."""
        return inventory_controllers.handle_add_image(
            validated_data=get_validated_form(),
            processed_image=get_validated_form(),
            inventory_id=get_jwt_identity()
        )

    @jwt_required()
    @inventory_api.doc(description='Delete an image from an item')
    def delete(self):
        """Delete an image from an item."""
        return inventory_controller.handle_delete_image(
            request=request,
            user_id=get_jwt_user_id(),
            inventory_id=get_jwt_identity()
        )


================================================================================

Filename: routes/user.py
Content:
from flask_restx import Namespace, Resource
from flask_jwt_extended import jwt_required, get_jwt_identity
from controllers import (
    user_controllers,
    permissions_required,
    get_jwt_user_id
)
from validators import (
    validate_request_data,
    get_validated_data
)
from restx import docs, models


# Namespace for /user/* operations
user_api = Namespace(name='User')


# User Resource
@user_api.route('/user')
class User(Resource):
    @user_api.expect(models.user.post_user_model)
    @user_api.doc(**docs.user.post_user_doc)
    @validate_request_data(models.user.post_user_semi_restx_dict)
    def post(self):
        """Sign up a new user."""
        return user_controllers.handle_user_post(
            validated_data=get_validated_data()
        )


# Inventory Resource
@user_api.route('/inventory')
class Shop(Resource):
    @user_api.expect(models.user.post_inventory_model)
    @user_api.doc(**docs.user.post_inventory_doc)
    @jwt_required()
    @validate_request_data(models.user.post_inventory_semi_restx_dict)
    def post(self):
        """Create new inventory and add inventory info to the user"""
        return user_controllers.handle_inventory_post(
            user_id=get_jwt_identity(),
            validated_data=get_validated_data()
        )

    @user_api.expect(models.user.put_inventory_model)
    @user_api.doc(**docs.user.put_inventory_doc)
    @jwt_required()
    @permissions_required()
    @validate_request_data(models.user.put_inventory_semi_restx_dict)
    def put(self):
        """Update inventory info of the user"""
        return user_controllers.handle_inventory_put(
            user_id=get_jwt_user_id(),
            inventory_id=get_jwt_identity(),
            validated_data=get_validated_data()
        )


================================================================================

Filename: supabase/.env
Content:
DB_USER=postgres
DB_PASSWORD=Rudra2004
DB_HOST=localhost
DB_PORT=6543
DB_NAME=postgres
TENANT_ID=supabase_tenant

================================================================================

Filename: supabase/__init__.py
Content:
import os

from dotenv import load_dotenv
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

from supabase.models import (Base, Inventory, Category,
                             Item, Ingredient, NutritionalValue, NutritionalInfo, Variant)

load_dotenv()

DB_USER = os.getenv('DB_USER', 'postgres')
DB_PASSWORD = os.getenv('DB_PASSWORD', 'your-super-secret-password')
DB_HOST = os.getenv('DB_HOST', 'localhost')
DB_PORT = os.getenv('DB_PORT', '5432')
DB_NAME = os.getenv('DB_NAME', 'postgres')
TENANT_ID = os.getenv('TENANT_ID', 'your-tenant-id')

SQLALCHEMY_DATABASE_URI = f'postgresql://{DB_USER}.{TENANT_ID}:{DB_PASSWORD}@{DB_HOST}:{DB_PORT}/{DB_NAME}'
print('DB_URL', SQLALCHEMY_DATABASE_URI)

engine = create_engine(SQLALCHEMY_DATABASE_URI)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

try:
    with engine.connect() as connection:
        print("Connection successful!")
except Exception as e:
    print("Connection failed:", e)


def init_db():
    """Initialize the database, including any custom enum types and tables."""
    try:
        # Create tables
        Base.metadata.create_all(bind=engine)
        print("Database initialized successfully")
    except Exception as e:
        print(f"Error initializing database: {str(e)}")
        raise


def get_db():
    """Provide a database session, closing it after use."""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


Base.metadata.create_all(engine)
session = SessionLocal()
# Sample data creation
try:
    # Create inventory
    inventory = Inventory()

    # Create categories
    category1 = Category(name="Beverages", inventory=inventory)
    category2 = Category(name="Snacks", inventory=inventory)

    # Create items
    item1 = Item(name="Cola", description="Carbonated soft drink", category=category1)
    item2 = Item(name="Chips", description="Potato chips", category=category2)

    # Create ingredients
    ingredient1 = Ingredient(ingredient_name="Carbonated Water", ingredient_content=90, unit="ml", item=item1)
    ingredient2 = Ingredient(ingredient_name="Salt", ingredient_content=5, unit="g", item=item2)

    # Create nutritional info
    nutritional_info1 = NutritionalInfo(serving_size=330, measuring_size=1, unit="can", item=item1)
    nutritional_info2 = NutritionalInfo(serving_size=30, measuring_size=1, unit="pack", item=item2)

    # Create nutritional values
    nutritional_value1 = NutritionalValue(name="Calories", value=140, unit="kcal", nutritional_info=nutritional_info1)
    nutritional_value2 = NutritionalValue(name="Calories", value=160, unit="kcal", nutritional_info=nutritional_info2)

    # Create variants
    variant1 = Variant(variant_name="Regular", variant_price="1.00", item=item1)
    variant2 = Variant(variant_name="Barbecue", variant_price="1.50", item=item2)

    # Add to session
    session.add(inventory)

    # Commit changes
    session.commit()
    print("Sample data inserted successfully.")

finally:
    session.close()


================================================================================

Filename: supabase/models/__init__.py
Content:
from supabase.models.base import Base
from supabase.models.inventory import *


================================================================================

Filename: supabase/models/base.py
Content:
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

================================================================================

Filename: supabase/models/inventory/__init__.py
Content:
from sqlalchemy import Column, Integer
from sqlalchemy.orm import relationship
from supabase.models.base import Base
from supabase.models.inventory.category import Category
from supabase.models.inventory.variant import Variant
from supabase.models.inventory.ingredient import Ingredient
from supabase.models.inventory.nutritional_info import NutritionalInfo
from supabase.models.inventory.item import Item
from supabase.models.inventory.nutritional_value import NutritionalValue

class Inventory(Base):
    """
    Represents an inventory that can have multiple categories.
    """
    __tablename__ = 'inventories'

    id = Column(Integer, primary_key=True, autoincrement=True)

    # Relationship to Categories
    categories = relationship('Category', back_populates='inventory', cascade='all, delete-orphan')


================================================================================

Filename: supabase/models/inventory/category.py
Content:
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship
from supabase.models.base import Base

class Category(Base):
    """
    Represents a category within an inventory, which can have multiple items.
    """
    __tablename__ = 'categories'

    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String, nullable=False)

    # Foreign key to Inventory
    inventory_id = Column(Integer, ForeignKey('inventories.id'), nullable=False)
    inventory = relationship("Inventory", back_populates="categories")
    # Relationship to Items
    items = relationship('Item', back_populates='category', cascade='all, delete-orphan')


================================================================================

Filename: supabase/models/inventory/ingredient.py
Content:
from sqlalchemy import Column, Integer, String, Float, ForeignKey
from sqlalchemy.orm import relationship
from supabase.models.base import Base


class Ingredient(Base):
    """
    Represents an ingredient with its name, content, and unit.
    """
    __tablename__ = 'ingredients'

    id = Column(Integer, primary_key=True, autoincrement=True)
    ingredient_name = Column(String, nullable=False)
    ingredient_content = Column(Float, nullable=False)
    unit = Column(String, nullable=False)

    # Relationship to Item
    item_id = Column(Integer, ForeignKey('items.id'))
    item = relationship("Item", back_populates="ingredients")


================================================================================

Filename: supabase/models/inventory/item.py
Content:
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship
from supabase.models.base import Base

class Item(Base):
    """
    Represents an item in the inventory with its details, variants, ingredients,
    and nutritional information.
    """
    __tablename__ = 'items'

    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String, nullable=False)
    description = Column(String)

    # Foreign key to Category
    category_id = Column(Integer, ForeignKey('categories.id'), nullable=False)
    category = relationship('Category', back_populates='items')

    # Relationships
    # In Item model
    variants = relationship("Variant", back_populates="item", cascade="all, delete-orphan")
    ingredients = relationship('Ingredient', back_populates='item', cascade='all, delete-orphan')
    nutritional_info = relationship('NutritionalInfo', uselist=False,
                                    back_populates='item', cascade='all, delete-orphan')


================================================================================

Filename: supabase/models/inventory/nutritional_info.py
Content:
from sqlalchemy import Column, Integer, Float, String, ForeignKey
from sqlalchemy.orm import relationship
from supabase.models.base import Base


class NutritionalInfo(Base):
    """
    Represents the nutritional information for an item.
    """
    __tablename__ = 'nutritional_info'

    id = Column(Integer, primary_key=True, autoincrement=True)

    # Information about serving and measuring sizes
    serving_size = Column(Float)
    measuring_size = Column(Float)
    unit = Column(String)

    # Relationship to Items
    item_id = Column(Integer, ForeignKey('items.id'), unique=True)
    item = relationship("Item", back_populates="nutritional_info")

    nutritional_values = relationship('NutritionalValue', back_populates='nutritional_info',
                                      cascade='all, delete-orphan')


================================================================================

Filename: supabase/models/inventory/nutritional_value.py
Content:
from sqlalchemy import Column, Integer, String, Float, ForeignKey
from sqlalchemy.orm import relationship
from supabase.models.base import Base


class NutritionalValue(Base):
    """
    Represents a nutritional component with its name, value, and unit.
    """
    __tablename__ = 'nutritional_values'

    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String, nullable=False)
    value = Column(Float, nullable=False)
    unit = Column(String, nullable=False)

    # Relationship to NutritionalInfo
    nutritional_info_id = Column(Integer, ForeignKey('nutritional_info.id'))
    nutritional_info = relationship('NutritionalInfo', back_populates='nutritional_values')


================================================================================

Filename: supabase/models/inventory/variant.py
Content:
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship
from supabase.models.base import Base


class Variant(Base):
    """
    Represents a variant of an item with its name and price.
    """
    __tablename__ = 'variants'

    id = Column(Integer, primary_key=True, autoincrement=True)
    variant_name = Column(String, nullable=False)
    variant_price = Column(String, nullable=False)

    # Relationship to Item
    item_id = Column(Integer, ForeignKey('items.id'))
    item = relationship("Item", back_populates="variants")


================================================================================

Filename: utils/__init__.py
Content:
from utils.cryptography_utils import *
from utils.inventory_utils import *
from utils.json_utils import *
from utils.token_utils import *
from utils.uuid_utils import *
from utils.restx_model_utils import *

================================================================================

Filename: utils/cryptography_utils.py
Content:
from flask import current_app
from cryptography.fernet import Fernet
import json
import base64
import hashlib


FERNET = None  # fernet object


def get_fernet_object():
    global FERNET

    if not FERNET:
        flask_secret_key = current_app.config['SECRET_KEY']
        print(flask_secret_key)

        base64_bytes = base64.urlsafe_b64encode(
            hashlib.sha256(
                flask_secret_key.encode('utf-8')
            ).digest()
        )

        FERNET = Fernet(base64_bytes.decode('utf-8'))

    return FERNET


# Encrypt data (dictionary to encrypted bytes)
def encrypt_data(data):
    # get fernet object
    fernet = get_fernet_object()
    # Convert dictionary to JSON string
    json_data = json.dumps(data)
    # Encrypt JSON string
    encrypted_data = fernet.encrypt(json_data.encode())
    # Encode the encrypted data in URL-safe base64 and return
    base64_encoded_data = base64.urlsafe_b64encode(encrypted_data).decode('utf-8')

    return base64_encoded_data


# Decrypt data (encrypted bytes to dictionary)
def decrypt_data(base64_encoded_data):
    # get fernet object
    fernet = get_fernet_object()
    # Decode the base64 encoded data back to bytes
    encrypted_data = base64.urlsafe_b64decode(base64_encoded_data.encode('utf-8'))
    # Decrypt encrypted bytes
    decrypted_data = fernet.decrypt(encrypted_data).decode()
    # Convert JSON string back to dictionary
    data = json.loads(decrypted_data)

    return data


================================================================================

Filename: utils/inventory_utils.py
Content:
# -----RESOLVE CATEGORY NAME--------------------------------------------------------------------------------------------
def resolve_category_name(user_inventory, category_name):
    """
    Returns: category_id, # if a category with category_id exists : else, None
    """
    for category_key in user_inventory["order"]:
        if user_inventory[category_key]["categoryName"] == category_name:
            return category_key
    return None


# -----CHECK ITEM ID EXISTS---------------------------------------------------------------------------------------------
def is_item_id_exists(user_inventory, category_id, item_id):
    """
    Returns: item_id, # if an item with item_id exists : else, None
    """
    for item_key in user_inventory[category_id]['items']['order']:
        if item_key == item_id:
            return item_key
    return None


================================================================================

Filename: utils/json_utils.py
Content:
import json


# fetch data from a json file (provide absolute path)
def get_data_from_json_file(absolute_file_path):
    with open(absolute_file_path, 'r', encoding="utf-8") as json_file:
        data = json.load(json_file)
        return data


================================================================================

Filename: utils/restx_model_utils.py
Content:
from flask_restx import fields
from restx import RESTX


def parse_semi_restx_dict_to_restx_model(semi_restx_dict):
    restx_model = {}

    for field_details in semi_restx_dict.get('fields'):
        field_name = field_details.get('field_name')

        if field_details.get('field_type') == "string":
            restx_model[field_name] = fields.String(**field_details)
        elif field_details.get('field_type') == "integer":
            restx_model[field_name] = fields.Integer(**field_details)
        elif field_details.get('field_type') == "float":
            restx_model[field_name] = fields.Float(**field_details)
        elif field_details.get('field_type') == "boolean":
            restx_model[field_name] = fields.Boolean(**field_details)
        elif field_details.get('field_type') == "date":
            restx_model[field_name] = fields.Date(**field_details)
        elif field_details.get('field_type') == "datetime":
            restx_model[field_name] = fields.DateTime(**field_details)
        elif field_details.get('field_type') == "list":
            restx_model[field_name] = fields.List(**field_details)
        elif field_details.get('field_type') == "nested":
            restx_model[field_name] = fields.Nested(**field_details)
        elif field_details.get('field_type') == "url":
            restx_model[field_name] = fields.Url(**field_details)
        elif field_details.get('field_type') == "raw":
            restx_model[field_name] = fields.Raw(**field_details)

    return RESTX.model(
        name=semi_restx_dict.get('model_name'),
        model=restx_model
    )




================================================================================

Filename: utils/token_utils.py
Content:
from flask_jwt_extended import create_access_token, create_refresh_token, decode_token as _decode_token
from firebase_admin import auth
from utils import cryptography_utils


# function to retrieve additional claim value from the token
def fetch_jwt_additional_claim(token, claim):
    # Note: pass the token without 'Bearer'.
    decoded_token = _decode_token(token)
    return decoded_token.get(claim, None)


# function to create session token
def create_session_token(data):
    return cryptography_utils.encrypt_data(data)


# function to validate and retrieve data from session token
def validate_session_token(token):
    try:
        return cryptography_utils.decrypt_data(token)
    except Exception:
        return None


# function to create user_access_token
def create_user_access_token(user_id):
    return create_access_token(identity=user_id)


# function to create user_refresh_token
def create_user_refresh_token(user_id):
    return create_refresh_token(identity=user_id)


# function to create inventory_access_token
def create_inventory_access_token(inventory_id, user_id):
    return create_access_token(
        identity=inventory_id,
        additional_claims={"userId": user_id}
    )


# -----DECODE JWT TOKENS (VENTORY & GOOGLE)-----------------------------------------------------------------------------
def decode_token(token, provider):
    # decode the token based on the provider
    try:
        if provider == "ventory":
            return _decode_token(token)
        elif provider == "google":
            return auth.verify_id_token(token)
        else:
            return None
    except Exception:
        return None


================================================================================

Filename: utils/uuid_utils.py
Content:
import uuid
import re


def generate_uuid():
    return re.sub(r'-', '_', str(uuid.uuid4()))


================================================================================

Filename: validators/__init__.py
Content:
from validators.validate_request_data import *
from validators.validate_request_form import *


================================================================================

Filename: validators/general_validators/__init__.py
Content:
from validators.general_validators.validate_mobile import validate_mobile
from validators.general_validators.validate_email import validate_email
from validators.general_validators.validate_hex_color import *
from validators.general_validators.validate_list_of_urls import *
from validators.general_validators.validate_url import *
from validators.general_validators.validate_boolean import *
from validators.general_validators.validate_string import *
from validators.general_validators.validate_alphanumeric_string import validate_alphanumeric_string
from validators.general_validators.validate_geo_point import *
from validators.general_validators.validate_index import *
from validators.general_validators.validate_image import *


================================================================================

Filename: validators/general_validators/validate_alphanumeric_string.py
Content:
def validate_alphanumeric_string(field_name, raw_data, required=False, min_length=None, max_length=None, **kwargs):
    # validates if a string is alphanumeric and satisfies all the conditions.
    if not raw_data and not required:
        return {"success": True, "data": None}
    if not isinstance(raw_data, str):
        message = f"Invalid {field_name}: must be a string."
    elif len(raw_data.strip()) == 0 and required:
        message = f"Invalid {field_name}: cannot be empty."
    elif min_length and len(raw_data.strip()) < min_length:
        message = f"Invalid {field_name}: must be {min_length} characters or more."
    elif max_length and len(raw_data) > max_length:
        message = f"Invalid {field_name}: must be {max_length} characters or fewer."
    elif not raw_data.isalnum():
        message = f"Invalid {field_name}: must contain only alphanumeric characters."
    else:
        return {"success": True, "data": raw_data}

    return {"success": False, "data": None, "message": message}


================================================================================

Filename: validators/general_validators/validate_boolean.py
Content:
def validate_boolean(raw_data, field_name, is_required=False, **kwargs):
    """
    Sanitizes and validates a boolean value.

    Args:
        raw_data (any): The value to be sanitized and validated.
        field_name (str): The label of the field for error messages.
        is_required (bool): Whether the field is required or not.

    Returns:
        dict: A dictionary with keys 'success' (bool), 'data' (bool), and 'message' (str).
    """
    # Handle required field check
    if is_required and (raw_data is None or raw_data == ''):
        return {
            "success": False,
            "message": f"{field_name} is required and cannot be empty."
        }

    # Check if the value is already a boolean
    if isinstance(raw_data, bool):
        return {"success": True, "data": raw_data}

    # Convert string representations to boolean
    if isinstance(raw_data, str):
        raw_data = raw_data.lower()
        if raw_data in ['true', '1', 'yes', 'on']:
            return {"success": True, "data": True}
        elif raw_data in ['false', '0', 'no', 'off']:
            return {"success": True, "data": False}

    # Convert integer representations to boolean
    if isinstance(raw_data, int):
        if raw_data == 1:
            return {"success": True, "data": True}
        elif raw_data == 0:
            return {"success": True, "data": False}

    # If we can't convert it to a boolean, return an error
    return {
        "success": False,
        "message": f"{field_name} must be a boolean value (true/false, 1/0, yes/no, on/off)."
    }


================================================================================

Filename: validators/general_validators/validate_email.py
Content:
import re


def validate_email(raw_data, field_name, required=False, **kwargs):
    """
    Sanitizes and validates an email address.

    Args:
        field_name (str): The label of the field for error messages.
        raw_data (str): The email address to be sanitized and validated.
        required (bool): Whether the field is required.

    Returns:
        dict: A dictionary with keys 'success' (bool), 'data' (str), and 'message' (str).
    """
    # Check if the field is required and empty
    if required and not raw_data:
        return {"success": False, "message": f"{field_name} is required."}

    # If it's not required and empty, return success
    if not required and not raw_data:
        return {"success": True, "data": ""}

    # Trim whitespace
    sanitized_value = raw_data.strip()

    # regex for email validation
    email_regex = r'^[a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if re.match(email_regex, sanitized_value):
        return {"success": True, "data": sanitized_value}
    else:
        return {
            "success": False,
            "message": f"{field_name} must be a valid email address."
        }


================================================================================

Filename: validators/general_validators/validate_geo_point.py
Content:
from firebase_admin.firestore import GeoPoint


def validate_geo_point(raw_data, field_name, is_required=False, **kwargs):
    """
    Sanitizes and validates a geo-point.

    Args:
        raw_data (List): The geo-point value as a list of [latitude, longitude].
        field_name (str): The label of the field for error messages.
        is_required (bool): Whether the field is required.

    Returns:
        Dict: A dictionary with 'success', 'data', and 'message' keys.
    """
    if not raw_data and not is_required:
        return {"success": True, "data": None, "message": ""}

    if not raw_data and is_required:
        return {"success": False, "data": None, "message": f"{field_name} is required."}

    try:
        if isinstance(raw_data, list) and len(raw_data) == 2:
            lat, lon = map(float, raw_data)
        else:
            raise ValueError("Invalid geo-point format")

        if not (-90 <= lat <= 90) or not (-180 <= lon <= 180):
            raise ValueError("Latitude or longitude out of range")

        # Create a GeoPoint object for Firebase
        geo_point = GeoPoint(lat, lon)

        return {"success": True, "data": geo_point, "message": ""}
    except (ValueError, TypeError) as e:
        return {"success": False, "data": None, "message": f"Invalid {field_name}: {str(e)}"}


================================================================================

Filename: validators/general_validators/validate_hex_color.py
Content:
import re

def validate_hex_color(raw_data, field_name, is_required=False, **kwargs):
    """
    Sanitizes a hex color string.

    Args:
        raw_data (str): The raw hex color string to be sanitized.
        field_name (str): The name of the hex color field.
        is_required (bool): Indicates whether the hex color field is required.

    Returns:
        dict: A dictionary with the following keys:
            - 'success': True if the hex color is valid, False otherwise.
            - 'data': The sanitized hex color string if valid, None otherwise.
            - 'message': The error message if the hex color is invalid.
    """
    message = ""
    if not raw_data and not is_required:
        return {"success": True, "data": None, "message": ""}
    # Check if the raw_data is a string
    if not isinstance(raw_data, str):
        message = f"Invalid {field_name}: must be a string."
    # Check if the raw_data is empty and is_required is True
    elif len(raw_data.strip()) == 0 and is_required:
        message = f"Invalid {field_name}: cannot be empty."
    # Check if the length of the raw_data is 7 (including the '#') and it matches the hex color pattern
    elif len(raw_data) != 7 or not re.match(r'^#([A-Fa-f0-9]{6})$', raw_data):
        message = f"Invalid {field_name}: must be a valid hex color code (e.g., #516395)."
    else:
        sanitized_data = raw_data.upper()
        return {
            "success": True,
            "data": sanitized_data
        }

    return {
        "success": False,
        "message": message
    }

================================================================================

Filename: validators/general_validators/validate_image.py
Content:
import io
from PIL import Image


def validate_image(image_file, width=500, height=500, **kwargs):
    """
    Sanitizes and processes an image file.

    Args:
        image_file (file): The image file to be sanitized and resized.
        width (int): The desired width of the image thumbnail. Defaults to 500.
        height (int): The desired height of the image thumbnail. Defaults to 500.

    Returns:
        dict: A dictionary with keys 'success' (bool), 'data' (BytesIO object), and 'message' (str).
    """
    try:
        with Image.open(image_file) as img:
            img = img.convert('RGBA')
            img.thumbnail((width, height))
            buffer = io.BytesIO()
            img.save(buffer, format='PNG')
            buffer.seek(0)
        return {"success": True, "data": buffer}
    except Exception as e:
        return {"success": False, "message": f"Error processing image: {str(e)}"}


================================================================================

Filename: validators/general_validators/validate_index.py
Content:
def validate_index(raw_data, low, high, field_name, is_required=False, **kwargs):
    """
    Sanitizes and validates an index value.

    Args:
        raw_data (any): The index value to be sanitized and validated.
        low (int): The lower bound for the index (inclusive).
        high (int): The upper bound for the index (inclusive).
        field_name (str): The label of the field for error messages.
        is_required (bool): Whether the index is required or not. Defaults to False.

    Returns:
        dict: A dictionary with keys 'success' (bool), 'data' (int), and 'message' (str).
    """

    # If the index is required and not provided (None), return an error
    if is_required and raw_data is None:
        return {"success": False, "message": f"{field_name} is required"}

    try:
        # Attempt to convert the provided index to an integer
        raw_data = int(raw_data)

        # Check if the index is within the specified range (low to high, inclusive)
        if low <= raw_data <= high:
            return {"success": True, "data": raw_data}
        else:
            # Return an error if the index is outside the allowed range
            return {"success": False, "message": f"{field_name} must be between {low} and {high}"}

    except ValueError:
        # Return an error if the index cannot be converted to an integer (invalid format)
        return {"success": False, "message": f"Invalid {field_name}"}


================================================================================

Filename: validators/general_validators/validate_list_of_urls.py
Content:
from validators.general_validators.validate_url import validate_url


def validate_list_of_urls(raw_data, field_name, max_count=0, is_required=False, **kwargs):
    """
    Sanitizes a list of URLs.

    Args:
        raw_data (list): The raw list of URLs to be sanitized.
        field_name (str): The name of the URL list field.
        max_count (int): The maximum allowed number of URLs in the list (0 means no limit).
        is_required (bool): Indicates whether the URL list is a required field.

    Returns:
        dict: A dictionary with the following keys:
            - 'success': True if the URL list is valid, False otherwise.
            - 'data': The sanitized list of URLs if valid, None otherwise.
            - 'message': The error message if the URL list is invalid.
    """
    message = ""
    if not raw_data and not is_required:
        return {"success": True, "data": None, "message": ""}
    # Check if the raw_data is a list
    if not isinstance(raw_data, list):
        message = f"Invalid {field_name}: must be a list."
    # Check if the length of the list is greater than the maximum allowed count
    elif 0 < max_count < len(raw_data):
        message = f"Invalid {field_name}: must contain {max_count} or fewer URLs."
    # Check if the list is empty and is_required is True
    elif len(raw_data) == 0 and is_required:
        message = f"Invalid {field_name}: cannot be empty."
    else:
        sanitized_data = []
        for url in raw_data:
            url_sanitization_response = validate_url(url, f"{field_name} item", is_required=True)
            if url_sanitization_response["success"]:
                sanitized_data.append(url_sanitization_response["data"])
            else:
                message += f"{url_sanitization_response['message']} "
        if not message:
            return {
                "success": True,
                "data": sanitized_data
            }

    return {
        "success": False,
        "message": message.strip()
    }


================================================================================

Filename: validators/general_validators/validate_mobile.py
Content:
import phonenumbers


def validate_mobile(raw_data, field_name, required=False, **kwargs):
    """
    Sanitizes and validates an international mobile number.

    Args:
        field_name (str): The label of the field for error messages.
        raw_data (str): The mobile number to be sanitized and validated.
        required (bool): Whether the field is required.

    Returns:
        dict: A dictionary with keys 'success' (bool), 'data' (str), and 'message' (str).
    """
    # Check if the field is required and empty
    if required and not raw_data:
        return {"success": False, "message": f"{field_name} is required."}

    # If it's not required and empty, return success
    if not required and not raw_data:
        return {"success": True, "data": ""}

    try:
        # Parse the phone number
        phone_number = phonenumbers.parse(raw_data, None)

        # Check if the number is valid
        if not phonenumbers.is_valid_number(phone_number):
            return {
                "success": False,
                "message": f"{field_name} is not a valid phone number."
            }

        # Format the number in E.164 format (e.g., +14155552671)
        formatted_number = phonenumbers.format_number(phone_number, phonenumbers.PhoneNumberFormat.E164)

        return {"success": True, "data": formatted_number}

    except phonenumbers.NumberParseException:
        return {
            "success": False,
            "message": f"{field_name} must be a valid international phone number with country code."
        }


================================================================================

Filename: validators/general_validators/validate_string.py
Content:
def validate_string(raw_data, max_length, field_name, is_required=False, min_length=0, isalnum=False, **kwargs):
    """
    Sanitizes and validates a string input.

    Args:
    raw_data (str): The input string to be sanitized and validated.
    max_length (int): The maximum allowed length of the string.
    name (str): The name of the field being validated (used in error messages).
    is_required (bool): Whether the field is required or can be empty.
    min_length (int): The minimum allowed length of the string.
    isalnum (bool): Whether the string should only contain alphanumeric characters.

    Returns:
    dict: A dictionary with 'success' (bool), 'data' (str or None), and 'message' (str) keys.
    """
    message = ""
    if not raw_data and not is_required:
        return {"success": True, "data": None, "message": ""}

    if not isinstance(raw_data, str):
        message = f"Invalid {field_name}: must be a string."
    elif len(raw_data.strip()) == 0 and is_required:
        message = f"Invalid {field_name}: cannot be empty."
    elif len(raw_data.strip()) < min_length:
        message = f"Invalid {field_name}: must be {min_length} characters or more."
    elif len(raw_data) > max_length:
        message = f"Invalid {field_name}: must be {max_length} characters or fewer."
    elif isalnum and not raw_data.isalnum():
        message = f"Invalid {field_name}: must contain only alphanumeric characters."
    else:
        sanitized_data = raw_data
        return {
            "success": True,
            "data": sanitized_data,
            "message": ""
        }

    return {
        "success": False,
        "data": None,
        "message": message
    }

================================================================================

Filename: validators/general_validators/validate_url.py
Content:
import re


def validate_url(raw_data, field_name, is_required=False, **kwargs):
    """
    Sanitizes the input URL string using regular expressions.

    Args:
        raw_data (str): The raw URL string to be sanitized.
        field_name (str): The name of the URL field.
        is_required (bool): Indicates whether the URL is a required field.

    Returns:
        dict: A dictionary with the following keys:
            - 'success': True if the URL is valid, False otherwise.
            - 'data': The sanitized URL if valid, None otherwise.
            - 'message': The error message if the URL is invalid.
    """
    message = ""

    if not raw_data and not is_required:
        return {"success": True, "data": None, "message": ""}

    # Check if the raw_data is a string
    if not isinstance(raw_data, str):
        message = f"Invalid {field_name}: must be a string."

    # Check if the raw_data is empty and is_required is True
    elif len(raw_data.strip()) == 0 and is_required:
        message = f"Invalid {field_name}: cannot be empty."

    # Validate the URL using a regular expression
    elif not re.match(
            r'(https://www\.|http://www\.|https://|http://)?[a-zA-Z]{2,}(\.[a-zA-Z]{2,})(\.[a-zA-Z]{2,})?/[a-zA-Z0-9]{2,}|((https://www\.|http://www\.|https://|http://)?[a-zA-Z]{2,}(\.[a-zA-Z]{2,})(\.[a-zA-Z]{2,})?)|(https://www\.|http://www\.|https://|http://)?[a-zA-Z0-9]{2,}\.[a-zA-Z0-9]{2,}\.[a-zA-Z0-9]{2,}(\.[a-zA-Z0-9]{2,})?',
            raw_data):
        message = f"Invalid {field_name}: must be a valid URL."

    else:
        # Sanitize the URL by stripping leading and trailing whitespace
        sanitized_data = raw_data.strip()
        return {
            "success": True,
            "data": sanitized_data
        }

    return {
        "success": False,
        "message": message
    }


================================================================================

Filename: validators/inventory_validators/__init__.py
Content:
from validators.inventory_validators.validate_item_ingredients import validate_item_ingredients
from validators.inventory_validators.validate_item_nutritional_info import validate_item_nutritional_info
from validators.inventory_validators.validate_item_tags import validate_item_tags
from validators.inventory_validators.validate_item_variants import validate_item_variants
from validators.inventory_validators.validate_item import validate_item


================================================================================

Filename: validators/inventory_validators/validate_item.py
Content:
from validators.general_validators import validate_alphanumeric_string, validate_string
from validators.inventory_validators import validate_item_variants, validate_item_tags, validate_item_ingredients, \
    validate_item_nutritional_info


def validate_item(raw_data, is_put=False, **kwargs):
    """
    Validates an item by calling all the nested validators
    Args:
        is_put: Bool value indicating if the request is a PUT request
        raw_data: The item to be validated
        **kwargs: any additional arguments to be passed to the validators

    Returns:
        A dictionary containing the validation status and the sanitized item

    """

    # Validate the item
    if not raw_data:
        return {
            "success": False,
            "message": "Invalid item! Item cannot be empty."
        }

    if not isinstance(raw_data, dict):
        return {
            "success": False,
            "message": "Invalid item! Item must be a dictionary."
        }

    # Validate the item name
    item_name_validation = validate_alphanumeric_string("Item Name",
                                                        raw_data.get("name", ""),
                                                        required=not is_put,
                                                        min_length=1,
                                                        max_length=30)
    if not item_name_validation["success"]:
        return {
            "success": False,
            "message": item_name_validation["message"]
        }

    # Validate the item description
    item_description_validation = validate_string(field_name="Item Description",
                                                  raw_data=raw_data.get("description", ""),
                                                  max_length=500)

    if not item_description_validation["success"]:
        return {
            "success": False,
            "message": item_description_validation["message"]
        }

    # Validate the item variants
    item_variants_validation = validate_item_variants(raw_data.get("variants", []),
                                                      is_required=not is_put)

    if not item_variants_validation["success"]:
        return {
            "success": False,
            "message": item_variants_validation["message"]
        }

    # Validate the item tags
    item_tags_validation = validate_item_tags(raw_data.get("tags", ""))

    if not item_tags_validation["success"]:
        return {
            "success": False,
            "message": item_tags_validation["message"]
        }

    # Validate the item ingredients
    item_ingredients_validation = validate_item_ingredients(raw_data.get("ingredients", []))

    if not item_ingredients_validation["success"]:
        return {
            "success": False,
            "message": item_ingredients_validation["message"]
        }

    # Validate the item nutritional info
    item_nutritional_info_validation = validate_item_nutritional_info(raw_data.get("nutritional_info", {}))

    if not item_nutritional_info_validation["success"]:
        return {
            "success": False,
            "message": item_nutritional_info_validation["message"]
        }

    # Return the sanitized item
    return {
        "success": True,
        "data": {
            "item_name": item_name_validation["data"],
            "item_description": item_description_validation["data"],
            "item_variants": item_variants_validation["data"],
            "item_tags": item_tags_validation["data"],
            "item_ingredients": item_ingredients_validation["data"],
            "item_nutritional_info": item_nutritional_info_validation["data"]
        }
    }

================================================================================

Filename: validators/inventory_validators/validate_item_ingredients.py
Content:
def validate_item_ingredients(ingredients, **kwargs):
    """
    Returns:
    - A dictionary with 'success': True and 'data': sanitized ingredients list if ingredients are valid
    - A dictionary with 'success': False and 'message': specific error message if ingredients are invalid
    """

    if not ingredients:
        return {
            "success": True,
            "data": []
        }

    message = ""

    sanitized_ingredients = []

    # check if ingredients is a non-empty list
    if not isinstance(ingredients, list):
        message = "Ingredients must be a list."

    elif len(ingredients) > 50:
        message = "Too many ingredients: maximum allowed is 50."

    else:
        for index, ingredient in enumerate(ingredients):
            # check if the ingredient is a dictionary
            if not isinstance(ingredient, dict):
                message = f"Ingredient at index {index} must be a dictionary."
                break

            ingredient_name = ingredient.get("ingredientName", "")
            ingredient_content = ingredient.get("ingredientContent", 0)
            ingredient_unit = ingredient.get("unit", "")

            # check if the ingredient fields are valid
            if not ingredient_name or not isinstance(ingredient_name, str) or len(ingredient_name) > 30:
                message = f"Invalid ingredientName at index {index}: must be a non-empty string with maximum length 30."
                break

            if not ingredient_content or not isinstance(ingredient_content, (int, float)):
                message = f"Invalid ingredientContent at index {index}: must be a non-zero number."
                break

            if not ingredient_unit or not isinstance(ingredient_unit, str) or len(ingredient_unit) > 10:
                message = f"Invalid unit at index {index}: must be a non-empty string with maximum length 10."
                break

            # create sanitized ingredient dictionary
            sanitized_ingredient = {
                "ingredientName": ingredient_name,
                "ingredientContent": ingredient_content,
                "unit": ingredient_unit
            }
            # add the sanitized ingredient to the list
            sanitized_ingredients.append(sanitized_ingredient)

    if message:
        return {
            "success": False,
            "message": f"Invalid ingredients format! {message}"
        }
    else:
        return {
            "success": True,
            "data": sanitized_ingredients
        }


================================================================================

Filename: validators/inventory_validators/validate_item_nutritional_info.py
Content:
def validate_item_nutritional_info(nutritional_info, **kwargs):
    """
    Returns:
    - A dictionary with 'success': True and 'data': sanitized nutritional info if valid
    - A dictionary with 'success': False and 'message': specific error message if invalid
    """

    if not nutritional_info:
        return {
            "success": True,
            "data": {}
        }

    message = ""

    sanitized_nutritional_info = {
        "information": {},
        "values": []
    }

    # check if nutritional_info is a non-empty dictionary
    if not isinstance(nutritional_info, dict):
        message = "Nutritional info must be a dictionary."

    else:
        information = nutritional_info.get("information")
        if not isinstance(information, dict):
            message = "Information must be a dictionary."

        else:
            serving_size = information.get("servingSize")
            measuring_size = information.get("measuringSize")
            unit = information.get("unit")

            # check if the information fields are valid
            if not isinstance(serving_size, (int, float)):
                message = "Serving size must be a number."

            elif not isinstance(measuring_size, (int, float)):
                message = "Measuring size must be a number."

            elif not isinstance(unit, str) or len(unit) > 10:
                message = "Unit must be a string with maximum length 10."

            else:
                # create sanitized information dictionary
                sanitized_nutritional_info["information"] = {
                    "servingSize": serving_size,
                    "measuringSize": measuring_size,
                    "unit": unit
                }

                # get the values list from nutritional_info
                values = nutritional_info.get("values", [])
                # check if values is a list and within the limit
                if not isinstance(values, list) or len(values) > 25:
                    message = "Values must be a list with maximum length 25."

                else:
                    for index, value in enumerate(values):
                        # check if the value is a dictionary
                        if not isinstance(value, dict):
                            message = f"Value at index {index} must be a dictionary."
                            break

                        name = value.get("name", "").capitalize()
                        value_num = value.get("value")
                        unit = value.get("unit")

                        # check if the value fields are valid
                        if not isinstance(name, str) or len(name) > 30:
                            message = f"Name at index {index} must be a string with maximum length 30."
                            break

                        if not isinstance(value_num, (int, float)):
                            message = f"Value at index {index} must be a number."
                            break

                        if not isinstance(unit, str) or len(unit) > 10:
                            message = f"Unit at index {index} must be a string with maximum length 10."
                            break

                        # Calculate RDA based on the formula
                        rda = calculate_rda(name, value_num, measuring_size, serving_size)

                        sanitized_value = {
                            "name": name,
                            "value": value_num,
                            "unit": unit,
                            "rda": rda
                        }
                        # add the sanitized value to the list
                        sanitized_nutritional_info["values"].append(sanitized_value)

    if message:
        return {
            "success": False,
            "message": f"Invalid nutritional info format! {message}"
        }
    else:
        return {
            "success": True,
            "data": sanitized_nutritional_info
        }

def calculate_rda(nutrient_name, value, measuring_size, serving_size):
    # RDA values as per FSSAI guidelines
    rda_values = {
        "Energy": 2000,  # kcal
        "Protein": 60,   # g
        "Carbohydrate": 300,  # g
        "Total Fat": 60,  # g
        "Saturated Fat": 20,  # g
        "Trans Fat": 2.2,  # g
        "Cholesterol": 300,  # mg
        "Dietary Fibre": 25,  # g
        "Sodium": 2000,  # mg
        "Vitamin A": 800,  # µg
        "Vitamin D": 5,   # µg
        "Vitamin E": 10,  # mg
        "Vitamin K": 65,  # µg
        "Vitamin C": 40,  # mg
        "Thiamine": 1.2,  # mg
        "Riboflavin": 1.4,  # mg
        "Niacin": 16,  # mg
        "Vitamin B6": 1.4,  # mg
        "Folic Acid": 200,  # µg
        "Vitamin B12": 1,  # µg
        "Biotin": 30,  # µg
        "Pantothenic acid": 5,  # mg
        "Calcium": 1000,  # mg
        "Phosphorus": 1000,  # mg
        "Iron": 17,  # mg
        "Magnesium": 310,  # mg
        "Zinc": 12,  # mg
        "Iodine": 150,  # µg
        "Copper": 2,  # mg
        "Manganese": 2.3,  # mg
        "Chromium": 30,  # µg
        "Selenium": 40,  # µg
        "Molybdenum": 45,  # µg
        "Chloride": 2300,  # mg
        "Potassium": 3500,  # mg
    }

    try:
        nutrient_value = float(value)
        rda = rda_values.get(nutrient_name)

        if rda is None:
            return ""  # RDA not available for this nutrient

        constant_value = float(measuring_size) if measuring_size else 1
        serving_size_value = float(serving_size) if serving_size else 1

        # Calculate RDA using the specified formula
        percentage = (nutrient_value / constant_value) / rda * serving_size_value * 100
        return f"{percentage:.1f}%"
    except ValueError:
        return ""

================================================================================

Filename: validators/inventory_validators/validate_item_tags.py
Content:
def validate_item_tags(tags, **kwargs):
    return {
        "success": True,
        "data": tags
    }


================================================================================

Filename: validators/inventory_validators/validate_item_variants.py
Content:
from handlers.default_data_handlers.get_default_price_info import get_default_price_list, get_accepted_currencies_list

DEFAULT_PRICES_LIST = get_default_price_list()
ACCEPTED_CURRENCIES = get_accepted_currencies_list()


def validate_item_variants(variants, **kwargs):
    """
    Returns:
    - A dictionary with 'success': True and 'data': sanitized variants list if variants are valid
    - A dictionary with 'success': False and 'message': specific error message if variants are invalid
    """
    global DEFAULT_PRICES_LIST, ACCEPTED_CURRENCIES

    # Extract is_required from kwargs, default to False if not provided
    is_required = kwargs.get('is_required', False)
    message = ""

    sanitized_variants = []

    # Check if variants is required
    if is_required and (not variants or not isinstance(variants, list)):
        return {
            "success": False,
            "message": "Variants must be a non-empty list when is_required is True."
        }

    # If variants is not required and empty, return success
    if not variants:
        return {
            "success": True,
            "data": []
        }

    # Existing checks for variants
    if len(variants) > 10:
        message = "Too many variants: maximum allowed is 10."

    else:
        for index, variant in enumerate(variants):
            # check if the variant is a dictionary
            if not isinstance(variant, dict):
                message = f"Variant at index {index} must be a dictionary."
                break

            variant_name = variant.get("variantName", "")
            variant_price = variant.get("variantPrice", "")

            # check the variant name
            if not variant_name or not isinstance(variant_name, str) or len(variant_name) > 30:
                message = f"Invalid variantName at index {index}: must be a non-empty string with maximum length 30."
                break

            # check the variant price
            if not variant_price or not isinstance(variant_price, str) or len(variant_price) > 15:
                message = f"Invalid variantPrice at index {index}: must be a non-empty string with maximum length 15."
                break

            # Check if the currency from the currency list is in the price value
            currency_found = any(currency in variant_price for currency in ACCEPTED_CURRENCIES)
            if currency_found:
                try:
                    # check if the values written after currency is a number or not
                    price = int(variant_price[2:])
                    if price == 0:
                        message = f"Invalid price at index {index}: price cannot be zero."
                        break

                except ValueError:
                    message = f"Invalid price format at index {index}: must be a number after currency symbol."
                    break
            else:
                # check if the item price is a default price
                if variant_price not in DEFAULT_PRICES_LIST:
                    message = (f"Invalid price at index {index}: must be in the default prices list or have a valid "
                               f"currency.")
                    break

            # If all checks pass, add the variant to the sanitized list
            sanitized_variants.append(variant)

    if message:
        return {
            "success": False,
            "message": f"Invalid variants format! {message}"
        }
    else:
        return {
            "success": True,
            "data": sanitized_variants
        }

================================================================================

Filename: validators/user_validators/__init__.py
Content:
from validators.user_validators.validate_shop_category import *
from validators.user_validators.validate_shop_contact_details import validate_shop_contact_details
from validators.user_validators.validate_gst_number import validate_gst_number
from validators.user_validators.validate_shop_timings import validate_shop_timings
from validators.user_validators.validate_shop_theme_colors import validate_shop_theme_colors

================================================================================

Filename: validators/user_validators/validate_gst_number.py
Content:
import re


def validate_gst_number(raw_data, field_name, is_required=False, **kwargs):
    """
    Sanitizes and validates a GST number.

    Args:
        raw_data (str): The GST number to validate.
        field_name (str): The label of the field for error messages.
        is_required (bool): Whether the field is required.

    Returns:
        Dict: A dictionary with 'success', 'data', and 'message' keys.
    """
    if not raw_data and not is_required:
        return {"success": True, "data": None, "message": ""}

    if not raw_data and is_required:
        return {"success": False, "data": None, "message": f"{field_name} is required."}

    # GST number format: 2 digits, 10 characters, 1 digit, 1 character, 1 digit
    gst_pattern = r"^[0-9]{2}[A-Z]{5}[0-9]{4}[A-Z]{1}[1-9A-Z]{1}Z[0-9A-Z]{1}$"

    if re.match(gst_pattern, raw_data):
        return {"success": True, "data": raw_data, "message": ""}
    else:
        return {"success": False, "data": None, "message": f"Invalid {field_name} format."}


================================================================================

Filename: validators/user_validators/validate_shop_category.py
Content:
from handlers.default_data_handlers.get_default_category_info import get_default_shop_categories


def validate_shop_category(raw_data, field_name, is_required=False, **kwargs):
    """
    Sanitizes and validates a shop category value.

    Args:
        raw_data (any): The shop category value to be sanitized and validated.
        field_name (str): The label of the field for error messages.
        is_required (bool): Whether the category is required or not. Defaults to False.

    Returns:
        dict:
            - 'success' (bool): True if the category is valid, False otherwise.
            - 'data' (str or None): Sanitized shop category if valid, None if not provided and not required.
            - 'message' (str): Error message if validation fails.
    """

    message = ""  # Initialize the error message

    # If value is not provided and the category is not required, return success with None
    if not raw_data and not is_required:
        return {"success": True, "data": None, "message": ""}

    # If the value is not a string, return an error indicating the value must be a string
    if not isinstance(raw_data, str):
        message = "Invalid shop category: must be a string."

    # If the value is an empty string and the category is required, return an error
    elif len(raw_data.strip()) == 0 and is_required:
        message = "Invalid shop category: cannot be empty."

    else:
        # Sanitize the category by stripping whitespace and capitalizing the first letter
        sanitized_category = raw_data.strip().lower().capitalize()

        # Get the list of valid categories from the default categories handler
        valid_categories = get_default_shop_categories()

        # If the sanitized category is in the list of valid categories, return success
        if sanitized_category in valid_categories:
            return {"success": True, "data": sanitized_category}
        else:
            # Return an error if the category is not recognized
            message = f"Invalid {field_name}: '{raw_data}' is not a recognized category."

    # Return failure with the appropriate error message if any validation step fails
    return {"success": False, "message": message}


================================================================================

Filename: validators/user_validators/validate_shop_contact_details.py
Content:
from validators import general_validators


def validate_shop_contact_details(raw_data, field_name, max_items, min_items, is_required=False, **kwargs):
    """
    Sanitizes the shop contact details.

    Args:
        min_items (int): Minimum number of contacts allowed.
        raw_data (list): List of contact detail dictionaries.
        field_name (str): Label for the field.
        max_items (int): Maximum number of contact details allowed.
        is_required (bool): Whether the field is required.

    Returns:
        dict: A dictionary with sanitization results.
    """
    # If the value is empty and not required, return an empty list
    if not raw_data and not is_required:
        return {"success": True, "data": []}

    # Check if the value is a list
    if not isinstance(raw_data, list):
        return {"success": False, "message": f"{field_name} must be a list of contact details."}

    # Check if the number of contact details exceeds the maximum allowed
    if len(raw_data) > max_items:
        return {"success": False, "message": f"{field_name} can have at most {max_items} entries."}

    # Check if the number of contact details is less than the minimum allowed
    if len(raw_data) < min_items:
        return {"success": False, "message": f"{field_name} should have at least {min_items} entries."}

    # Initialize a list to store sanitized contacts
    sanitized_contacts = []

    # Iterate through each contact in the list
    for contact_info in raw_data:
        # Ensure that contact_info is a dictionary
        if not isinstance(contact_info, dict):
            return {"success": False, "message": f"Each {field_name} entry must be a dictionary."}

        # Initialize a dictionary to store the sanitized contact info
        sanitized_contact = {}

        # Validate contact name
        name_response = general_validators.validate_string(contact_info.get("contactName", ""), 30, "Contact Name",
                                                           True, 1)
        if not name_response["success"]:
            return {"success": False, "message": name_response["message"]}
        sanitized_contact["contactName"] = name_response["data"]

        # Validate email
        email_response = general_validators.validate_email(contact_info.get("email", ""), "Email", True)
        if not email_response["success"]:
            return {"success": False, "message": email_response["message"]}
        sanitized_contact["email"] = email_response["data"]

        # Validate mobile
        mobile_response = general_validators.validate_mobile(contact_info.get("mobile", ""), "Mobile", True)
        if not mobile_response["success"]:
            return {"success": False, "message": mobile_response["message"]}
        sanitized_contact["mobile"] = mobile_response["data"]

        # Validate isWPAvailable
        wp_response = general_validators.validate_boolean(contact_info.get("isWPAvailable", False), "Is WhatsApp Available")
        if not wp_response["success"]:
            return {"success": False, "message": wp_response["message"]}
        sanitized_contact["isWPAvailable"] = wp_response["data"]

        # Add the sanitized contact to the list
        sanitized_contacts.append(sanitized_contact)

    # Return the sanitized contacts
    return {"success": True, "data": sanitized_contacts}

================================================================================

Filename: validators/user_validators/validate_shop_theme_colors.py
Content:
from validators import general_validators


# define the default primary and secondary colors
DEFAULT_PRIMARY_THEME_COLOR = "#516395"
DEFAULT_SECONDARY_THEME_COLOR = "#2E8B57"


def validate_shop_theme_colors(raw_data, field_name, is_required=False, **kwargs):
    global DEFAULT_PRIMARY_THEME_COLOR, DEFAULT_SECONDARY_THEME_COLOR

    """
    Sanitizes the shop theme colors.

    Args:
        value (dict): List of shop theme colors.
        field_name (str): Label for the field.
        is_required (bool): Whether the field is required.

    Returns:
        dict: A List with valid sanitization results.
    """

    # If the value is empty and not required, return the default theme colors list
    if not raw_data and not is_required:
        return {"success": True, "data": [
            DEFAULT_PRIMARY_THEME_COLOR,
            DEFAULT_SECONDARY_THEME_COLOR
        ]}

    # Check if the value is a list
    if not isinstance(raw_data, list):
        return {"success": False, "message": f"{field_name} must be a List of hex color strings of size '2'"}

    # Check if the number of colors is not equal to '2'
    if len(raw_data) != 2:
        return {"success": False, "message": f"{field_name} must have two string of hex colors."}

    # extract primary and secondary theme colors from the theme colors
    primary_theme_color = raw_data[0]
    secondary_theme_color = raw_data[1]

    # Ensure that both theme colors are string
    if (not isinstance(primary_theme_color, str)) or (not isinstance(secondary_theme_color, str)):
        return {"success": False, "message": f"Each {field_name} entry must be a string."}

    # validating and sanitizing the primary theme color
    primary_theme_hex_color_response = general_validators.validate_hex_color(
        raw_data=primary_theme_color,
        field_name="hexColorAtIndex0 (primary theme color)",
        is_required=True
    )
    if not primary_theme_hex_color_response["success"]:
        return {"success": False, "message": primary_theme_hex_color_response["message"]}

    # validating and sanitizing the secondary theme color
    secondary_theme_hex_color_response = general_validators.validate_hex_color(
        raw_data=secondary_theme_color,
        field_name="hexColorAtIndex1 (secondary theme color)",
        is_required=True
    )
    if not secondary_theme_hex_color_response["success"]:
        return {"success": False, "message": secondary_theme_hex_color_response["message"]}

    # Return the sanitized theme colors
    return {"success": True, "data": raw_data}


================================================================================

Filename: validators/user_validators/validate_shop_timings.py
Content:
def validate_shop_timings(raw_data, field_name, is_required=False, **kwargs):
    """
    Sanitizes and validates shop timings.

    Args:
        raw_data (Dict): The shop timing dictionary.
        field_name (str): The label of the field for error messages.
        is_required (bool): Whether the field is required.

    Returns:
        Dict: A dictionary with 'success', 'data', and 'message' keys.
    """
    if not raw_data and not is_required:
        return {"success": True, "data": None, "message": ""}

    if not raw_data and is_required:
        return {"success": False, "data": None, "message": f"{field_name} is required."}

    required_keys = ["generalTimings", "inStore", "takeaway", "delivery"]
    days_of_week = ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]

    sanitized_timings = {}
    errors = []

    for key in required_keys:
        # Check if the required key exists in the input value
        if key not in raw_data:
            # If not, add an error message
            errors.append(f"Missing '{key}' in {field_name}")
        else:
            # Initialize the dictionary for this timing type
            sanitized_timings[key] = {}
            # Iterate through each day of the week
            for day in days_of_week:
                # Get the time range for this day (None if not present)
                time_range = raw_data[key].get(day, "None")
                # If the time range is None, the shop is closed on this day
                if time_range is None:
                    sanitized_timings[key][day] = None
                # If the time range is a list, process it
                elif isinstance(time_range, list):
                    # If the list has exactly two elements, it should be a valid time range
                    if len(time_range) == 2:
                        try:
                            # Convert the time range to integers
                            start, end = map(int, time_range)
                            # Check if the times are within valid range (0000 to 2359)
                            if 0 <= start < 2400 and 0 <= end < 2400 and end > start:
                                sanitized_timings[key][day] = [start, end]
                            else:
                                # If not in valid range, add an error
                                errors.append(f"Invalid time range for {day} in {key}")
                        except ValueError:
                            # If conversion to int fails, add an error
                            errors.append(f"Invalid time format for {day} in {key}")
                    else:
                        # If the list doesn't have 0 or 2 elements, it's invalid
                        errors.append(f"Invalid time range for {day} in {key}")
                else:
                    # If the value is neither None nor a list, it's invalid
                    errors.append(f"Invalid value for {day} in {key}")

    # If there are any errors, return failure with error messages
    if errors:
        return {"success": False, "message": "; ".join(errors)}
    else:
        # If no errors, return success with the sanitized timings
        return {"success": True, "data": sanitized_timings}


================================================================================

Filename: validators/validate.py
Content:
from flask import abort
from validators.general_validators import *
from validators.inventory_validators import *
from validators.user_validators import *


# create a function to wrap the validators
VALIDATORS = {
    "validate_string": validate_string,
    "validate_item": validate_item,
    "validate_alphanumeric_string": validate_alphanumeric_string,
    "validate_item_ingredients": validate_item_ingredients,
    "validate_item_nutritional_info": validate_item_nutritional_info,
    "validate_item_tags": validate_item_tags,
    "validate_item_variants": validate_item_variants,
    "validate_boolean": validate_boolean,
    "validate_email": validate_email,
    "validate_geo_point": validate_geo_point,
    "validate_hex_color": validate_hex_color,
    "validate_image": validate_image,
    "validate_index": validate_index,
    "validate_list_of_urls": validate_list_of_urls,
    "validate_mobile": validate_mobile,
    "validate_url": validate_url,
    "validate_gst_number": validate_gst_number,
    "validate_shop_category": validate_shop_category,
    "validate_shop_contact_details": validate_shop_contact_details,
    "validate_shop_timings": validate_shop_timings,
    "validate_shop_theme_colors": validate_shop_theme_colors
}


def validate(raw_data, validator, **kwargs):
    """
    Validates data using the specified validator function.
    If validator is "pass", returns the raw data unchanged.

    Args:
        raw_data: The data to validate
        validator: String name of validator function or "pass"
        **kwargs: Additional arguments to pass to the validator function

    Returns:
        Validated data if validator specified, otherwise raw data unchanged
    """

    if not validator:
        return {"success": True, "data": raw_data, "message": ""}

    if VALIDATORS.get(validator, None) is None:
        abort(500, f"Invalid validator: {validator}")

    return VALIDATORS[validator](raw_data=raw_data, **kwargs)


def validate_data(request_data, schema):
    """
    Args:
        request_data: data retrieved from api request
        schema: semi_restx_dict for that api endpoint

    Returns: validated data
    """

    validated_data = {}

    for field_details in schema["fields"]:
        field_name = field_details.get("field_name", "")
        is_field_required = field_details.get('required', False)
        field_data = request_data.get(field_name, None)  # field data obtained from the request body (raw_data)

        # Check if the field is required and missing/empty
        if is_field_required and (not field_data):
            abort(400, f"Missing/Empty required field: {field_name}")

        # fetch the field validator
        field_validator = field_details.get("validator", None)

        if field_validator:
            # apply validation
            validation_result = validate(raw_data=field_data, **field_details)

            # If validation failed, return an error
            if not validation_result['success']:
                abort(400, validation_result['message'])

            # Add validated field to the result
            validated_data[field_name] = validation_result['data']

        else:
            # Add field as it is to the result
            validated_data[field_name] = field_data

    return validated_data


================================================================================

Filename: validators/validate_request_data.py
Content:
from flask import g
from functools import wraps
from flask import request
from flask_restx import abort
from validators.validate import validate_data


# Decorator to validate request data based on the schema provided
def validate_request_data(semi_restx_dict):
    def decorator(f):
        @wraps(f)
        def wrapper(*args, **kwargs):
            # get the request data
            json_data = request.get_json()
            if not json_data:
                abort(400, "No input data provided")

            # Validate the data using the loaded schema
            validated_data = validate_data(
                request_data=json_data,
                schema=semi_restx_dict
            )

            # Store validated data in Flask's global object
            g.validated_data = validated_data

            return f(*args, **kwargs)

        return wrapper

    return decorator


def get_validated_data():
    """Retrieve validated data stored in Flask's `g` object."""
    if hasattr(g, 'validated_data'):
        return g.validated_data
    raise RuntimeError("No validated data found. Did you forget to use the @validate_request_data decorator?")

================================================================================

Filename: validators/validate_request_form.py
Content:
from flask import g
from functools import wraps
from flask import request
from flask_restx import abort
from validators.validate import validate_data


# Decorator to validate request form data based on the schema provided
def validate_request_form(semi_restx_dict):
    def decorator(f):
        @wraps(f)
        def wrapper(*args, **kwargs):
            # Get form data
            form_data = request.form.to_dict()
            if not form_data:
                abort(400, "No form data provided")

            # Validate the form data using the loaded schema
            validated_form = validate_data(
                request_data=form_data,
                schema=semi_restx_dict
            )

            # Store validated data in Flask's global object
            g.validated_form = validated_form

            return f(*args, **kwargs)

        return wrapper

    return decorator


def get_validated_form():
    """Retrieve validated form stored in Flask's `g` object."""
    if hasattr(g, 'validated_form'):
        return g.validated_data
    raise RuntimeError("No validated form found. Did you forget to use the @validate_request_form decorator?")

================================================================================
